// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for CouchbaseLiteC
class CblCBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  CblCBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  CblCBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Equality test of two slices.
  bool FLSlice_Equal(
    FLSlice a,
    FLSlice b,
  ) {
    return _FLSlice_Equal(
          a,
          b,
        ) !=
        0;
  }

  late final _FLSlice_Equal_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlice_Equal>>('FLSlice_Equal');
  late final _dart_FLSlice_Equal _FLSlice_Equal =
      _FLSlice_Equal_ptr.asFunction<_dart_FLSlice_Equal>();

  /// Lexicographic comparison of two slices; basically like memcmp(), but taking into account
  /// differences in length.
  int FLSlice_Compare(
    FLSlice arg0,
    FLSlice arg1,
  ) {
    return _FLSlice_Compare(
      arg0,
      arg1,
    );
  }

  late final _FLSlice_Compare_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlice_Compare>>('FLSlice_Compare');
  late final _dart_FLSlice_Compare _FLSlice_Compare =
      _FLSlice_Compare_ptr.asFunction<_dart_FLSlice_Compare>();

  /// Allocates an FLSliceResult of the given size, without initializing the buffer.
  FLSliceResult FLSliceResult_New(
    int arg0,
  ) {
    return _FLSliceResult_New(
      arg0,
    );
  }

  late final _FLSliceResult_New_ptr =
      _lookup<ffi.NativeFunction<_c_FLSliceResult_New>>('FLSliceResult_New');
  late final _dart_FLSliceResult_New _FLSliceResult_New =
      _FLSliceResult_New_ptr.asFunction<_dart_FLSliceResult_New>();

  /// Allocates an FLSliceResult, copying the given slice.
  FLSliceResult FLSlice_Copy(
    FLSlice arg0,
  ) {
    return _FLSlice_Copy(
      arg0,
    );
  }

  late final _FLSlice_Copy_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlice_Copy>>('FLSlice_Copy');
  late final _dart_FLSlice_Copy _FLSlice_Copy =
      _FLSlice_Copy_ptr.asFunction<_dart_FLSlice_Copy>();

  void FLBuf_Retain(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _FLBuf_Retain(
      arg0,
    );
  }

  late final _FLBuf_Retain_ptr =
      _lookup<ffi.NativeFunction<_c_FLBuf_Retain>>('_FLBuf_Retain');
  late final _dart_FLBuf_Retain _FLBuf_Retain =
      _FLBuf_Retain_ptr.asFunction<_dart_FLBuf_Retain>();

  void FLBuf_Release(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _FLBuf_Release(
      arg0,
    );
  }

  late final _FLBuf_Release_ptr =
      _lookup<ffi.NativeFunction<_c_FLBuf_Release>>('_FLBuf_Release');
  late final _dart_FLBuf_Release _FLBuf_Release =
      _FLBuf_Release_ptr.asFunction<_dart_FLBuf_Release>();

  /// Returns a message describing an error.
  /// @note  It is the caller's responsibility to free the returned C string by calling `free`.
  ffi.Pointer<ffi.Int8> CBLError_Message(
    ffi.Pointer<CBLError> arg0,
  ) {
    return _CBLError_Message(
      arg0,
    );
  }

  late final _CBLError_Message_ptr =
      _lookup<ffi.NativeFunction<_c_CBLError_Message>>('CBLError_Message');
  late final _dart_CBLError_Message _CBLError_Message =
      _CBLError_Message_ptr.asFunction<_dart_CBLError_Message>();

  FLSliceResult CBLError_Message_s(
    ffi.Pointer<CBLError> arg0,
  ) {
    return _CBLError_Message_s(
      arg0,
    );
  }

  late final _CBLError_Message_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLError_Message_s>>('CBLError_Message_s');
  late final _dart_CBLError_Message_s _CBLError_Message_s =
      _CBLError_Message_s_ptr.asFunction<_dart_CBLError_Message_s>();

  /// Returns the current time, in milliseconds since 1/1/1970.
  int CBL_Now() {
    return _CBL_Now();
  }

  late final _CBL_Now_ptr = _lookup<ffi.NativeFunction<_c_CBL_Now>>('CBL_Now');
  late final _dart_CBL_Now _CBL_Now = _CBL_Now_ptr.asFunction<_dart_CBL_Now>();

  /// Increments an object's reference-count.
  /// Usually you'll call one of the type-safe synonyms specific to the object type,
  /// like \ref CBLDatabase_Retain`
  ffi.Pointer<CBLRefCounted> CBL_Retain(
    ffi.Pointer<CBLRefCounted> arg0,
  ) {
    return _CBL_Retain(
      arg0,
    );
  }

  late final _CBL_Retain_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_Retain>>('CBL_Retain');
  late final _dart_CBL_Retain _CBL_Retain =
      _CBL_Retain_ptr.asFunction<_dart_CBL_Retain>();

  /// Decrements an object's reference-count, freeing the object if the count hits zero.
  /// Usually you'll call one of the type-safe synonyms specific to the object type,
  /// like \ref CBLDatabase_Release.
  void CBL_Release(
    ffi.Pointer<CBLRefCounted> arg0,
  ) {
    return _CBL_Release(
      arg0,
    );
  }

  late final _CBL_Release_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_Release>>('CBL_Release');
  late final _dart_CBL_Release _CBL_Release =
      _CBL_Release_ptr.asFunction<_dart_CBL_Release>();

  /// Returns the total number of Couchbase Lite objects. Useful for leak checking.
  int CBL_InstanceCount() {
    return _CBL_InstanceCount();
  }

  late final _CBL_InstanceCount_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_InstanceCount>>('CBL_InstanceCount');
  late final _dart_CBL_InstanceCount _CBL_InstanceCount =
      _CBL_InstanceCount_ptr.asFunction<_dart_CBL_InstanceCount>();

  /// Logs the class and address of each Couchbase Lite object. Useful for leak checking.
  /// @note  May only be functional in debug builds of Couchbase Lite.
  void CBL_DumpInstances() {
    return _CBL_DumpInstances();
  }

  late final _CBL_DumpInstances_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_DumpInstances>>('CBL_DumpInstances');
  late final _dart_CBL_DumpInstances _CBL_DumpInstances =
      _CBL_DumpInstances_ptr.asFunction<_dart_CBL_DumpInstances>();

  /// Removes a listener callback, given the token that was returned when it was added.
  void CBLListener_Remove(
    ffi.Pointer<CBLListenerToken> arg0,
  ) {
    return _CBLListener_Remove(
      arg0,
    );
  }

  late final _CBLListener_Remove_ptr =
      _lookup<ffi.NativeFunction<_c_CBLListener_Remove>>('CBLListener_Remove');
  late final _dart_CBLListener_Remove _CBLListener_Remove =
      _CBLListener_Remove_ptr.asFunction<_dart_CBLListener_Remove>();

  /// Creates an FLDoc from Fleece-encoded data that's been returned as a result from
  /// FLSlice_Copy or other API. The resulting document retains the data, so you don't need to
  /// worry about it remaining valid.
  ffi.Pointer<FLDoc> FLDoc_FromResultData(
    FLSliceResult data,
    int arg1,
    ffi.Pointer<FLSharedKeys> arg2,
    FLSlice externData,
  ) {
    return _FLDoc_FromResultData(
      data,
      arg1,
      arg2,
      externData,
    );
  }

  late final _FLDoc_FromResultData_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_FromResultData>>(
          'FLDoc_FromResultData');
  late final _dart_FLDoc_FromResultData _FLDoc_FromResultData =
      _FLDoc_FromResultData_ptr.asFunction<_dart_FLDoc_FromResultData>();

  /// Creates an FLDoc from JSON-encoded data. The data is first encoded into Fleece, and the
  /// Fleece data is kept by the doc; the input JSON data is no longer needed after this
  /// function returns.
  ffi.Pointer<FLDoc> FLDoc_FromJSON(
    FLSlice json,
    ffi.Pointer<ffi.Int32> outError,
  ) {
    return _FLDoc_FromJSON(
      json,
      outError,
    );
  }

  late final _FLDoc_FromJSON_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_FromJSON>>('FLDoc_FromJSON');
  late final _dart_FLDoc_FromJSON _FLDoc_FromJSON =
      _FLDoc_FromJSON_ptr.asFunction<_dart_FLDoc_FromJSON>();

  /// Releases a reference to an FLDoc. This must be called once to free an FLDoc you created.
  void FLDoc_Release(
    ffi.Pointer<FLDoc> arg0,
  ) {
    return _FLDoc_Release(
      arg0,
    );
  }

  late final _FLDoc_Release_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_Release>>('FLDoc_Release');
  late final _dart_FLDoc_Release _FLDoc_Release =
      _FLDoc_Release_ptr.asFunction<_dart_FLDoc_Release>();

  /// Adds a reference to an FLDoc. This extends its lifespan until at least such time as you
  /// call FLRelease to remove the reference.
  ffi.Pointer<FLDoc> FLDoc_Retain(
    ffi.Pointer<FLDoc> arg0,
  ) {
    return _FLDoc_Retain(
      arg0,
    );
  }

  late final _FLDoc_Retain_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_Retain>>('FLDoc_Retain');
  late final _dart_FLDoc_Retain _FLDoc_Retain =
      _FLDoc_Retain_ptr.asFunction<_dart_FLDoc_Retain>();

  /// Returns the encoded Fleece data backing the document.
  FLSlice FLDoc_GetData(
    ffi.Pointer<FLDoc> arg0,
  ) {
    return _FLDoc_GetData(
      arg0,
    );
  }

  late final _FLDoc_GetData_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_GetData>>('FLDoc_GetData');
  late final _dart_FLDoc_GetData _FLDoc_GetData =
      _FLDoc_GetData_ptr.asFunction<_dart_FLDoc_GetData>();

  /// Returns the FLSliceResult data owned by the document, if any, else a null slice.
  FLSliceResult FLDoc_GetAllocedData(
    ffi.Pointer<FLDoc> arg0,
  ) {
    return _FLDoc_GetAllocedData(
      arg0,
    );
  }

  late final _FLDoc_GetAllocedData_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_GetAllocedData>>(
          'FLDoc_GetAllocedData');
  late final _dart_FLDoc_GetAllocedData _FLDoc_GetAllocedData =
      _FLDoc_GetAllocedData_ptr.asFunction<_dart_FLDoc_GetAllocedData>();

  /// Returns the root value in the FLDoc, usually an FLDict.
  ffi.Pointer<FLValue> FLDoc_GetRoot(
    ffi.Pointer<FLDoc> arg0,
  ) {
    return _FLDoc_GetRoot(
      arg0,
    );
  }

  late final _FLDoc_GetRoot_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_GetRoot>>('FLDoc_GetRoot');
  late final _dart_FLDoc_GetRoot _FLDoc_GetRoot =
      _FLDoc_GetRoot_ptr.asFunction<_dart_FLDoc_GetRoot>();

  /// Returns the FLSharedKeys used by this FLDoc, as specified when it was created.
  ffi.Pointer<FLSharedKeys> FLDoc_GetSharedKeys(
    ffi.Pointer<FLDoc> arg0,
  ) {
    return _FLDoc_GetSharedKeys(
      arg0,
    );
  }

  late final _FLDoc_GetSharedKeys_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_GetSharedKeys>>(
          'FLDoc_GetSharedKeys');
  late final _dart_FLDoc_GetSharedKeys _FLDoc_GetSharedKeys =
      _FLDoc_GetSharedKeys_ptr.asFunction<_dart_FLDoc_GetSharedKeys>();

  /// Looks up the Doc containing the Value, or NULL if the Value was created without a Doc.
  /// Caller must release the FLDoc reference!!
  ffi.Pointer<FLDoc> FLValue_FindDoc(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_FindDoc(
      arg0,
    );
  }

  late final _FLValue_FindDoc_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_FindDoc>>('FLValue_FindDoc');
  late final _dart_FLValue_FindDoc _FLValue_FindDoc =
      _FLValue_FindDoc_ptr.asFunction<_dart_FLValue_FindDoc>();

  /// Returns a pointer to the root value in the encoded data, or NULL if validation failed.
  /// The FLValue, and all values found through it, are only valid as long as the encoded data
  /// remains intact and unchanged.
  ffi.Pointer<FLValue> FLValue_FromData(
    FLSlice data,
    int arg1,
  ) {
    return _FLValue_FromData(
      data,
      arg1,
    );
  }

  late final _FLValue_FromData_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_FromData>>('FLValue_FromData');
  late final _dart_FLValue_FromData _FLValue_FromData =
      _FLValue_FromData_ptr.asFunction<_dart_FLValue_FromData>();

  /// Directly converts JSON data to Fleece-encoded data.
  /// You can then call FLValue_FromData (in kFLTrusted mode) to get the root as a Value.
  FLSliceResult FLData_ConvertJSON(
    FLSlice json,
    ffi.Pointer<ffi.Int32> outError,
  ) {
    return _FLData_ConvertJSON(
      json,
      outError,
    );
  }

  late final _FLData_ConvertJSON_ptr =
      _lookup<ffi.NativeFunction<_c_FLData_ConvertJSON>>('FLData_ConvertJSON');
  late final _dart_FLData_ConvertJSON _FLData_ConvertJSON =
      _FLData_ConvertJSON_ptr.asFunction<_dart_FLData_ConvertJSON>();

  /// Produces a human-readable dump of the Value encoded in the data.
  /// This is only useful if you already know, or want to learn, the encoding format.
  FLSliceResult FLData_Dump(
    FLSlice data,
  ) {
    return _FLData_Dump(
      data,
    );
  }

  late final _FLData_Dump_ptr =
      _lookup<ffi.NativeFunction<_c_FLData_Dump>>('FLData_Dump');
  late final _dart_FLData_Dump _FLData_Dump =
      _FLData_Dump_ptr.asFunction<_dart_FLData_Dump>();

  /// Encodes a Fleece value as JSON (or a JSON fragment.)
  /// Any Data values will become base64-encoded JSON strings.
  FLSliceResult FLValue_ToJSON(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_ToJSON(
      arg0,
    );
  }

  late final _FLValue_ToJSON_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_ToJSON>>('FLValue_ToJSON');
  late final _dart_FLValue_ToJSON _FLValue_ToJSON =
      _FLValue_ToJSON_ptr.asFunction<_dart_FLValue_ToJSON>();

  /// Encodes a Fleece value as JSON5, a more lenient variant of JSON that allows dictionary
  /// keys to be unquoted if they're alphanumeric. This tends to be more readable.
  FLSliceResult FLValue_ToJSON5(
    ffi.Pointer<FLValue> v,
  ) {
    return _FLValue_ToJSON5(
      v,
    );
  }

  late final _FLValue_ToJSON5_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_ToJSON5>>('FLValue_ToJSON5');
  late final _dart_FLValue_ToJSON5 _FLValue_ToJSON5 =
      _FLValue_ToJSON5_ptr.asFunction<_dart_FLValue_ToJSON5>();

  /// Most general Fleece to JSON converter.
  FLSliceResult FLValue_ToJSONX(
    ffi.Pointer<FLValue> v,
    bool json5,
    bool canonicalForm,
  ) {
    return _FLValue_ToJSONX(
      v,
      json5 ? 1 : 0,
      canonicalForm ? 1 : 0,
    );
  }

  late final _FLValue_ToJSONX_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_ToJSONX>>('FLValue_ToJSONX');
  late final _dart_FLValue_ToJSONX _FLValue_ToJSONX =
      _FLValue_ToJSONX_ptr.asFunction<_dart_FLValue_ToJSONX>();

  /// Converts valid JSON5 <https://json5.org> to JSON. Among other things, it converts single
  /// quotes to double, adds missing quotes around dictionary keys, removes trailing commas,
  /// and removes comments.
  /// @note If given invalid JSON5, it will _usually_ return an error, but may just ouput
  /// comparably invalid JSON, in which case the caller's subsequent JSON parsing will
  /// detect the error. The types of errors it overlooks tend to be subtleties of string
  /// or number encoding.
  /// @param json5  The JSON5 to parse
  /// @param outErrorMessage  On failure, the error message will be stored here (if not NULL.)
  /// As this is a \ref FLStringResult, you will be responsible for freeing it.
  /// @param outErrorPos  On a parse error, the byte offset in the input where the error occurred
  /// will be stored here (if it's not NULL.)
  /// @param outError  On failure, the error code will be stored here (if it's not NULL.)
  /// @return  The converted JSON.
  FLSliceResult FLJSON5_ToJSON(
    FLSlice json5,
    ffi.Pointer<FLSliceResult> outErrorMessage,
    ffi.Pointer<ffi.Uint64> outErrorPos,
    ffi.Pointer<ffi.Int32> outError,
  ) {
    return _FLJSON5_ToJSON(
      json5,
      outErrorMessage,
      outErrorPos,
      outError,
    );
  }

  late final _FLJSON5_ToJSON_ptr =
      _lookup<ffi.NativeFunction<_c_FLJSON5_ToJSON>>('FLJSON5_ToJSON');
  late final _dart_FLJSON5_ToJSON _FLJSON5_ToJSON =
      _FLJSON5_ToJSON_ptr.asFunction<_dart_FLJSON5_ToJSON>();

  /// \name Debugging Functions
  /// @{ */
  /// /** Debugging function that returns a C string of JSON. Does not free the string's memory!
  ffi.Pointer<ffi.Int8> FLDump(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLDump(
      arg0,
    );
  }

  late final _FLDump_ptr = _lookup<ffi.NativeFunction<_c_FLDump>>('FLDump');
  late final _dart_FLDump _FLDump = _FLDump_ptr.asFunction<_dart_FLDump>();

  /// Debugging function that returns a C string of JSON. Does not free the string's memory!
  ffi.Pointer<ffi.Int8> FLDumpData(
    FLSlice data,
  ) {
    return _FLDumpData(
      data,
    );
  }

  late final _FLDumpData_ptr =
      _lookup<ffi.NativeFunction<_c_FLDumpData>>('FLDumpData');
  late final _dart_FLDumpData _FLDumpData =
      _FLDumpData_ptr.asFunction<_dart_FLDumpData>();

  /// Returns the data type of an arbitrary Value.
  /// (If the parameter is a NULL pointer, returns `kFLUndefined`.)
  int FLValue_GetType(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_GetType(
      arg0,
    );
  }

  late final _FLValue_GetType_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_GetType>>('FLValue_GetType');
  late final _dart_FLValue_GetType _FLValue_GetType =
      _FLValue_GetType_ptr.asFunction<_dart_FLValue_GetType>();

  /// Returns true if the value is non-NULL and represents an integer.
  bool FLValue_IsInteger(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_IsInteger(
          arg0,
        ) !=
        0;
  }

  late final _FLValue_IsInteger_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_IsInteger>>('FLValue_IsInteger');
  late final _dart_FLValue_IsInteger _FLValue_IsInteger =
      _FLValue_IsInteger_ptr.asFunction<_dart_FLValue_IsInteger>();

  /// Returns true if the value is non-NULL and represents an integer >= 2^63. Such a value can't
  /// be represented in C as an `int64_t`, only a `uint64_t`, so you should access it by calling
  /// `FLValueAsUnsigned`, _not_ FLValueAsInt, which would return  an incorrect (negative)
  /// value.
  bool FLValue_IsUnsigned(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_IsUnsigned(
          arg0,
        ) !=
        0;
  }

  late final _FLValue_IsUnsigned_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_IsUnsigned>>('FLValue_IsUnsigned');
  late final _dart_FLValue_IsUnsigned _FLValue_IsUnsigned =
      _FLValue_IsUnsigned_ptr.asFunction<_dart_FLValue_IsUnsigned>();

  /// Returns true if the value is non-NULL and represents a 64-bit floating-point number.
  bool FLValue_IsDouble(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_IsDouble(
          arg0,
        ) !=
        0;
  }

  late final _FLValue_IsDouble_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_IsDouble>>('FLValue_IsDouble');
  late final _dart_FLValue_IsDouble _FLValue_IsDouble =
      _FLValue_IsDouble_ptr.asFunction<_dart_FLValue_IsDouble>();

  /// Returns a value coerced to boolean. This will be true unless the value is NULL (undefined),
  /// null, false, or zero.
  bool FLValue_AsBool(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsBool(
          arg0,
        ) !=
        0;
  }

  late final _FLValue_AsBool_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsBool>>('FLValue_AsBool');
  late final _dart_FLValue_AsBool _FLValue_AsBool =
      _FLValue_AsBool_ptr.asFunction<_dart_FLValue_AsBool>();

  /// Returns a value coerced to an integer. True and false are returned as 1 and 0, and
  /// floating-point numbers are rounded. All other types are returned as 0.
  /// @warning  Large 64-bit unsigned integers (2^63 and above) will come out wrong. You can
  /// check for these by calling `FLValueIsUnsigned`.
  int FLValue_AsInt(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsInt(
      arg0,
    );
  }

  late final _FLValue_AsInt_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsInt>>('FLValue_AsInt');
  late final _dart_FLValue_AsInt _FLValue_AsInt =
      _FLValue_AsInt_ptr.asFunction<_dart_FLValue_AsInt>();

  /// Returns a value coerced to an unsigned integer.
  /// This is the same as `FLValueAsInt` except that it _can't_ handle negative numbers, but
  /// does correctly return large `uint64_t` values of 2^63 and up.
  int FLValue_AsUnsigned(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsUnsigned(
      arg0,
    );
  }

  late final _FLValue_AsUnsigned_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsUnsigned>>('FLValue_AsUnsigned');
  late final _dart_FLValue_AsUnsigned _FLValue_AsUnsigned =
      _FLValue_AsUnsigned_ptr.asFunction<_dart_FLValue_AsUnsigned>();

  /// Returns a value coerced to a 32-bit floating point number.
  /// True and false are returned as 1.0 and 0.0, and integers are converted to float. All other
  /// types are returned as 0.0.
  /// @warning  Large integers (outside approximately +/- 2^23) will lose precision due to the
  /// limitations of IEEE 32-bit float format.
  double FLValue_AsFloat(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsFloat(
      arg0,
    );
  }

  late final _FLValue_AsFloat_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsFloat>>('FLValue_AsFloat');
  late final _dart_FLValue_AsFloat _FLValue_AsFloat =
      _FLValue_AsFloat_ptr.asFunction<_dart_FLValue_AsFloat>();

  /// Returns a value coerced to a 32-bit floating point number.
  /// True and false are returned as 1.0 and 0.0, and integers are converted to float. All other
  /// types are returned as 0.0.
  /// @warning  Very large integers (outside approximately +/- 2^50) will lose precision due to
  /// the limitations of IEEE 32-bit float format.
  double FLValue_AsDouble(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsDouble(
      arg0,
    );
  }

  late final _FLValue_AsDouble_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsDouble>>('FLValue_AsDouble');
  late final _dart_FLValue_AsDouble _FLValue_AsDouble =
      _FLValue_AsDouble_ptr.asFunction<_dart_FLValue_AsDouble>();

  /// Returns the exact contents of a string value, or null for all other types.
  FLSlice FLValue_AsString(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsString(
      arg0,
    );
  }

  late final _FLValue_AsString_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsString>>('FLValue_AsString');
  late final _dart_FLValue_AsString _FLValue_AsString =
      _FLValue_AsString_ptr.asFunction<_dart_FLValue_AsString>();

  /// Converts a value to a timestamp, in milliseconds since Unix epoch, or INT64_MIN on failure.
  /// - A string is parsed as ISO-8601 (standard JSON date format).
  /// - A number is interpreted as a timestamp and returned as-is.
  int FLValue_AsTimestamp(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsTimestamp(
      arg0,
    );
  }

  late final _FLValue_AsTimestamp_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsTimestamp>>(
          'FLValue_AsTimestamp');
  late final _dart_FLValue_AsTimestamp _FLValue_AsTimestamp =
      _FLValue_AsTimestamp_ptr.asFunction<_dart_FLValue_AsTimestamp>();

  /// Returns the exact contents of a data value, or null for all other types.
  FLSlice FLValue_AsData(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsData(
      arg0,
    );
  }

  late final _FLValue_AsData_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsData>>('FLValue_AsData');
  late final _dart_FLValue_AsData _FLValue_AsData =
      _FLValue_AsData_ptr.asFunction<_dart_FLValue_AsData>();

  /// If a FLValue represents an array, returns it cast to FLArray, else NULL.
  ffi.Pointer<FLArray> FLValue_AsArray(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsArray(
      arg0,
    );
  }

  late final _FLValue_AsArray_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsArray>>('FLValue_AsArray');
  late final _dart_FLValue_AsArray _FLValue_AsArray =
      _FLValue_AsArray_ptr.asFunction<_dart_FLValue_AsArray>();

  /// If a FLValue represents a dictionary, returns it as an FLDict, else NULL.
  ffi.Pointer<FLDict> FLValue_AsDict(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsDict(
      arg0,
    );
  }

  late final _FLValue_AsDict_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsDict>>('FLValue_AsDict');
  late final _dart_FLValue_AsDict _FLValue_AsDict =
      _FLValue_AsDict_ptr.asFunction<_dart_FLValue_AsDict>();

  /// Returns a string representation of any scalar value. Data values are returned in raw form.
  /// Arrays and dictionaries don't have a representation and will return NULL.
  FLSliceResult FLValue_ToString(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_ToString(
      arg0,
    );
  }

  late final _FLValue_ToString_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_ToString>>('FLValue_ToString');
  late final _dart_FLValue_ToString _FLValue_ToString =
      _FLValue_ToString_ptr.asFunction<_dart_FLValue_ToString>();

  /// Compares two values for equality. This is a deep recursive comparison.
  bool FLValue_IsEqual(
    ffi.Pointer<FLValue> v1,
    ffi.Pointer<FLValue> v2,
  ) {
    return _FLValue_IsEqual(
          v1,
          v2,
        ) !=
        0;
  }

  late final _FLValue_IsEqual_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_IsEqual>>('FLValue_IsEqual');
  late final _dart_FLValue_IsEqual _FLValue_IsEqual =
      _FLValue_IsEqual_ptr.asFunction<_dart_FLValue_IsEqual>();

  /// If this value is mutable (and thus heap-based) its ref-count is incremented.
  /// Otherwise, this call does nothing.
  ffi.Pointer<FLValue> FLValue_Retain(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_Retain(
      arg0,
    );
  }

  late final _FLValue_Retain_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_Retain>>('FLValue_Retain');
  late final _dart_FLValue_Retain _FLValue_Retain =
      _FLValue_Retain_ptr.asFunction<_dart_FLValue_Retain>();

  /// If this value is mutable (and thus heap-based) its ref-count is decremented, and if it
  /// reaches zero the value is freed.
  /// If the value is not mutable, this call does nothing.
  void FLValue_Release(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_Release(
      arg0,
    );
  }

  late final _FLValue_Release_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_Release>>('FLValue_Release');
  late final _dart_FLValue_Release _FLValue_Release =
      _FLValue_Release_ptr.asFunction<_dart_FLValue_Release>();

  /// ///// VALUE SLOT
  void FLSlot_SetNull(
    ffi.Pointer<FLSlot> arg0,
  ) {
    return _FLSlot_SetNull(
      arg0,
    );
  }

  late final _FLSlot_SetNull_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetNull>>('FLSlot_SetNull');
  late final _dart_FLSlot_SetNull _FLSlot_SetNull =
      _FLSlot_SetNull_ptr.asFunction<_dart_FLSlot_SetNull>();

  void FLSlot_SetBool(
    ffi.Pointer<FLSlot> arg0,
    bool arg1,
  ) {
    return _FLSlot_SetBool(
      arg0,
      arg1 ? 1 : 0,
    );
  }

  late final _FLSlot_SetBool_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetBool>>('FLSlot_SetBool');
  late final _dart_FLSlot_SetBool _FLSlot_SetBool =
      _FLSlot_SetBool_ptr.asFunction<_dart_FLSlot_SetBool>();

  void FLSlot_SetInt(
    ffi.Pointer<FLSlot> arg0,
    int arg1,
  ) {
    return _FLSlot_SetInt(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetInt_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetInt>>('FLSlot_SetInt');
  late final _dart_FLSlot_SetInt _FLSlot_SetInt =
      _FLSlot_SetInt_ptr.asFunction<_dart_FLSlot_SetInt>();

  void FLSlot_SetUInt(
    ffi.Pointer<FLSlot> arg0,
    int arg1,
  ) {
    return _FLSlot_SetUInt(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetUInt_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetUInt>>('FLSlot_SetUInt');
  late final _dart_FLSlot_SetUInt _FLSlot_SetUInt =
      _FLSlot_SetUInt_ptr.asFunction<_dart_FLSlot_SetUInt>();

  void FLSlot_SetFloat(
    ffi.Pointer<FLSlot> arg0,
    double arg1,
  ) {
    return _FLSlot_SetFloat(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetFloat_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetFloat>>('FLSlot_SetFloat');
  late final _dart_FLSlot_SetFloat _FLSlot_SetFloat =
      _FLSlot_SetFloat_ptr.asFunction<_dart_FLSlot_SetFloat>();

  void FLSlot_SetDouble(
    ffi.Pointer<FLSlot> arg0,
    double arg1,
  ) {
    return _FLSlot_SetDouble(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetDouble_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetDouble>>('FLSlot_SetDouble');
  late final _dart_FLSlot_SetDouble _FLSlot_SetDouble =
      _FLSlot_SetDouble_ptr.asFunction<_dart_FLSlot_SetDouble>();

  void FLSlot_SetString(
    ffi.Pointer<FLSlot> arg0,
    FLSlice arg1,
  ) {
    return _FLSlot_SetString(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetString_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetString>>('FLSlot_SetString');
  late final _dart_FLSlot_SetString _FLSlot_SetString =
      _FLSlot_SetString_ptr.asFunction<_dart_FLSlot_SetString>();

  void FLSlot_SetData(
    ffi.Pointer<FLSlot> arg0,
    FLSlice arg1,
  ) {
    return _FLSlot_SetData(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetData_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetData>>('FLSlot_SetData');
  late final _dart_FLSlot_SetData _FLSlot_SetData =
      _FLSlot_SetData_ptr.asFunction<_dart_FLSlot_SetData>();

  void FLSlot_SetValue(
    ffi.Pointer<FLSlot> arg0,
    ffi.Pointer<FLValue> arg1,
  ) {
    return _FLSlot_SetValue(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetValue_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetValue>>('FLSlot_SetValue');
  late final _dart_FLSlot_SetValue _FLSlot_SetValue =
      _FLSlot_SetValue_ptr.asFunction<_dart_FLSlot_SetValue>();

  /// Returns the number of items in an array, or 0 if the pointer is NULL.
  int FLArray_Count(
    ffi.Pointer<FLArray> arg0,
  ) {
    return _FLArray_Count(
      arg0,
    );
  }

  late final _FLArray_Count_ptr =
      _lookup<ffi.NativeFunction<_c_FLArray_Count>>('FLArray_Count');
  late final _dart_FLArray_Count _FLArray_Count =
      _FLArray_Count_ptr.asFunction<_dart_FLArray_Count>();

  /// Returns true if an array is empty (or NULL). Depending on the array's representation,
  /// this can be faster than `FLArray_Count(a) == 0`
  bool FLArray_IsEmpty(
    ffi.Pointer<FLArray> arg0,
  ) {
    return _FLArray_IsEmpty(
          arg0,
        ) !=
        0;
  }

  late final _FLArray_IsEmpty_ptr =
      _lookup<ffi.NativeFunction<_c_FLArray_IsEmpty>>('FLArray_IsEmpty');
  late final _dart_FLArray_IsEmpty _FLArray_IsEmpty =
      _FLArray_IsEmpty_ptr.asFunction<_dart_FLArray_IsEmpty>();

  /// If the array is mutable, returns it cast to FLMutableArray, else NULL.
  ffi.Pointer<FLArray> FLArray_AsMutable(
    ffi.Pointer<FLArray> arg0,
  ) {
    return _FLArray_AsMutable(
      arg0,
    );
  }

  late final _FLArray_AsMutable_ptr =
      _lookup<ffi.NativeFunction<_c_FLArray_AsMutable>>('FLArray_AsMutable');
  late final _dart_FLArray_AsMutable _FLArray_AsMutable =
      _FLArray_AsMutable_ptr.asFunction<_dart_FLArray_AsMutable>();

  /// Returns an value at an array index, or NULL if the index is out of range.
  ffi.Pointer<FLValue> FLArray_Get(
    ffi.Pointer<FLArray> arg0,
    int index,
  ) {
    return _FLArray_Get(
      arg0,
      index,
    );
  }

  late final _FLArray_Get_ptr =
      _lookup<ffi.NativeFunction<_c_FLArray_Get>>('FLArray_Get');
  late final _dart_FLArray_Get _FLArray_Get =
      _FLArray_Get_ptr.asFunction<_dart_FLArray_Get>();

  /// Initializes a FLArrayIterator struct to iterate over an array.
  /// Call FLArrayIteratorGetValue to get the first item, then FLArrayIteratorNext.
  void FLArrayIterator_Begin(
    ffi.Pointer<FLArray> arg0,
    ffi.Pointer<FLArrayIterator> arg1,
  ) {
    return _FLArrayIterator_Begin(
      arg0,
      arg1,
    );
  }

  late final _FLArrayIterator_Begin_ptr =
      _lookup<ffi.NativeFunction<_c_FLArrayIterator_Begin>>(
          'FLArrayIterator_Begin');
  late final _dart_FLArrayIterator_Begin _FLArrayIterator_Begin =
      _FLArrayIterator_Begin_ptr.asFunction<_dart_FLArrayIterator_Begin>();

  /// Returns the current value being iterated over.
  ffi.Pointer<FLValue> FLArrayIterator_GetValue(
    ffi.Pointer<FLArrayIterator> arg0,
  ) {
    return _FLArrayIterator_GetValue(
      arg0,
    );
  }

  late final _FLArrayIterator_GetValue_ptr =
      _lookup<ffi.NativeFunction<_c_FLArrayIterator_GetValue>>(
          'FLArrayIterator_GetValue');
  late final _dart_FLArrayIterator_GetValue _FLArrayIterator_GetValue =
      _FLArrayIterator_GetValue_ptr.asFunction<
          _dart_FLArrayIterator_GetValue>();

  /// Returns a value in the array at the given offset from the current value.
  ffi.Pointer<FLValue> FLArrayIterator_GetValueAt(
    ffi.Pointer<FLArrayIterator> arg0,
    int offset,
  ) {
    return _FLArrayIterator_GetValueAt(
      arg0,
      offset,
    );
  }

  late final _FLArrayIterator_GetValueAt_ptr =
      _lookup<ffi.NativeFunction<_c_FLArrayIterator_GetValueAt>>(
          'FLArrayIterator_GetValueAt');
  late final _dart_FLArrayIterator_GetValueAt _FLArrayIterator_GetValueAt =
      _FLArrayIterator_GetValueAt_ptr.asFunction<
          _dart_FLArrayIterator_GetValueAt>();

  /// Returns the number of items remaining to be iterated, including the current one.
  int FLArrayIterator_GetCount(
    ffi.Pointer<FLArrayIterator> arg0,
  ) {
    return _FLArrayIterator_GetCount(
      arg0,
    );
  }

  late final _FLArrayIterator_GetCount_ptr =
      _lookup<ffi.NativeFunction<_c_FLArrayIterator_GetCount>>(
          'FLArrayIterator_GetCount');
  late final _dart_FLArrayIterator_GetCount _FLArrayIterator_GetCount =
      _FLArrayIterator_GetCount_ptr.asFunction<
          _dart_FLArrayIterator_GetCount>();

  /// Advances the iterator to the next value, or returns false if at the end.
  bool FLArrayIterator_Next(
    ffi.Pointer<FLArrayIterator> arg0,
  ) {
    return _FLArrayIterator_Next(
          arg0,
        ) !=
        0;
  }

  late final _FLArrayIterator_Next_ptr =
      _lookup<ffi.NativeFunction<_c_FLArrayIterator_Next>>(
          'FLArrayIterator_Next');
  late final _dart_FLArrayIterator_Next _FLArrayIterator_Next =
      _FLArrayIterator_Next_ptr.asFunction<_dart_FLArrayIterator_Next>();

  /// Creates a new mutable Array that's a copy of the source Array.
  /// Its initial ref-count is 1, so a call to FLMutableArray_Release will free it.
  ///
  /// Copying an immutable Array is very cheap (only one small allocation) unless the flag
  /// kFLCopyImmutables is set.
  ///
  /// Copying a mutable Array is cheap if it's a shallow copy, but if `deepCopy` is true,
  /// nested mutable Arrays and Dicts are also copied, recursively; if kFLCopyImmutables is
  /// also set, immutable values are also copied.
  ///
  /// If the source Array is NULL, then NULL is returned.
  ffi.Pointer<FLArray> FLArray_MutableCopy(
    ffi.Pointer<FLArray> arg0,
    int arg1,
  ) {
    return _FLArray_MutableCopy(
      arg0,
      arg1,
    );
  }

  late final _FLArray_MutableCopy_ptr =
      _lookup<ffi.NativeFunction<_c_FLArray_MutableCopy>>(
          'FLArray_MutableCopy');
  late final _dart_FLArray_MutableCopy _FLArray_MutableCopy =
      _FLArray_MutableCopy_ptr.asFunction<_dart_FLArray_MutableCopy>();

  /// Creates a new empty mutable Array.
  /// Its initial ref-count is 1, so a call to FLMutableArray_Free will free it.
  ffi.Pointer<FLArray> FLMutableArray_New() {
    return _FLMutableArray_New();
  }

  late final _FLMutableArray_New_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_New>>('FLMutableArray_New');
  late final _dart_FLMutableArray_New _FLMutableArray_New =
      _FLMutableArray_New_ptr.asFunction<_dart_FLMutableArray_New>();

  /// If the Array was created by FLArray_MutableCopy, returns the original source Array.
  ffi.Pointer<FLArray> FLMutableArray_GetSource(
    ffi.Pointer<FLArray> arg0,
  ) {
    return _FLMutableArray_GetSource(
      arg0,
    );
  }

  late final _FLMutableArray_GetSource_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_GetSource>>(
          'FLMutableArray_GetSource');
  late final _dart_FLMutableArray_GetSource _FLMutableArray_GetSource =
      _FLMutableArray_GetSource_ptr.asFunction<
          _dart_FLMutableArray_GetSource>();

  /// Returns true if the Array has been changed from the source it was copied from.
  bool FLMutableArray_IsChanged(
    ffi.Pointer<FLArray> arg0,
  ) {
    return _FLMutableArray_IsChanged(
          arg0,
        ) !=
        0;
  }

  late final _FLMutableArray_IsChanged_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_IsChanged>>(
          'FLMutableArray_IsChanged');
  late final _dart_FLMutableArray_IsChanged _FLMutableArray_IsChanged =
      _FLMutableArray_IsChanged_ptr.asFunction<
          _dart_FLMutableArray_IsChanged>();

  /// Lets you store a value into a MutableArray, by returning a \ref FLSlot that you can call
  /// a function like \ref FLSlot_SetInt on.
  ffi.Pointer<FLSlot> FLMutableArray_Set(
    ffi.Pointer<FLArray> arg0,
    int index,
  ) {
    return _FLMutableArray_Set(
      arg0,
      index,
    );
  }

  late final _FLMutableArray_Set_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_Set>>('FLMutableArray_Set');
  late final _dart_FLMutableArray_Set _FLMutableArray_Set =
      _FLMutableArray_Set_ptr.asFunction<_dart_FLMutableArray_Set>();

  /// Appends a null value to a MutableArray and returns a \ref FLSlot that you can call
  /// to store something else in the new value.
  ffi.Pointer<FLSlot> FLMutableArray_Append(
    ffi.Pointer<FLArray> arg0,
  ) {
    return _FLMutableArray_Append(
      arg0,
    );
  }

  late final _FLMutableArray_Append_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_Append>>(
          'FLMutableArray_Append');
  late final _dart_FLMutableArray_Append _FLMutableArray_Append =
      _FLMutableArray_Append_ptr.asFunction<_dart_FLMutableArray_Append>();

  /// Inserts a contiguous range of JSON `null` values into the array.
  /// @param array  The array to operate on.
  /// @param firstIndex  The zero-based index of the first value to be inserted.
  /// @param count  The number of items to insert.
  void FLMutableArray_Insert(
    ffi.Pointer<FLArray> array,
    int firstIndex,
    int count,
  ) {
    return _FLMutableArray_Insert(
      array,
      firstIndex,
      count,
    );
  }

  late final _FLMutableArray_Insert_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_Insert>>(
          'FLMutableArray_Insert');
  late final _dart_FLMutableArray_Insert _FLMutableArray_Insert =
      _FLMutableArray_Insert_ptr.asFunction<_dart_FLMutableArray_Insert>();

  /// Removes contiguous items from the array.
  /// @param array  The array to operate on.
  /// @param firstIndex  The zero-based index of the first item to remove.
  /// @param count  The number of items to remove.
  void FLMutableArray_Remove(
    ffi.Pointer<FLArray> array,
    int firstIndex,
    int count,
  ) {
    return _FLMutableArray_Remove(
      array,
      firstIndex,
      count,
    );
  }

  late final _FLMutableArray_Remove_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_Remove>>(
          'FLMutableArray_Remove');
  late final _dart_FLMutableArray_Remove _FLMutableArray_Remove =
      _FLMutableArray_Remove_ptr.asFunction<_dart_FLMutableArray_Remove>();

  /// Changes the size of an array.
  /// If the new size is larger, the array is padded with JSON `null` values.
  /// If it's smaller, values are removed from the end.
  void FLMutableArray_Resize(
    ffi.Pointer<FLArray> array,
    int size,
  ) {
    return _FLMutableArray_Resize(
      array,
      size,
    );
  }

  late final _FLMutableArray_Resize_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_Resize>>(
          'FLMutableArray_Resize');
  late final _dart_FLMutableArray_Resize _FLMutableArray_Resize =
      _FLMutableArray_Resize_ptr.asFunction<_dart_FLMutableArray_Resize>();

  /// Convenience function for getting an array-valued property in mutable form.
  /// - If the value for the key is not an array, returns NULL.
  /// - If the value is a mutable array, returns it.
  /// - If the value is an immutable array, this function makes a mutable copy, assigns the
  /// copy as the property value, and returns the copy.
  ffi.Pointer<FLArray> FLMutableArray_GetMutableArray(
    ffi.Pointer<FLArray> arg0,
    int index,
  ) {
    return _FLMutableArray_GetMutableArray(
      arg0,
      index,
    );
  }

  late final _FLMutableArray_GetMutableArray_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_GetMutableArray>>(
          'FLMutableArray_GetMutableArray');
  late final _dart_FLMutableArray_GetMutableArray
      _FLMutableArray_GetMutableArray = _FLMutableArray_GetMutableArray_ptr
          .asFunction<_dart_FLMutableArray_GetMutableArray>();

  /// Convenience function for getting an array-valued property in mutable form.
  /// - If the value for the key is not an array, returns NULL.
  /// - If the value is a mutable array, returns it.
  /// - If the value is an immutable array, this function makes a mutable copy, assigns the
  /// copy as the property value, and returns the copy.
  ffi.Pointer<FLDict> FLMutableArray_GetMutableDict(
    ffi.Pointer<FLArray> arg0,
    int index,
  ) {
    return _FLMutableArray_GetMutableDict(
      arg0,
      index,
    );
  }

  late final _FLMutableArray_GetMutableDict_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_GetMutableDict>>(
          'FLMutableArray_GetMutableDict');
  late final _dart_FLMutableArray_GetMutableDict
      _FLMutableArray_GetMutableDict = _FLMutableArray_GetMutableDict_ptr
          .asFunction<_dart_FLMutableArray_GetMutableDict>();

  /// Returns the number of items in a dictionary, or 0 if the pointer is NULL.
  int FLDict_Count(
    ffi.Pointer<FLDict> arg0,
  ) {
    return _FLDict_Count(
      arg0,
    );
  }

  late final _FLDict_Count_ptr =
      _lookup<ffi.NativeFunction<_c_FLDict_Count>>('FLDict_Count');
  late final _dart_FLDict_Count _FLDict_Count =
      _FLDict_Count_ptr.asFunction<_dart_FLDict_Count>();

  /// Returns true if a dictionary is empty (or NULL). Depending on the dictionary's
  /// representation, this can be faster than `FLDict_Count(a) == 0`
  bool FLDict_IsEmpty(
    ffi.Pointer<FLDict> arg0,
  ) {
    return _FLDict_IsEmpty(
          arg0,
        ) !=
        0;
  }

  late final _FLDict_IsEmpty_ptr =
      _lookup<ffi.NativeFunction<_c_FLDict_IsEmpty>>('FLDict_IsEmpty');
  late final _dart_FLDict_IsEmpty _FLDict_IsEmpty =
      _FLDict_IsEmpty_ptr.asFunction<_dart_FLDict_IsEmpty>();

  /// If the dictionary is mutable, returns it cast to FLMutableDict, else NULL.
  ffi.Pointer<FLDict> FLDict_AsMutable(
    ffi.Pointer<FLDict> arg0,
  ) {
    return _FLDict_AsMutable(
      arg0,
    );
  }

  late final _FLDict_AsMutable_ptr =
      _lookup<ffi.NativeFunction<_c_FLDict_AsMutable>>('FLDict_AsMutable');
  late final _dart_FLDict_AsMutable _FLDict_AsMutable =
      _FLDict_AsMutable_ptr.asFunction<_dart_FLDict_AsMutable>();

  /// Looks up a key in a dictionary, returning its value.
  /// Returns NULL if the value is not found or if the dictionary is NULL.
  ffi.Pointer<FLValue> FLDict_Get(
    ffi.Pointer<FLDict> arg0,
    FLSlice keyString,
  ) {
    return _FLDict_Get(
      arg0,
      keyString,
    );
  }

  late final _FLDict_Get_ptr =
      _lookup<ffi.NativeFunction<_c_FLDict_Get>>('FLDict_Get');
  late final _dart_FLDict_Get _FLDict_Get =
      _FLDict_Get_ptr.asFunction<_dart_FLDict_Get>();

  /// Initializes a FLDictIterator struct to iterate over a dictionary.
  /// Call FLDictIterator_GetKey and FLDictIterator_GetValue to get the first item,
  /// then FLDictIterator_Next.
  void FLDictIterator_Begin(
    ffi.Pointer<FLDict> arg0,
    ffi.Pointer<FLDictIterator> arg1,
  ) {
    return _FLDictIterator_Begin(
      arg0,
      arg1,
    );
  }

  late final _FLDictIterator_Begin_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictIterator_Begin>>(
          'FLDictIterator_Begin');
  late final _dart_FLDictIterator_Begin _FLDictIterator_Begin =
      _FLDictIterator_Begin_ptr.asFunction<_dart_FLDictIterator_Begin>();

  /// Returns the current key being iterated over. This Value will be a string or an integer.
  ffi.Pointer<FLValue> FLDictIterator_GetKey(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_GetKey(
      arg0,
    );
  }

  late final _FLDictIterator_GetKey_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictIterator_GetKey>>(
          'FLDictIterator_GetKey');
  late final _dart_FLDictIterator_GetKey _FLDictIterator_GetKey =
      _FLDictIterator_GetKey_ptr.asFunction<_dart_FLDictIterator_GetKey>();

  /// Returns the current key's string value.
  FLSlice FLDictIterator_GetKeyString(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_GetKeyString(
      arg0,
    );
  }

  late final _FLDictIterator_GetKeyString_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictIterator_GetKeyString>>(
          'FLDictIterator_GetKeyString');
  late final _dart_FLDictIterator_GetKeyString _FLDictIterator_GetKeyString =
      _FLDictIterator_GetKeyString_ptr.asFunction<
          _dart_FLDictIterator_GetKeyString>();

  /// Returns the current value being iterated over.
  ffi.Pointer<FLValue> FLDictIterator_GetValue(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_GetValue(
      arg0,
    );
  }

  late final _FLDictIterator_GetValue_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictIterator_GetValue>>(
          'FLDictIterator_GetValue');
  late final _dart_FLDictIterator_GetValue _FLDictIterator_GetValue =
      _FLDictIterator_GetValue_ptr.asFunction<_dart_FLDictIterator_GetValue>();

  /// Returns the number of items remaining to be iterated, including the current one.
  int FLDictIterator_GetCount(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_GetCount(
      arg0,
    );
  }

  late final _FLDictIterator_GetCount_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictIterator_GetCount>>(
          'FLDictIterator_GetCount');
  late final _dart_FLDictIterator_GetCount _FLDictIterator_GetCount =
      _FLDictIterator_GetCount_ptr.asFunction<_dart_FLDictIterator_GetCount>();

  /// Advances the iterator to the next value, or returns false if at the end.
  bool FLDictIterator_Next(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_Next(
          arg0,
        ) !=
        0;
  }

  late final _FLDictIterator_Next_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictIterator_Next>>(
          'FLDictIterator_Next');
  late final _dart_FLDictIterator_Next _FLDictIterator_Next =
      _FLDictIterator_Next_ptr.asFunction<_dart_FLDictIterator_Next>();

  /// Cleans up after an iterator. Only needed if (a) the dictionary is a delta, and
  /// (b) you stop iterating before the end (i.e. before FLDictIterator_Next returns false.)
  void FLDictIterator_End(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_End(
      arg0,
    );
  }

  late final _FLDictIterator_End_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictIterator_End>>('FLDictIterator_End');
  late final _dart_FLDictIterator_End _FLDictIterator_End =
      _FLDictIterator_End_ptr.asFunction<_dart_FLDictIterator_End>();

  /// Initializes an FLDictKey struct with a key string.
  /// @warning  The input string's memory MUST remain valid for as long as the FLDictKey is in
  /// use! (The FLDictKey stores a pointer to the string, but does not copy it.)
  /// @param string  The key string (UTF-8).
  /// @return  An initialized FLDictKey struct.
  FLDictKey FLDictKey_Init(
    FLSlice string,
  ) {
    return _FLDictKey_Init(
      string,
    );
  }

  late final _FLDictKey_Init_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictKey_Init>>('FLDictKey_Init');
  late final _dart_FLDictKey_Init _FLDictKey_Init =
      _FLDictKey_Init_ptr.asFunction<_dart_FLDictKey_Init>();

  /// Returns the string value of the key (which it was initialized with.)
  FLSlice FLDictKey_GetString(
    ffi.Pointer<FLDictKey> arg0,
  ) {
    return _FLDictKey_GetString(
      arg0,
    );
  }

  late final _FLDictKey_GetString_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictKey_GetString>>(
          'FLDictKey_GetString');
  late final _dart_FLDictKey_GetString _FLDictKey_GetString =
      _FLDictKey_GetString_ptr.asFunction<_dart_FLDictKey_GetString>();

  /// Looks up a key in a dictionary using an FLDictKey. If the key is found, "hint" data will
  /// be stored inside the FLDictKey that will speed up subsequent lookups.
  ffi.Pointer<FLValue> FLDict_GetWithKey(
    ffi.Pointer<FLDict> arg0,
    ffi.Pointer<FLDictKey> arg1,
  ) {
    return _FLDict_GetWithKey(
      arg0,
      arg1,
    );
  }

  late final _FLDict_GetWithKey_ptr =
      _lookup<ffi.NativeFunction<_c_FLDict_GetWithKey>>('FLDict_GetWithKey');
  late final _dart_FLDict_GetWithKey _FLDict_GetWithKey =
      _FLDict_GetWithKey_ptr.asFunction<_dart_FLDict_GetWithKey>();

  /// Creates a new mutable Dict that's a copy of the source Dict.
  /// Its initial ref-count is 1, so a call to FLMutableDict_Release will free it.
  ///
  /// Copying an immutable Dict is very cheap (only one small allocation.) The `deepCopy` flag
  /// is ignored.
  ///
  /// Copying a mutable Dict is cheap if it's a shallow copy, but if `deepCopy` is true,
  /// nested mutable Dicts and Arrays are also copied, recursively.
  ///
  /// If the source dict is NULL, then NULL is returned.
  ffi.Pointer<FLDict> FLDict_MutableCopy(
    ffi.Pointer<FLDict> source,
    int arg1,
  ) {
    return _FLDict_MutableCopy(
      source,
      arg1,
    );
  }

  late final _FLDict_MutableCopy_ptr =
      _lookup<ffi.NativeFunction<_c_FLDict_MutableCopy>>('FLDict_MutableCopy');
  late final _dart_FLDict_MutableCopy _FLDict_MutableCopy =
      _FLDict_MutableCopy_ptr.asFunction<_dart_FLDict_MutableCopy>();

  /// Creates a new empty mutable Dict.
  /// Its initial ref-count is 1, so a call to FLMutableDict_Free will free it.
  ffi.Pointer<FLDict> FLMutableDict_New() {
    return _FLMutableDict_New();
  }

  late final _FLMutableDict_New_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_New>>('FLMutableDict_New');
  late final _dart_FLMutableDict_New _FLMutableDict_New =
      _FLMutableDict_New_ptr.asFunction<_dart_FLMutableDict_New>();

  /// If the Dict was created by FLDict_MutableCopy, returns the original source Dict.
  ffi.Pointer<FLDict> FLMutableDict_GetSource(
    ffi.Pointer<FLDict> arg0,
  ) {
    return _FLMutableDict_GetSource(
      arg0,
    );
  }

  late final _FLMutableDict_GetSource_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_GetSource>>(
          'FLMutableDict_GetSource');
  late final _dart_FLMutableDict_GetSource _FLMutableDict_GetSource =
      _FLMutableDict_GetSource_ptr.asFunction<_dart_FLMutableDict_GetSource>();

  /// Returns true if the Dict has been changed from the source it was copied from.
  bool FLMutableDict_IsChanged(
    ffi.Pointer<FLDict> arg0,
  ) {
    return _FLMutableDict_IsChanged(
          arg0,
        ) !=
        0;
  }

  late final _FLMutableDict_IsChanged_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_IsChanged>>(
          'FLMutableDict_IsChanged');
  late final _dart_FLMutableDict_IsChanged _FLMutableDict_IsChanged =
      _FLMutableDict_IsChanged_ptr.asFunction<_dart_FLMutableDict_IsChanged>();

  /// Returns the Slot storing the key's value, adding a new one if needed (with a null value.)
  /// To set the value itself, call one of the FLSlot functions, e.g. \ref FLSlot_SetInt.
  ffi.Pointer<FLSlot> FLMutableDict_Set(
    ffi.Pointer<FLDict> FL_NONNULL,
    FLSlice key,
  ) {
    return _FLMutableDict_Set(
      FL_NONNULL,
      key,
    );
  }

  late final _FLMutableDict_Set_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_Set>>('FLMutableDict_Set');
  late final _dart_FLMutableDict_Set _FLMutableDict_Set =
      _FLMutableDict_Set_ptr.asFunction<_dart_FLMutableDict_Set>();

  /// Removes the value for a key.
  void FLMutableDict_Remove(
    ffi.Pointer<FLDict> arg0,
    FLSlice key,
  ) {
    return _FLMutableDict_Remove(
      arg0,
      key,
    );
  }

  late final _FLMutableDict_Remove_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_Remove>>(
          'FLMutableDict_Remove');
  late final _dart_FLMutableDict_Remove _FLMutableDict_Remove =
      _FLMutableDict_Remove_ptr.asFunction<_dart_FLMutableDict_Remove>();

  /// Removes all keys and values.
  void FLMutableDict_RemoveAll(
    ffi.Pointer<FLDict> arg0,
  ) {
    return _FLMutableDict_RemoveAll(
      arg0,
    );
  }

  late final _FLMutableDict_RemoveAll_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_RemoveAll>>(
          'FLMutableDict_RemoveAll');
  late final _dart_FLMutableDict_RemoveAll _FLMutableDict_RemoveAll =
      _FLMutableDict_RemoveAll_ptr.asFunction<_dart_FLMutableDict_RemoveAll>();

  /// Convenience function for getting an array-valued property in mutable form.
  /// - If the value for the key is not an array, returns NULL.
  /// - If the value is a mutable array, returns it.
  /// - If the value is an immutable array, this function makes a mutable copy, assigns the
  /// copy as the property value, and returns the copy.
  ffi.Pointer<FLArray> FLMutableDict_GetMutableArray(
    ffi.Pointer<FLDict> arg0,
    FLSlice key,
  ) {
    return _FLMutableDict_GetMutableArray(
      arg0,
      key,
    );
  }

  late final _FLMutableDict_GetMutableArray_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_GetMutableArray>>(
          'FLMutableDict_GetMutableArray');
  late final _dart_FLMutableDict_GetMutableArray
      _FLMutableDict_GetMutableArray = _FLMutableDict_GetMutableArray_ptr
          .asFunction<_dart_FLMutableDict_GetMutableArray>();

  /// Convenience function for getting a dict-valued property in mutable form.
  /// - If the value for the key is not a dict, returns NULL.
  /// - If the value is a mutable dict, returns it.
  /// - If the value is an immutable dict, this function makes a mutable copy, assigns the
  /// copy as the property value, and returns the copy.
  ffi.Pointer<FLDict> FLMutableDict_GetMutableDict(
    ffi.Pointer<FLDict> arg0,
    FLSlice key,
  ) {
    return _FLMutableDict_GetMutableDict(
      arg0,
      key,
    );
  }

  late final _FLMutableDict_GetMutableDict_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_GetMutableDict>>(
          'FLMutableDict_GetMutableDict');
  late final _dart_FLMutableDict_GetMutableDict _FLMutableDict_GetMutableDict =
      _FLMutableDict_GetMutableDict_ptr.asFunction<
          _dart_FLMutableDict_GetMutableDict>();

  /// Creates a FLDeepIterator to iterate over a dictionary.
  /// Call FLDeepIterator_GetKey and FLDeepIterator_GetValue to get the first item,
  /// then FLDeepIterator_Next.
  ffi.Pointer<FLDeepIterator> FLDeepIterator_New(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLDeepIterator_New(
      arg0,
    );
  }

  late final _FLDeepIterator_New_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_New>>('FLDeepIterator_New');
  late final _dart_FLDeepIterator_New _FLDeepIterator_New =
      _FLDeepIterator_New_ptr.asFunction<_dart_FLDeepIterator_New>();

  void FLDeepIterator_Free(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_Free(
      arg0,
    );
  }

  late final _FLDeepIterator_Free_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_Free>>(
          'FLDeepIterator_Free');
  late final _dart_FLDeepIterator_Free _FLDeepIterator_Free =
      _FLDeepIterator_Free_ptr.asFunction<_dart_FLDeepIterator_Free>();

  /// Returns the current value being iterated over. or NULL at the end of iteration.
  ffi.Pointer<FLValue> FLDeepIterator_GetValue(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_GetValue(
      arg0,
    );
  }

  late final _FLDeepIterator_GetValue_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetValue>>(
          'FLDeepIterator_GetValue');
  late final _dart_FLDeepIterator_GetValue _FLDeepIterator_GetValue =
      _FLDeepIterator_GetValue_ptr.asFunction<_dart_FLDeepIterator_GetValue>();

  /// Returns the key of the current value, or an empty slice if not in a dictionary.
  FLSlice FLDeepIterator_GetKey(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_GetKey(
      arg0,
    );
  }

  late final _FLDeepIterator_GetKey_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetKey>>(
          'FLDeepIterator_GetKey');
  late final _dart_FLDeepIterator_GetKey _FLDeepIterator_GetKey =
      _FLDeepIterator_GetKey_ptr.asFunction<_dart_FLDeepIterator_GetKey>();

  /// Returns the array index of the current value, or 0 if not in an array.
  int FLDeepIterator_GetIndex(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_GetIndex(
      arg0,
    );
  }

  late final _FLDeepIterator_GetIndex_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetIndex>>(
          'FLDeepIterator_GetIndex');
  late final _dart_FLDeepIterator_GetIndex _FLDeepIterator_GetIndex =
      _FLDeepIterator_GetIndex_ptr.asFunction<_dart_FLDeepIterator_GetIndex>();

  /// Returns the current depth in the hierarchy, starting at 1 for the top-level children.
  int FLDeepIterator_GetDepth(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_GetDepth(
      arg0,
    );
  }

  late final _FLDeepIterator_GetDepth_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetDepth>>(
          'FLDeepIterator_GetDepth');
  late final _dart_FLDeepIterator_GetDepth _FLDeepIterator_GetDepth =
      _FLDeepIterator_GetDepth_ptr.asFunction<_dart_FLDeepIterator_GetDepth>();

  /// Tells the iterator to skip the children of the current value.
  void FLDeepIterator_SkipChildren(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_SkipChildren(
      arg0,
    );
  }

  late final _FLDeepIterator_SkipChildren_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_SkipChildren>>(
          'FLDeepIterator_SkipChildren');
  late final _dart_FLDeepIterator_SkipChildren _FLDeepIterator_SkipChildren =
      _FLDeepIterator_SkipChildren_ptr.asFunction<
          _dart_FLDeepIterator_SkipChildren>();

  /// Advances the iterator to the next value, or returns false if at the end.
  bool FLDeepIterator_Next(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_Next(
          arg0,
        ) !=
        0;
  }

  late final _FLDeepIterator_Next_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_Next>>(
          'FLDeepIterator_Next');
  late final _dart_FLDeepIterator_Next _FLDeepIterator_Next =
      _FLDeepIterator_Next_ptr.asFunction<_dart_FLDeepIterator_Next>();

  /// Returns the path as an array of FLPathComponents.
  void FLDeepIterator_GetPath(
    ffi.Pointer<FLDeepIterator> arg0,
    ffi.Pointer<ffi.Pointer<FLPathComponent>> outPath,
    ffi.Pointer<ffi.Uint64> outDepth,
  ) {
    return _FLDeepIterator_GetPath(
      arg0,
      outPath,
      outDepth,
    );
  }

  late final _FLDeepIterator_GetPath_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetPath>>(
          'FLDeepIterator_GetPath');
  late final _dart_FLDeepIterator_GetPath _FLDeepIterator_GetPath =
      _FLDeepIterator_GetPath_ptr.asFunction<_dart_FLDeepIterator_GetPath>();

  /// Returns the current path in JavaScript format.
  FLSliceResult FLDeepIterator_GetPathString(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_GetPathString(
      arg0,
    );
  }

  late final _FLDeepIterator_GetPathString_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetPathString>>(
          'FLDeepIterator_GetPathString');
  late final _dart_FLDeepIterator_GetPathString _FLDeepIterator_GetPathString =
      _FLDeepIterator_GetPathString_ptr.asFunction<
          _dart_FLDeepIterator_GetPathString>();

  /// Returns the current path in JSONPointer format (RFC 6901).
  FLSliceResult FLDeepIterator_GetJSONPointer(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_GetJSONPointer(
      arg0,
    );
  }

  late final _FLDeepIterator_GetJSONPointer_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetJSONPointer>>(
          'FLDeepIterator_GetJSONPointer');
  late final _dart_FLDeepIterator_GetJSONPointer
      _FLDeepIterator_GetJSONPointer = _FLDeepIterator_GetJSONPointer_ptr
          .asFunction<_dart_FLDeepIterator_GetJSONPointer>();

  /// Creates a new FLKeyPath object by compiling a path specifier string.
  ffi.Pointer<FLKeyPath> FLKeyPath_New(
    FLSlice specifier,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _FLKeyPath_New(
      specifier,
      error,
    );
  }

  late final _FLKeyPath_New_ptr =
      _lookup<ffi.NativeFunction<_c_FLKeyPath_New>>('FLKeyPath_New');
  late final _dart_FLKeyPath_New _FLKeyPath_New =
      _FLKeyPath_New_ptr.asFunction<_dart_FLKeyPath_New>();

  /// Frees a compiled FLKeyPath object. (It's ok to pass NULL.)
  void FLKeyPath_Free(
    ffi.Pointer<FLKeyPath> arg0,
  ) {
    return _FLKeyPath_Free(
      arg0,
    );
  }

  late final _FLKeyPath_Free_ptr =
      _lookup<ffi.NativeFunction<_c_FLKeyPath_Free>>('FLKeyPath_Free');
  late final _dart_FLKeyPath_Free _FLKeyPath_Free =
      _FLKeyPath_Free_ptr.asFunction<_dart_FLKeyPath_Free>();

  /// Evaluates a compiled key-path for a given Fleece root object.
  ffi.Pointer<FLValue> FLKeyPath_Eval(
    ffi.Pointer<FLKeyPath> arg0,
    ffi.Pointer<FLValue> root,
  ) {
    return _FLKeyPath_Eval(
      arg0,
      root,
    );
  }

  late final _FLKeyPath_Eval_ptr =
      _lookup<ffi.NativeFunction<_c_FLKeyPath_Eval>>('FLKeyPath_Eval');
  late final _dart_FLKeyPath_Eval _FLKeyPath_Eval =
      _FLKeyPath_Eval_ptr.asFunction<_dart_FLKeyPath_Eval>();

  /// Evaluates a key-path from a specifier string, for a given Fleece root object.
  /// If you only need to evaluate the path once, this is a bit faster than creating an
  /// FLKeyPath object, evaluating, then freeing it.
  ffi.Pointer<FLValue> FLKeyPath_EvalOnce(
    FLSlice specifier,
    ffi.Pointer<FLValue> root,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _FLKeyPath_EvalOnce(
      specifier,
      root,
      error,
    );
  }

  late final _FLKeyPath_EvalOnce_ptr =
      _lookup<ffi.NativeFunction<_c_FLKeyPath_EvalOnce>>('FLKeyPath_EvalOnce');
  late final _dart_FLKeyPath_EvalOnce _FLKeyPath_EvalOnce =
      _FLKeyPath_EvalOnce_ptr.asFunction<_dart_FLKeyPath_EvalOnce>();

  /// @} */
  /// /** \defgroup FLSharedKeys   Shared Keys
  /// @{
  ffi.Pointer<FLSharedKeys> FLSharedKeys_Create() {
    return _FLSharedKeys_Create();
  }

  late final _FLSharedKeys_Create_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_Create>>(
          'FLSharedKeys_Create');
  late final _dart_FLSharedKeys_Create _FLSharedKeys_Create =
      _FLSharedKeys_Create_ptr.asFunction<_dart_FLSharedKeys_Create>();

  ffi.Pointer<FLSharedKeys> FLSharedKeys_Retain(
    ffi.Pointer<FLSharedKeys> arg0,
  ) {
    return _FLSharedKeys_Retain(
      arg0,
    );
  }

  late final _FLSharedKeys_Retain_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_Retain>>(
          'FLSharedKeys_Retain');
  late final _dart_FLSharedKeys_Retain _FLSharedKeys_Retain =
      _FLSharedKeys_Retain_ptr.asFunction<_dart_FLSharedKeys_Retain>();

  void FLSharedKeys_Release(
    ffi.Pointer<FLSharedKeys> arg0,
  ) {
    return _FLSharedKeys_Release(
      arg0,
    );
  }

  late final _FLSharedKeys_Release_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_Release>>(
          'FLSharedKeys_Release');
  late final _dart_FLSharedKeys_Release _FLSharedKeys_Release =
      _FLSharedKeys_Release_ptr.asFunction<_dart_FLSharedKeys_Release>();

  ffi.Pointer<FLSharedKeys> FLSharedKeys_CreateFromStateData(
    FLSlice arg0,
  ) {
    return _FLSharedKeys_CreateFromStateData(
      arg0,
    );
  }

  late final _FLSharedKeys_CreateFromStateData_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_CreateFromStateData>>(
          'FLSharedKeys_CreateFromStateData');
  late final _dart_FLSharedKeys_CreateFromStateData
      _FLSharedKeys_CreateFromStateData = _FLSharedKeys_CreateFromStateData_ptr
          .asFunction<_dart_FLSharedKeys_CreateFromStateData>();

  FLSliceResult FLSharedKeys_GetStateData(
    ffi.Pointer<FLSharedKeys> arg0,
  ) {
    return _FLSharedKeys_GetStateData(
      arg0,
    );
  }

  late final _FLSharedKeys_GetStateData_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_GetStateData>>(
          'FLSharedKeys_GetStateData');
  late final _dart_FLSharedKeys_GetStateData _FLSharedKeys_GetStateData =
      _FLSharedKeys_GetStateData_ptr.asFunction<
          _dart_FLSharedKeys_GetStateData>();

  int FLSharedKeys_Encode(
    ffi.Pointer<FLSharedKeys> arg0,
    FLSlice arg1,
    bool add,
  ) {
    return _FLSharedKeys_Encode(
      arg0,
      arg1,
      add ? 1 : 0,
    );
  }

  late final _FLSharedKeys_Encode_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_Encode>>(
          'FLSharedKeys_Encode');
  late final _dart_FLSharedKeys_Encode _FLSharedKeys_Encode =
      _FLSharedKeys_Encode_ptr.asFunction<_dart_FLSharedKeys_Encode>();

  FLSlice FLSharedKeys_Decode(
    ffi.Pointer<FLSharedKeys> arg0,
    int key,
  ) {
    return _FLSharedKeys_Decode(
      arg0,
      key,
    );
  }

  late final _FLSharedKeys_Decode_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_Decode>>(
          'FLSharedKeys_Decode');
  late final _dart_FLSharedKeys_Decode _FLSharedKeys_Decode =
      _FLSharedKeys_Decode_ptr.asFunction<_dart_FLSharedKeys_Decode>();

  int FLSharedKeys_Count(
    ffi.Pointer<FLSharedKeys> arg0,
  ) {
    return _FLSharedKeys_Count(
      arg0,
    );
  }

  late final _FLSharedKeys_Count_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_Count>>('FLSharedKeys_Count');
  late final _dart_FLSharedKeys_Count _FLSharedKeys_Count =
      _FLSharedKeys_Count_ptr.asFunction<_dart_FLSharedKeys_Count>();

  /// Creates a new encoder, for generating Fleece data. Call FLEncoder_Free when done.
  ffi.Pointer<FLEncoder> FLEncoder_New() {
    return _FLEncoder_New();
  }

  late final _FLEncoder_New_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_New>>('FLEncoder_New');
  late final _dart_FLEncoder_New _FLEncoder_New =
      _FLEncoder_New_ptr.asFunction<_dart_FLEncoder_New>();

  /// Creates a new encoder, allowing some options to be customized.
  /// @param format  The output format to generate (Fleece, JSON, or JSON5.)
  /// @param reserveSize  The number of bytes to preallocate for the output. (Default is 256)
  /// @param uniqueStrings  (Fleece only) If true, string values that appear multiple times will be written
  /// as a single shared value. This saves space but makes encoding slightly slower.
  /// You should only turn this off if you know you're going to be writing large numbers
  /// of non-repeated strings. (Default is true)
  ffi.Pointer<FLEncoder> FLEncoder_NewWithOptions(
    int format,
    int reserveSize,
    bool uniqueStrings,
  ) {
    return _FLEncoder_NewWithOptions(
      format,
      reserveSize,
      uniqueStrings ? 1 : 0,
    );
  }

  late final _FLEncoder_NewWithOptions_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_NewWithOptions>>(
          'FLEncoder_NewWithOptions');
  late final _dart_FLEncoder_NewWithOptions _FLEncoder_NewWithOptions =
      _FLEncoder_NewWithOptions_ptr.asFunction<
          _dart_FLEncoder_NewWithOptions>();

  /// Creates a new Fleece encoder that writes to a file, not to memory.
  ffi.Pointer<FLEncoder> FLEncoder_NewWritingToFile(
    ffi.Pointer<FILE> arg0,
    bool uniqueStrings,
  ) {
    return _FLEncoder_NewWritingToFile(
      arg0,
      uniqueStrings ? 1 : 0,
    );
  }

  late final _FLEncoder_NewWritingToFile_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_NewWritingToFile>>(
          'FLEncoder_NewWritingToFile');
  late final _dart_FLEncoder_NewWritingToFile _FLEncoder_NewWritingToFile =
      _FLEncoder_NewWritingToFile_ptr.asFunction<
          _dart_FLEncoder_NewWritingToFile>();

  /// Frees the space used by an encoder.
  void FLEncoder_Free(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_Free(
      arg0,
    );
  }

  late final _FLEncoder_Free_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_Free>>('FLEncoder_Free');
  late final _dart_FLEncoder_Free _FLEncoder_Free =
      _FLEncoder_Free_ptr.asFunction<_dart_FLEncoder_Free>();

  /// Tells the encoder to use a shared-keys mapping when encoding dictionary keys.
  void FLEncoder_SetSharedKeys(
    ffi.Pointer<FLEncoder> arg0,
    ffi.Pointer<FLSharedKeys> arg1,
  ) {
    return _FLEncoder_SetSharedKeys(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_SetSharedKeys_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_SetSharedKeys>>(
          'FLEncoder_SetSharedKeys');
  late final _dart_FLEncoder_SetSharedKeys _FLEncoder_SetSharedKeys =
      _FLEncoder_SetSharedKeys_ptr.asFunction<_dart_FLEncoder_SetSharedKeys>();

  /// Associates an arbitrary user-defined value with the encoder.
  void FLEncoder_SetExtraInfo(
    ffi.Pointer<FLEncoder> arg0,
    ffi.Pointer<ffi.Void> info,
  ) {
    return _FLEncoder_SetExtraInfo(
      arg0,
      info,
    );
  }

  late final _FLEncoder_SetExtraInfo_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_SetExtraInfo>>(
          'FLEncoder_SetExtraInfo');
  late final _dart_FLEncoder_SetExtraInfo _FLEncoder_SetExtraInfo =
      _FLEncoder_SetExtraInfo_ptr.asFunction<_dart_FLEncoder_SetExtraInfo>();

  /// Returns the user-defined value associated with the encoder; NULL by default.
  ffi.Pointer<ffi.Void> FLEncoder_GetExtraInfo(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_GetExtraInfo(
      arg0,
    );
  }

  late final _FLEncoder_GetExtraInfo_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_GetExtraInfo>>(
          'FLEncoder_GetExtraInfo');
  late final _dart_FLEncoder_GetExtraInfo _FLEncoder_GetExtraInfo =
      _FLEncoder_GetExtraInfo_ptr.asFunction<_dart_FLEncoder_GetExtraInfo>();

  /// Tells the encoder to logically append to the given Fleece document, rather than making a
  /// standalone document. Any calls to FLEncoder_WriteValue() where the value points inside the
  /// base data will write a pointer back to the original value.
  /// The resulting data returned by FLEncoder_FinishDoc() will *NOT* be standalone; it can only
  /// be used by first appending it to the base data.
  /// @param e  The FLEncoder affected.
  /// @param base  The base document to create an amendment of.
  /// @param reuseStrings  If true, then writing a string that already exists in the base will
  /// just create a pointer back to the original. But the encoder has to scan the
  /// base for strings first.
  /// @param externPointers  If true, pointers into the base will be marked with the `extern`
  /// flag. This allows them to be resolved using the `FLResolver_Begin` function,
  /// so that when the delta is used the base document can be anywhere in memory,
  /// not just immediately preceding the delta document.
  void FLEncoder_Amend(
    ffi.Pointer<FLEncoder> e,
    FLSlice base,
    bool reuseStrings,
    bool externPointers,
  ) {
    return _FLEncoder_Amend(
      e,
      base,
      reuseStrings ? 1 : 0,
      externPointers ? 1 : 0,
    );
  }

  late final _FLEncoder_Amend_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_Amend>>('FLEncoder_Amend');
  late final _dart_FLEncoder_Amend _FLEncoder_Amend =
      _FLEncoder_Amend_ptr.asFunction<_dart_FLEncoder_Amend>();

  /// Returns the `base` value passed to FLEncoder_Amend.
  FLSlice FLEncoder_GetBase(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_GetBase(
      arg0,
    );
  }

  late final _FLEncoder_GetBase_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_GetBase>>('FLEncoder_GetBase');
  late final _dart_FLEncoder_GetBase _FLEncoder_GetBase =
      _FLEncoder_GetBase_ptr.asFunction<_dart_FLEncoder_GetBase>();

  /// Tells the encoder not to write the two-byte Fleece trailer at the end of the data.
  /// This is only useful for certain special purposes.
  void FLEncoder_SuppressTrailer(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_SuppressTrailer(
      arg0,
    );
  }

  late final _FLEncoder_SuppressTrailer_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_SuppressTrailer>>(
          'FLEncoder_SuppressTrailer');
  late final _dart_FLEncoder_SuppressTrailer _FLEncoder_SuppressTrailer =
      _FLEncoder_SuppressTrailer_ptr.asFunction<
          _dart_FLEncoder_SuppressTrailer>();

  /// Resets the state of an encoder without freeing it. It can then be reused to encode
  /// another value.
  void FLEncoder_Reset(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_Reset(
      arg0,
    );
  }

  late final _FLEncoder_Reset_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_Reset>>('FLEncoder_Reset');
  late final _dart_FLEncoder_Reset _FLEncoder_Reset =
      _FLEncoder_Reset_ptr.asFunction<_dart_FLEncoder_Reset>();

  /// Returns the number of bytes encoded so far.
  int FLEncoder_BytesWritten(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_BytesWritten(
      arg0,
    );
  }

  late final _FLEncoder_BytesWritten_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_BytesWritten>>(
          'FLEncoder_BytesWritten');
  late final _dart_FLEncoder_BytesWritten _FLEncoder_BytesWritten =
      _FLEncoder_BytesWritten_ptr.asFunction<_dart_FLEncoder_BytesWritten>();

  /// Returns the byte offset in the encoded data where the next value will be written.
  /// (Due to internal buffering, this is not the same as FLEncoder_BytesWritten.)
  int FLEncoder_GetNextWritePos(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_GetNextWritePos(
      arg0,
    );
  }

  late final _FLEncoder_GetNextWritePos_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_GetNextWritePos>>(
          'FLEncoder_GetNextWritePos');
  late final _dart_FLEncoder_GetNextWritePos _FLEncoder_GetNextWritePos =
      _FLEncoder_GetNextWritePos_ptr.asFunction<
          _dart_FLEncoder_GetNextWritePos>();

  /// Writes a `null` value to an encoder. (This is an explicitly-stored null, like the JSON
  /// `null`, not the "undefined" value represented by a NULL FLValue pointer.)
  bool FLEncoder_WriteNull(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_WriteNull(
          arg0,
        ) !=
        0;
  }

  late final _FLEncoder_WriteNull_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteNull>>(
          'FLEncoder_WriteNull');
  late final _dart_FLEncoder_WriteNull _FLEncoder_WriteNull =
      _FLEncoder_WriteNull_ptr.asFunction<_dart_FLEncoder_WriteNull>();

  /// Writes an `undefined` value to an encoder. (Its value when read will not be a `NULL`
  /// pointer, but it can be recognized by `FLValue_GetType` returning `kFLUndefined`.)
  /// @note The only real use for writing undefined values is to represent "holes" in an array.
  /// An undefined dictionary value should be written simply by skipping the key and value.
  bool FLEncoder_WriteUndefined(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_WriteUndefined(
          arg0,
        ) !=
        0;
  }

  late final _FLEncoder_WriteUndefined_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteUndefined>>(
          'FLEncoder_WriteUndefined');
  late final _dart_FLEncoder_WriteUndefined _FLEncoder_WriteUndefined =
      _FLEncoder_WriteUndefined_ptr.asFunction<
          _dart_FLEncoder_WriteUndefined>();

  /// Writes a boolean value (true or false) to an encoder.
  bool FLEncoder_WriteBool(
    ffi.Pointer<FLEncoder> arg0,
    bool arg1,
  ) {
    return _FLEncoder_WriteBool(
          arg0,
          arg1 ? 1 : 0,
        ) !=
        0;
  }

  late final _FLEncoder_WriteBool_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteBool>>(
          'FLEncoder_WriteBool');
  late final _dart_FLEncoder_WriteBool _FLEncoder_WriteBool =
      _FLEncoder_WriteBool_ptr.asFunction<_dart_FLEncoder_WriteBool>();

  /// Writes an integer to an encoder. The parameter is typed as `int64_t` but you can pass any
  /// integral type (signed or unsigned) except for huge `uint64_t`s.
  /// The number will be written in a compact form that uses only as many bytes as necessary.
  bool FLEncoder_WriteInt(
    ffi.Pointer<FLEncoder> arg0,
    int arg1,
  ) {
    return _FLEncoder_WriteInt(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteInt_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteInt>>('FLEncoder_WriteInt');
  late final _dart_FLEncoder_WriteInt _FLEncoder_WriteInt =
      _FLEncoder_WriteInt_ptr.asFunction<_dart_FLEncoder_WriteInt>();

  /// Writes an unsigned integer to an encoder.
  /// @note This function is only really necessary for huge
  /// 64-bit integers greater than or equal to 2^63, which can't be represented as int64_t.
  bool FLEncoder_WriteUInt(
    ffi.Pointer<FLEncoder> arg0,
    int arg1,
  ) {
    return _FLEncoder_WriteUInt(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteUInt_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteUInt>>(
          'FLEncoder_WriteUInt');
  late final _dart_FLEncoder_WriteUInt _FLEncoder_WriteUInt =
      _FLEncoder_WriteUInt_ptr.asFunction<_dart_FLEncoder_WriteUInt>();

  /// Writes a 32-bit floating point number to an encoder.
  /// @note As an implementation detail, if the number has no fractional part and can be
  /// represented exactly as an integer, it'll be encoded as an integer to save space. This is
  /// transparent to the reader, since if it requests the value as a float it'll be returned
  /// as floating-point.
  bool FLEncoder_WriteFloat(
    ffi.Pointer<FLEncoder> arg0,
    double arg1,
  ) {
    return _FLEncoder_WriteFloat(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteFloat_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteFloat>>(
          'FLEncoder_WriteFloat');
  late final _dart_FLEncoder_WriteFloat _FLEncoder_WriteFloat =
      _FLEncoder_WriteFloat_ptr.asFunction<_dart_FLEncoder_WriteFloat>();

  /// Writes a 64-bit floating point number to an encoder.
  /// @note As an implementation detail, the number may be encoded as a 32-bit float or even
  /// as an integer, if this can be done without losing precision. For example, 123.0 will be
  /// written as an integer, and 123.75 as a float.)
  bool FLEncoder_WriteDouble(
    ffi.Pointer<FLEncoder> arg0,
    double arg1,
  ) {
    return _FLEncoder_WriteDouble(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteDouble_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteDouble>>(
          'FLEncoder_WriteDouble');
  late final _dart_FLEncoder_WriteDouble _FLEncoder_WriteDouble =
      _FLEncoder_WriteDouble_ptr.asFunction<_dart_FLEncoder_WriteDouble>();

  /// Writes a string to an encoder. The string must be UTF-8-encoded and must not contain any
  /// zero bytes.
  /// @warning Do _not_ use this to write a dictionary key; use FLEncoder_WriteKey instead.
  bool FLEncoder_WriteString(
    ffi.Pointer<FLEncoder> arg0,
    FLSlice arg1,
  ) {
    return _FLEncoder_WriteString(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteString_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteString>>(
          'FLEncoder_WriteString');
  late final _dart_FLEncoder_WriteString _FLEncoder_WriteString =
      _FLEncoder_WriteString_ptr.asFunction<_dart_FLEncoder_WriteString>();

  /// Writes a timestamp to an encoder, as an ISO-8601 date string.
  /// @note Since neither Fleece nor JSON have a 'Date' type, the encoded string has no
  /// metadata that distinguishes it as a date. It's just a string.)
  /// @param encoder  The encoder to write to.
  /// @param ts  The timestamp (milliseconds since Unix epoch 1-1-1970).
  /// @param asUTC  If true, date is written in UTC (GMT); if false, with the local timezone.
  /// @return  True on success, false on error.
  bool FLEncoder_WriteDateString(
    ffi.Pointer<FLEncoder> encoder,
    int ts,
    bool asUTC,
  ) {
    return _FLEncoder_WriteDateString(
          encoder,
          ts,
          asUTC ? 1 : 0,
        ) !=
        0;
  }

  late final _FLEncoder_WriteDateString_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteDateString>>(
          'FLEncoder_WriteDateString');
  late final _dart_FLEncoder_WriteDateString _FLEncoder_WriteDateString =
      _FLEncoder_WriteDateString_ptr.asFunction<
          _dart_FLEncoder_WriteDateString>();

  /// Writes a binary data value (a blob) to an encoder. This can contain absolutely anything
  /// including null bytes.
  /// If the encoder is generating JSON, the blob will be written as a base64-encoded string.
  bool FLEncoder_WriteData(
    ffi.Pointer<FLEncoder> arg0,
    FLSlice arg1,
  ) {
    return _FLEncoder_WriteData(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteData_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteData>>(
          'FLEncoder_WriteData');
  late final _dart_FLEncoder_WriteData _FLEncoder_WriteData =
      _FLEncoder_WriteData_ptr.asFunction<_dart_FLEncoder_WriteData>();

  /// Writes raw data directly to the encoded output.
  /// (This is not the same as FLEncoder_WriteData, which safely encodes a blob.)
  /// @warning **Do not call this** unless you really know what you're doing ...
  /// it's quite unsafe, and only used for certain advanced purposes.
  bool FLEncoder_WriteRaw(
    ffi.Pointer<FLEncoder> arg0,
    FLSlice arg1,
  ) {
    return _FLEncoder_WriteRaw(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteRaw_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteRaw>>('FLEncoder_WriteRaw');
  late final _dart_FLEncoder_WriteRaw _FLEncoder_WriteRaw =
      _FLEncoder_WriteRaw_ptr.asFunction<_dart_FLEncoder_WriteRaw>();

  /// Begins writing an array value to an encoder. This pushes a new state where each
  /// subsequent value written becomes an array item, until FLEncoder_EndArray is called.
  /// @param reserveCount  Number of array elements to reserve space for. If you know the size
  /// of the array, providing it here speeds up encoding slightly. If you don't know,
  /// just use zero.
  bool FLEncoder_BeginArray(
    ffi.Pointer<FLEncoder> arg0,
    int reserveCount,
  ) {
    return _FLEncoder_BeginArray(
          arg0,
          reserveCount,
        ) !=
        0;
  }

  late final _FLEncoder_BeginArray_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_BeginArray>>(
          'FLEncoder_BeginArray');
  late final _dart_FLEncoder_BeginArray _FLEncoder_BeginArray =
      _FLEncoder_BeginArray_ptr.asFunction<_dart_FLEncoder_BeginArray>();

  /// Ends writing an array value; pops back the previous encoding state.
  bool FLEncoder_EndArray(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_EndArray(
          arg0,
        ) !=
        0;
  }

  late final _FLEncoder_EndArray_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_EndArray>>('FLEncoder_EndArray');
  late final _dart_FLEncoder_EndArray _FLEncoder_EndArray =
      _FLEncoder_EndArray_ptr.asFunction<_dart_FLEncoder_EndArray>();

  /// Begins writing a dictionary value to an encoder. This pushes a new state where each
  /// subsequent key and value written are added to the dictionary, until FLEncoder_EndDict is
  /// called.
  /// Before adding each value, you must call FLEncoder_WriteKey (_not_ FLEncoder_WriteString!),
  /// to write the dictionary key.
  /// @param reserveCount  Number of dictionary items to reserve space for. If you know the size
  /// of the dictionary, providing it here speeds up encoding slightly. If you don't know,
  /// just use zero.
  bool FLEncoder_BeginDict(
    ffi.Pointer<FLEncoder> arg0,
    int reserveCount,
  ) {
    return _FLEncoder_BeginDict(
          arg0,
          reserveCount,
        ) !=
        0;
  }

  late final _FLEncoder_BeginDict_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_BeginDict>>(
          'FLEncoder_BeginDict');
  late final _dart_FLEncoder_BeginDict _FLEncoder_BeginDict =
      _FLEncoder_BeginDict_ptr.asFunction<_dart_FLEncoder_BeginDict>();

  /// Specifies the key for the next value to be written to the current dictionary.
  bool FLEncoder_WriteKey(
    ffi.Pointer<FLEncoder> arg0,
    FLSlice arg1,
  ) {
    return _FLEncoder_WriteKey(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteKey_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteKey>>('FLEncoder_WriteKey');
  late final _dart_FLEncoder_WriteKey _FLEncoder_WriteKey =
      _FLEncoder_WriteKey_ptr.asFunction<_dart_FLEncoder_WriteKey>();

  /// Specifies the key for the next value to be written to the current dictionary.
  /// The key is given as a Value, which must be a string or integer.
  bool FLEncoder_WriteKeyValue(
    ffi.Pointer<FLEncoder> arg0,
    ffi.Pointer<FLValue> arg1,
  ) {
    return _FLEncoder_WriteKeyValue(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteKeyValue_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteKeyValue>>(
          'FLEncoder_WriteKeyValue');
  late final _dart_FLEncoder_WriteKeyValue _FLEncoder_WriteKeyValue =
      _FLEncoder_WriteKeyValue_ptr.asFunction<_dart_FLEncoder_WriteKeyValue>();

  /// Ends writing a dictionary value; pops back the previous encoding state.
  bool FLEncoder_EndDict(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_EndDict(
          arg0,
        ) !=
        0;
  }

  late final _FLEncoder_EndDict_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_EndDict>>('FLEncoder_EndDict');
  late final _dart_FLEncoder_EndDict _FLEncoder_EndDict =
      _FLEncoder_EndDict_ptr.asFunction<_dart_FLEncoder_EndDict>();

  /// Writes a Fleece Value to an Encoder.
  bool FLEncoder_WriteValue(
    ffi.Pointer<FLEncoder> arg0,
    ffi.Pointer<FLValue> arg1,
  ) {
    return _FLEncoder_WriteValue(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteValue_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteValue>>(
          'FLEncoder_WriteValue');
  late final _dart_FLEncoder_WriteValue _FLEncoder_WriteValue =
      _FLEncoder_WriteValue_ptr.asFunction<_dart_FLEncoder_WriteValue>();

  /// Parses JSON data and writes the object(s) to the encoder. (This acts as a single write,
  /// like WriteInt; it's just that the value written is likely to be an entire dictionary of
  /// array.)
  bool FLEncoder_ConvertJSON(
    ffi.Pointer<FLEncoder> arg0,
    FLSlice json,
  ) {
    return _FLEncoder_ConvertJSON(
          arg0,
          json,
        ) !=
        0;
  }

  late final _FLEncoder_ConvertJSON_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_ConvertJSON>>(
          'FLEncoder_ConvertJSON');
  late final _dart_FLEncoder_ConvertJSON _FLEncoder_ConvertJSON =
      _FLEncoder_ConvertJSON_ptr.asFunction<_dart_FLEncoder_ConvertJSON>();

  /// Finishes encoding the current item, and returns its offset in the output data.
  int FLEncoder_FinishItem(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_FinishItem(
      arg0,
    );
  }

  late final _FLEncoder_FinishItem_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_FinishItem>>(
          'FLEncoder_FinishItem');
  late final _dart_FLEncoder_FinishItem _FLEncoder_FinishItem =
      _FLEncoder_FinishItem_ptr.asFunction<_dart_FLEncoder_FinishItem>();

  /// Ends encoding; if there has been no error, it returns the encoded Fleece data packaged in
  /// an FLDoc. (This function does not support JSON encoding.)
  /// This does not free the FLEncoder; call FLEncoder_Free (or FLEncoder_Reset) next.
  ffi.Pointer<FLDoc> FLEncoder_FinishDoc(
    ffi.Pointer<FLEncoder> arg0,
    ffi.Pointer<ffi.Int32> arg1,
  ) {
    return _FLEncoder_FinishDoc(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_FinishDoc_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_FinishDoc>>(
          'FLEncoder_FinishDoc');
  late final _dart_FLEncoder_FinishDoc _FLEncoder_FinishDoc =
      _FLEncoder_FinishDoc_ptr.asFunction<_dart_FLEncoder_FinishDoc>();

  /// Ends encoding; if there has been no error, it returns the encoded data, else null.
  /// This does not free the FLEncoder; call FLEncoder_Free (or FLEncoder_Reset) next.
  FLSliceResult FLEncoder_Finish(
    ffi.Pointer<FLEncoder> e,
    ffi.Pointer<ffi.Int32> outError,
  ) {
    return _FLEncoder_Finish(
      e,
      outError,
    );
  }

  late final _FLEncoder_Finish_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_Finish>>('FLEncoder_Finish');
  late final _dart_FLEncoder_Finish _FLEncoder_Finish =
      _FLEncoder_Finish_ptr.asFunction<_dart_FLEncoder_Finish>();

  /// Returns the error code of an encoder, or NoError (0) if there's no error.
  int FLEncoder_GetError(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_GetError(
      arg0,
    );
  }

  late final _FLEncoder_GetError_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_GetError>>('FLEncoder_GetError');
  late final _dart_FLEncoder_GetError _FLEncoder_GetError =
      _FLEncoder_GetError_ptr.asFunction<_dart_FLEncoder_GetError>();

  /// Returns the error message of an encoder, or NULL if there's no error.
  ffi.Pointer<ffi.Int8> FLEncoder_GetErrorMessage(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_GetErrorMessage(
      arg0,
    );
  }

  late final _FLEncoder_GetErrorMessage_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_GetErrorMessage>>(
          'FLEncoder_GetErrorMessage');
  late final _dart_FLEncoder_GetErrorMessage _FLEncoder_GetErrorMessage =
      _FLEncoder_GetErrorMessage_ptr.asFunction<
          _dart_FLEncoder_GetErrorMessage>();

  /// Returns JSON that encodes the changes to turn the value `old` into `nuu`.
  /// (The format is documented in Fleece.md, but you should treat it as a black box.)
  /// @param old  A value that's typically the old/original state of some data.
  /// @param nuu  A value that's typically the new/changed state of the `old` data.
  /// @return  JSON data representing the changes from `old` to `nuu`, or NULL on
  /// (extremely unlikely) failure.
  FLSliceResult FLCreateJSONDelta(
    ffi.Pointer<FLValue> old,
    ffi.Pointer<FLValue> nuu,
  ) {
    return _FLCreateJSONDelta(
      old,
      nuu,
    );
  }

  late final _FLCreateJSONDelta_ptr =
      _lookup<ffi.NativeFunction<_c_FLCreateJSONDelta>>('FLCreateJSONDelta');
  late final _dart_FLCreateJSONDelta _FLCreateJSONDelta =
      _FLCreateJSONDelta_ptr.asFunction<_dart_FLCreateJSONDelta>();

  /// Writes JSON that describes the changes to turn the value `old` into `nuu`.
  /// (The format is documented in Fleece.md, but you should treat it as a black box.)
  /// @param old  A value that's typically the old/original state of some data.
  /// @param nuu  A value that's typically the new/changed state of the `old` data.
  /// @param jsonEncoder  An encoder to write the JSON to. Must have been created using
  /// `FLEncoder_NewWithOptions`, with JSON or JSON5 format.
  /// @return  True on success, false on (extremely unlikely) failure.
  bool FLEncodeJSONDelta(
    ffi.Pointer<FLValue> old,
    ffi.Pointer<FLValue> nuu,
    ffi.Pointer<FLEncoder> jsonEncoder,
  ) {
    return _FLEncodeJSONDelta(
          old,
          nuu,
          jsonEncoder,
        ) !=
        0;
  }

  late final _FLEncodeJSONDelta_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncodeJSONDelta>>('FLEncodeJSONDelta');
  late final _dart_FLEncodeJSONDelta _FLEncodeJSONDelta =
      _FLEncodeJSONDelta_ptr.asFunction<_dart_FLEncodeJSONDelta>();

  /// Applies the JSON data created by `CreateJSONDelta` to the value `old`, which must be equal
  /// to the `old` value originally passed to `FLCreateJSONDelta`, and returns a Fleece document
  /// equal to the original `nuu` value.
  /// @param old  A value that's typically the old/original state of some data. This must be
  /// equal to the `old` value used when creating the `jsonDelta`.
  /// @param jsonDelta  A JSON-encoded delta created by `FLCreateJSONDelta` or `FLEncodeJSONDelta`.
  /// @param error  On failure, error information will be stored where this points, if non-null.
  /// @return  The corresponding `nuu` value, encoded as Fleece, or null if an error occurred.
  FLSliceResult FLApplyJSONDelta(
    ffi.Pointer<FLValue> old,
    FLSlice jsonDelta,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _FLApplyJSONDelta(
      old,
      jsonDelta,
      error,
    );
  }

  late final _FLApplyJSONDelta_ptr =
      _lookup<ffi.NativeFunction<_c_FLApplyJSONDelta>>('FLApplyJSONDelta');
  late final _dart_FLApplyJSONDelta _FLApplyJSONDelta =
      _FLApplyJSONDelta_ptr.asFunction<_dart_FLApplyJSONDelta>();

  /// Applies the (parsed) JSON data created by `CreateJSONDelta` to the value `old`, which must be
  /// equal to the `old` value originally passed to `FLCreateJSONDelta`, and writes the corresponding
  /// `nuu` value to the encoder.
  /// @param old  A value that's typically the old/original state of some data. This must be
  /// equal to the `old` value used when creating the `jsonDelta`.
  /// @param jsonDelta  A JSON-encoded delta created by `FLCreateJSONDelta` or `FLEncodeJSONDelta`.
  /// @param encoder  A Fleece encoder to write the decoded `nuu` value to. (JSON encoding is not
  /// supported.)
  /// @return  True on success, false on error; call `FLEncoder_GetError` for details.
  bool FLEncodeApplyingJSONDelta(
    ffi.Pointer<FLValue> old,
    FLSlice jsonDelta,
    ffi.Pointer<FLEncoder> encoder,
  ) {
    return _FLEncodeApplyingJSONDelta(
          old,
          jsonDelta,
          encoder,
        ) !=
        0;
  }

  late final _FLEncodeApplyingJSONDelta_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncodeApplyingJSONDelta>>(
          'FLEncodeApplyingJSONDelta');
  late final _dart_FLEncodeApplyingJSONDelta _FLEncodeApplyingJSONDelta =
      _FLEncodeApplyingJSONDelta_ptr.asFunction<
          _dart_FLEncodeApplyingJSONDelta>();

  /// < `"@type"`
  late final ffi.Pointer<FLSlice> _kCBLTypeProperty =
      _lookup<FLSlice>('kCBLTypeProperty');

  FLSlice get kCBLTypeProperty => _kCBLTypeProperty.ref;

  /// < `"blob"`
  late final ffi.Pointer<FLSlice> _kCBLBlobType =
      _lookup<FLSlice>('kCBLBlobType');

  FLSlice get kCBLBlobType => _kCBLBlobType.ref;

  /// < `"digest"`
  late final ffi.Pointer<FLSlice> _kCBLBlobDigestProperty =
      _lookup<FLSlice>('kCBLBlobDigestProperty');

  FLSlice get kCBLBlobDigestProperty => _kCBLBlobDigestProperty.ref;

  /// < `"length"`
  late final ffi.Pointer<FLSlice> _kCBLBlobLengthProperty =
      _lookup<FLSlice>('kCBLBlobLengthProperty');

  FLSlice get kCBLBlobLengthProperty => _kCBLBlobLengthProperty.ref;

  /// < `"content_type"`
  late final ffi.Pointer<FLSlice> _kCBLBlobContentTypeProperty =
      _lookup<FLSlice>('kCBLBlobContentTypeProperty');

  FLSlice get kCBLBlobContentTypeProperty => _kCBLBlobContentTypeProperty.ref;

  /// Returns true if a dictionary in a document is a blob reference.
  /// If so, you can call \ref CBLBlob_Get to access it.
  /// @note This function tests whether the dictionary has a `@type` property,
  /// whose value is `"blob"`.
  bool CBL_IsBlob(
    ffi.Pointer<FLDict> arg0,
  ) {
    return _CBL_IsBlob(
          arg0,
        ) !=
        0;
  }

  late final _CBL_IsBlob_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_IsBlob>>('CBL_IsBlob');
  late final _dart_CBL_IsBlob _CBL_IsBlob =
      _CBL_IsBlob_ptr.asFunction<_dart_CBL_IsBlob>();

  /// Returns a CBLBlob object corresponding to a blob dictionary in a document.
  /// @param blobDict  A dictionary in a document.
  /// @return  A CBLBlob instance for this blob, or NULL if the dictionary is not a blob.
  ffi.Pointer<CBLBlob> CBLBlob_Get(
    ffi.Pointer<FLDict> blobDict,
  ) {
    return _CBLBlob_Get(
      blobDict,
    );
  }

  late final _CBLBlob_Get_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_Get>>('CBLBlob_Get');
  late final _dart_CBLBlob_Get _CBLBlob_Get =
      _CBLBlob_Get_ptr.asFunction<_dart_CBLBlob_Get>();

  /// Returns the length in bytes of a blob's content (from its `length` property).
  int CBLBlob_Length(
    ffi.Pointer<CBLBlob> arg0,
  ) {
    return _CBLBlob_Length(
      arg0,
    );
  }

  late final _CBLBlob_Length_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_Length>>('CBLBlob_Length');
  late final _dart_CBLBlob_Length _CBLBlob_Length =
      _CBLBlob_Length_ptr.asFunction<_dart_CBLBlob_Length>();

  /// Returns the cryptographic digest of a blob's content (from its `digest` property).
  ffi.Pointer<ffi.Int8> CBLBlob_Digest(
    ffi.Pointer<CBLBlob> arg0,
  ) {
    return _CBLBlob_Digest(
      arg0,
    );
  }

  late final _CBLBlob_Digest_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_Digest>>('CBLBlob_Digest');
  late final _dart_CBLBlob_Digest _CBLBlob_Digest =
      _CBLBlob_Digest_ptr.asFunction<_dart_CBLBlob_Digest>();

  /// Returns a blob's MIME type, if its metadata has a `content_type` property.
  ffi.Pointer<ffi.Int8> CBLBlob_ContentType(
    ffi.Pointer<CBLBlob> arg0,
  ) {
    return _CBLBlob_ContentType(
      arg0,
    );
  }

  late final _CBLBlob_ContentType_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_ContentType>>(
          'CBLBlob_ContentType');
  late final _dart_CBLBlob_ContentType _CBLBlob_ContentType =
      _CBLBlob_ContentType_ptr.asFunction<_dart_CBLBlob_ContentType>();

  /// Returns a blob's metadata. This includes the `digest`, `length` and `content_type`
  /// properties, as well as any custom ones that may have been added.
  ffi.Pointer<FLDict> CBLBlob_Properties(
    ffi.Pointer<CBLBlob> arg0,
  ) {
    return _CBLBlob_Properties(
      arg0,
    );
  }

  late final _CBLBlob_Properties_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_Properties>>('CBLBlob_Properties');
  late final _dart_CBLBlob_Properties _CBLBlob_Properties =
      _CBLBlob_Properties_ptr.asFunction<_dart_CBLBlob_Properties>();

  /// Reads the blob's contents into memory and returns them.
  /// You are responsible for calling \ref FLSliceResult_Release on the returned data when done.
  /// @warning  This can potentially allocate a very large heap block!
  FLSliceResult CBLBlob_LoadContent(
    ffi.Pointer<CBLBlob> arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLBlob_LoadContent(
      arg0,
      outError,
    );
  }

  late final _CBLBlob_LoadContent_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_LoadContent>>(
          'CBLBlob_LoadContent');
  late final _dart_CBLBlob_LoadContent _CBLBlob_LoadContent =
      _CBLBlob_LoadContent_ptr.asFunction<_dart_CBLBlob_LoadContent>();

  /// Opens a stream for reading a blob's content.
  ffi.Pointer<CBLBlobReadStream> CBLBlob_OpenContentStream(
    ffi.Pointer<CBLBlob> arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLBlob_OpenContentStream(
      arg0,
      outError,
    );
  }

  late final _CBLBlob_OpenContentStream_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_OpenContentStream>>(
          'CBLBlob_OpenContentStream');
  late final _dart_CBLBlob_OpenContentStream _CBLBlob_OpenContentStream =
      _CBLBlob_OpenContentStream_ptr.asFunction<
          _dart_CBLBlob_OpenContentStream>();

  /// Reads data from a blob.
  /// @param stream  The stream to read from.
  /// @param dst  The address to copy the read data to.
  /// @param maxLength  The maximum number of bytes to read.
  /// @param outError  On failure, an error will be stored here if non-NULL.
  /// @return  The actual number of bytes read; 0 if at EOF, -1 on error.
  int CBLBlobReader_Read(
    ffi.Pointer<CBLBlobReadStream> stream,
    ffi.Pointer<ffi.Void> dst,
    int maxLength,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLBlobReader_Read(
      stream,
      dst,
      maxLength,
      outError,
    );
  }

  late final _CBLBlobReader_Read_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlobReader_Read>>('CBLBlobReader_Read');
  late final _dart_CBLBlobReader_Read _CBLBlobReader_Read =
      _CBLBlobReader_Read_ptr.asFunction<_dart_CBLBlobReader_Read>();

  /// Closes a CBLBlobReadStream.
  void CBLBlobReader_Close(
    ffi.Pointer<CBLBlobReadStream> arg0,
  ) {
    return _CBLBlobReader_Close(
      arg0,
    );
  }

  late final _CBLBlobReader_Close_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlobReader_Close>>(
          'CBLBlobReader_Close');
  late final _dart_CBLBlobReader_Close _CBLBlobReader_Close =
      _CBLBlobReader_Close_ptr.asFunction<_dart_CBLBlobReader_Close>();

  /// Creates a new blob given its contents as a single block of data.
  /// @note  You are responsible for releasing the \ref CBLBlob, but not until after its document
  /// has been saved.
  /// @param contentType  The MIME type (optional).
  /// @param contents  The data's address and length.
  /// @return  A new CBLBlob instance.
  ffi.Pointer<CBLBlob> CBLBlob_CreateWithData(
    ffi.Pointer<ffi.Int8> contentType,
    FLSlice contents,
  ) {
    return _CBLBlob_CreateWithData(
      contentType,
      contents,
    );
  }

  late final _CBLBlob_CreateWithData_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_CreateWithData>>(
          'CBLBlob_CreateWithData');
  late final _dart_CBLBlob_CreateWithData _CBLBlob_CreateWithData =
      _CBLBlob_CreateWithData_ptr.asFunction<_dart_CBLBlob_CreateWithData>();

  ffi.Pointer<CBLBlob> CBLBlob_CreateWithData_s(
    FLSlice contentType,
    FLSlice contents,
  ) {
    return _CBLBlob_CreateWithData_s(
      contentType,
      contents,
    );
  }

  late final _CBLBlob_CreateWithData_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_CreateWithData_s>>(
          'CBLBlob_CreateWithData_s');
  late final _dart_CBLBlob_CreateWithData_s _CBLBlob_CreateWithData_s =
      _CBLBlob_CreateWithData_s_ptr.asFunction<
          _dart_CBLBlob_CreateWithData_s>();

  /// Opens a stream for writing a new blob.
  /// You should next call \ref CBLBlobWriter_Write one or more times to write the data,
  /// then \ref CBLBlob_CreateWithStream to create the blob.
  ///
  /// If for some reason you need to abort, just call \ref CBLBlobWriter_Close.
  ffi.Pointer<CBLBlobWriteStream> CBLBlobWriter_New(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLBlobWriter_New(
      db,
      outError,
    );
  }

  late final _CBLBlobWriter_New_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlobWriter_New>>('CBLBlobWriter_New');
  late final _dart_CBLBlobWriter_New _CBLBlobWriter_New =
      _CBLBlobWriter_New_ptr.asFunction<_dart_CBLBlobWriter_New>();

  /// Closes a blob-writing stream, if you need to give up without creating a \ref CBLBlob.
  void CBLBlobWriter_Close(
    ffi.Pointer<CBLBlobWriteStream> arg0,
  ) {
    return _CBLBlobWriter_Close(
      arg0,
    );
  }

  late final _CBLBlobWriter_Close_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlobWriter_Close>>(
          'CBLBlobWriter_Close');
  late final _dart_CBLBlobWriter_Close _CBLBlobWriter_Close =
      _CBLBlobWriter_Close_ptr.asFunction<_dart_CBLBlobWriter_Close>();

  /// Writes data to a new blob.
  /// @param writer  The stream to write to.
  /// @param data  The address of the data to write.
  /// @param length  The length of the data to write.
  /// @param outError  On failure, error info will be written here.
  /// @return  True on success, false on failure.
  bool CBLBlobWriter_Write(
    ffi.Pointer<CBLBlobWriteStream> writer,
    ffi.Pointer<ffi.Void> data,
    int length,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLBlobWriter_Write(
          writer,
          data,
          length,
          outError,
        ) !=
        0;
  }

  late final _CBLBlobWriter_Write_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlobWriter_Write>>(
          'CBLBlobWriter_Write');
  late final _dart_CBLBlobWriter_Write _CBLBlobWriter_Write =
      _CBLBlobWriter_Write_ptr.asFunction<_dart_CBLBlobWriter_Write>();

  /// Creates a new blob after its data has been written to a \ref CBLBlobWriteStream.
  /// You should then add the blob to a mutable document as a property -- see
  /// \ref FLMutableDict_SetBlob and \ref FLMutableArray_SetBlob.
  /// @note  You are responsible for releasing the CBLBlob reference.
  /// @note  Do not free the stream; the blob will do that.
  /// @param contentType  The MIME type (optional).
  /// @param writer  The blob-writing stream the data was written to.
  /// @return  A new CBLBlob instance.
  ffi.Pointer<CBLBlob> CBLBlob_CreateWithStream(
    ffi.Pointer<ffi.Int8> contentType,
    ffi.Pointer<CBLBlobWriteStream> writer,
  ) {
    return _CBLBlob_CreateWithStream(
      contentType,
      writer,
    );
  }

  late final _CBLBlob_CreateWithStream_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_CreateWithStream>>(
          'CBLBlob_CreateWithStream');
  late final _dart_CBLBlob_CreateWithStream _CBLBlob_CreateWithStream =
      _CBLBlob_CreateWithStream_ptr.asFunction<
          _dart_CBLBlob_CreateWithStream>();

  ffi.Pointer<CBLBlob> CBLBlob_CreateWithStream_s(
    FLSlice contentType,
    ffi.Pointer<CBLBlobWriteStream> writer,
  ) {
    return _CBLBlob_CreateWithStream_s(
      contentType,
      writer,
    );
  }

  late final _CBLBlob_CreateWithStream_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_CreateWithStream_s>>(
          'CBLBlob_CreateWithStream_s');
  late final _dart_CBLBlob_CreateWithStream_s _CBLBlob_CreateWithStream_s =
      _CBLBlob_CreateWithStream_s_ptr.asFunction<
          _dart_CBLBlob_CreateWithStream_s>();

  void FLSlot_SetBlob(
    ffi.Pointer<FLSlot> slot,
    ffi.Pointer<CBLBlob> blob,
  ) {
    return _FLSlot_SetBlob(
      slot,
      blob,
    );
  }

  late final _FLSlot_SetBlob_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetBlob>>('FLSlot_SetBlob');
  late final _dart_FLSlot_SetBlob _FLSlot_SetBlob =
      _FLSlot_SetBlob_ptr.asFunction<_dart_FLSlot_SetBlob>();

  /// Stores a blob in a mutable array.
  void FLMutableArray_SetBlob(
    ffi.Pointer<FLArray> array,
    int index,
    ffi.Pointer<CBLBlob> blob,
  ) {
    return _FLMutableArray_SetBlob(
      array,
      index,
      blob,
    );
  }

  late final _FLMutableArray_SetBlob_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_SetBlob>>(
          'FLMutableArray_SetBlob');
  late final _dart_FLMutableArray_SetBlob _FLMutableArray_SetBlob =
      _FLMutableArray_SetBlob_ptr.asFunction<_dart_FLMutableArray_SetBlob>();

  /// Stores a blob in a mutable dictionary.
  void FLMutableDict_SetBlob(
    ffi.Pointer<FLDict> dict,
    FLSlice key,
    ffi.Pointer<CBLBlob> blob,
  ) {
    return _FLMutableDict_SetBlob(
      dict,
      key,
      blob,
    );
  }

  late final _FLMutableDict_SetBlob_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_SetBlob>>(
          'FLMutableDict_SetBlob');
  late final _dart_FLMutableDict_SetBlob _FLMutableDict_SetBlob =
      _FLMutableDict_SetBlob_ptr.asFunction<_dart_FLMutableDict_SetBlob>();

  /// Returns the default database configuration.
  CBLDatabaseConfiguration CBLDatabaseConfiguration_Default() {
    return _CBLDatabaseConfiguration_Default();
  }

  late final _CBLDatabaseConfiguration_Default_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabaseConfiguration_Default>>(
          'CBLDatabaseConfiguration_Default');
  late final _dart_CBLDatabaseConfiguration_Default
      _CBLDatabaseConfiguration_Default = _CBLDatabaseConfiguration_Default_ptr
          .asFunction<_dart_CBLDatabaseConfiguration_Default>();

  CBLDatabaseConfiguration_s CBLDatabaseConfiguration_Default_s() {
    return _CBLDatabaseConfiguration_Default_s();
  }

  late final _CBLDatabaseConfiguration_Default_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabaseConfiguration_Default_s>>(
          'CBLDatabaseConfiguration_Default_s');
  late final _dart_CBLDatabaseConfiguration_Default_s
      _CBLDatabaseConfiguration_Default_s =
      _CBLDatabaseConfiguration_Default_s_ptr.asFunction<
          _dart_CBLDatabaseConfiguration_Default_s>();

  /// Returns true if a database with the given name exists in the given directory.
  /// @param name  The database name (without the ".cblite2" extension.)
  /// @param inDirectory  The directory containing the database. If NULL, `name` must be an
  /// absolute or relative path to the database.
  bool CBL_DatabaseExists(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> inDirectory,
  ) {
    return _CBL_DatabaseExists(
          name,
          inDirectory,
        ) !=
        0;
  }

  late final _CBL_DatabaseExists_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_DatabaseExists>>('CBL_DatabaseExists');
  late final _dart_CBL_DatabaseExists _CBL_DatabaseExists =
      _CBL_DatabaseExists_ptr.asFunction<_dart_CBL_DatabaseExists>();

  bool CBL_DatabaseExists_s(
    FLSlice name,
    FLSlice inDirectory,
  ) {
    return _CBL_DatabaseExists_s(
          name,
          inDirectory,
        ) !=
        0;
  }

  late final _CBL_DatabaseExists_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_DatabaseExists_s>>(
          'CBL_DatabaseExists_s');
  late final _dart_CBL_DatabaseExists_s _CBL_DatabaseExists_s =
      _CBL_DatabaseExists_s_ptr.asFunction<_dart_CBL_DatabaseExists_s>();

  /// Copies a database file to a new location, and assigns it a new internal UUID to distinguish
  /// it from the original database when replicating.
  /// @param fromPath  The full filesystem path to the original database (including extension).
  /// @param toName  The new database name (without the ".cblite2" extension.)
  /// @param config  The database configuration (directory and encryption option.)
  bool CBL_CopyDatabase(
    ffi.Pointer<ffi.Int8> fromPath,
    ffi.Pointer<ffi.Int8> toName,
    ffi.Pointer<CBLDatabaseConfiguration> config,
    ffi.Pointer<CBLError> arg3,
  ) {
    return _CBL_CopyDatabase(
          fromPath,
          toName,
          config,
          arg3,
        ) !=
        0;
  }

  late final _CBL_CopyDatabase_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_CopyDatabase>>('CBL_CopyDatabase');
  late final _dart_CBL_CopyDatabase _CBL_CopyDatabase =
      _CBL_CopyDatabase_ptr.asFunction<_dart_CBL_CopyDatabase>();

  bool CBL_CopyDatabase_s(
    FLSlice fromPath,
    FLSlice toName,
    ffi.Pointer<CBLDatabaseConfiguration_s> config,
    ffi.Pointer<CBLError> arg3,
  ) {
    return _CBL_CopyDatabase_s(
          fromPath,
          toName,
          config,
          arg3,
        ) !=
        0;
  }

  late final _CBL_CopyDatabase_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_CopyDatabase_s>>('CBL_CopyDatabase_s');
  late final _dart_CBL_CopyDatabase_s _CBL_CopyDatabase_s =
      _CBL_CopyDatabase_s_ptr.asFunction<_dart_CBL_CopyDatabase_s>();

  /// Deletes a database file. If the database file is open, an error is returned.
  /// @param name  The database name (without the ".cblite2" extension.)
  /// @param inDirectory  The directory containing the database. If NULL, `name` must be an
  /// absolute or relative path to the database.
  /// @param outError  On return, will be set to the error that occurred, or a 0 code if no error.
  /// @return  True if the database was deleted, false if it doesn't exist or deletion failed.
  /// (You can tell the last two cases apart by looking at \p outError.)
  bool CBL_DeleteDatabase(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> inDirectory,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBL_DeleteDatabase(
          name,
          inDirectory,
          outError,
        ) !=
        0;
  }

  late final _CBL_DeleteDatabase_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_DeleteDatabase>>('CBL_DeleteDatabase');
  late final _dart_CBL_DeleteDatabase _CBL_DeleteDatabase =
      _CBL_DeleteDatabase_ptr.asFunction<_dart_CBL_DeleteDatabase>();

  bool CBL_DeleteDatabase_s(
    FLSlice name,
    FLSlice inDirectory,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBL_DeleteDatabase_s(
          name,
          inDirectory,
          outError,
        ) !=
        0;
  }

  late final _CBL_DeleteDatabase_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_DeleteDatabase_s>>(
          'CBL_DeleteDatabase_s');
  late final _dart_CBL_DeleteDatabase_s _CBL_DeleteDatabase_s =
      _CBL_DeleteDatabase_s_ptr.asFunction<_dart_CBL_DeleteDatabase_s>();

  /// Opens a database, or creates it if it doesn't exist yet, returning a new \ref CBLDatabase
  /// instance.
  /// It's OK to open the same database file multiple times. Each \ref CBLDatabase instance is
  /// independent of the others (and must be separately closed and released.)
  /// @param name  The database name (without the ".cblite2" extension.)
  /// @param config  The database configuration (directory and encryption option.)
  /// @param error  On failure, the error will be written here.
  /// @return  The new database object, or NULL on failure.
  ffi.Pointer<CBLDatabase> CBLDatabase_Open(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<CBLDatabaseConfiguration> config,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLDatabase_Open(
      name,
      config,
      error,
    );
  }

  late final _CBLDatabase_Open_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Open>>('CBLDatabase_Open');
  late final _dart_CBLDatabase_Open _CBLDatabase_Open =
      _CBLDatabase_Open_ptr.asFunction<_dart_CBLDatabase_Open>();

  ffi.Pointer<CBLDatabase> CBLDatabase_Open_s(
    FLSlice name,
    ffi.Pointer<CBLDatabaseConfiguration_s> config,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLDatabase_Open_s(
      name,
      config,
      error,
    );
  }

  late final _CBLDatabase_Open_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Open_s>>('CBLDatabase_Open_s');
  late final _dart_CBLDatabase_Open_s _CBLDatabase_Open_s =
      _CBLDatabase_Open_s_ptr.asFunction<_dart_CBLDatabase_Open_s>();

  /// Closes an open database.
  bool CBLDatabase_Close(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Pointer<CBLError> arg1,
  ) {
    return _CBLDatabase_Close(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _CBLDatabase_Close_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Close>>('CBLDatabase_Close');
  late final _dart_CBLDatabase_Close _CBLDatabase_Close =
      _CBLDatabase_Close_ptr.asFunction<_dart_CBLDatabase_Close>();

  /// Closes and deletes a database. If there are any other connections to the database,
  /// an error is returned.
  bool CBLDatabase_Delete(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Pointer<CBLError> arg1,
  ) {
    return _CBLDatabase_Delete(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _CBLDatabase_Delete_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Delete>>('CBLDatabase_Delete');
  late final _dart_CBLDatabase_Delete _CBLDatabase_Delete =
      _CBLDatabase_Delete_ptr.asFunction<_dart_CBLDatabase_Delete>();

  /// Compacts a database file.
  bool CBLDatabase_Compact(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Pointer<CBLError> arg1,
  ) {
    return _CBLDatabase_Compact(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _CBLDatabase_Compact_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Compact>>(
          'CBLDatabase_Compact');
  late final _dart_CBLDatabase_Compact _CBLDatabase_Compact =
      _CBLDatabase_Compact_ptr.asFunction<_dart_CBLDatabase_Compact>();

  /// Begins a batch operation, similar to a transaction. You **must** later call \ref
  /// CBLDatabase_EndBatch to end (commit) the batch.
  /// @note  Multiple writes are much faster when grouped inside a single batch.
  /// @note  Changes will not be visible to other CBLDatabase instances on the same database until
  /// the batch operation ends.
  /// @note  Batch operations can nest. Changes are not committed until the outer batch ends.
  bool CBLDatabase_BeginBatch(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Pointer<CBLError> arg1,
  ) {
    return _CBLDatabase_BeginBatch(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _CBLDatabase_BeginBatch_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_BeginBatch>>(
          'CBLDatabase_BeginBatch');
  late final _dart_CBLDatabase_BeginBatch _CBLDatabase_BeginBatch =
      _CBLDatabase_BeginBatch_ptr.asFunction<_dart_CBLDatabase_BeginBatch>();

  /// Ends a batch operation. This **must** be called after \ref CBLDatabase_BeginBatch.
  bool CBLDatabase_EndBatch(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Pointer<CBLError> arg1,
  ) {
    return _CBLDatabase_EndBatch(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _CBLDatabase_EndBatch_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_EndBatch>>(
          'CBLDatabase_EndBatch');
  late final _dart_CBLDatabase_EndBatch _CBLDatabase_EndBatch =
      _CBLDatabase_EndBatch_ptr.asFunction<_dart_CBLDatabase_EndBatch>();

  /// Returns the database's name.
  ffi.Pointer<ffi.Int8> CBLDatabase_Name(
    ffi.Pointer<CBLDatabase> arg0,
  ) {
    return _CBLDatabase_Name(
      arg0,
    );
  }

  late final _CBLDatabase_Name_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Name>>('CBLDatabase_Name');
  late final _dart_CBLDatabase_Name _CBLDatabase_Name =
      _CBLDatabase_Name_ptr.asFunction<_dart_CBLDatabase_Name>();

  /// Returns the database's full filesystem path.
  ffi.Pointer<ffi.Int8> CBLDatabase_Path(
    ffi.Pointer<CBLDatabase> arg0,
  ) {
    return _CBLDatabase_Path(
      arg0,
    );
  }

  late final _CBLDatabase_Path_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Path>>('CBLDatabase_Path');
  late final _dart_CBLDatabase_Path _CBLDatabase_Path =
      _CBLDatabase_Path_ptr.asFunction<_dart_CBLDatabase_Path>();

  /// Returns the number of documents in the database.
  int CBLDatabase_Count(
    ffi.Pointer<CBLDatabase> arg0,
  ) {
    return _CBLDatabase_Count(
      arg0,
    );
  }

  late final _CBLDatabase_Count_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Count>>('CBLDatabase_Count');
  late final _dart_CBLDatabase_Count _CBLDatabase_Count =
      _CBLDatabase_Count_ptr.asFunction<_dart_CBLDatabase_Count>();

  /// Returns the database's configuration, as given when it was opened.
  /// @note  The encryption key is not filled in, for security reasons.
  CBLDatabaseConfiguration CBLDatabase_Config(
    ffi.Pointer<CBLDatabase> arg0,
  ) {
    return _CBLDatabase_Config(
      arg0,
    );
  }

  late final _CBLDatabase_Config_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Config>>('CBLDatabase_Config');
  late final _dart_CBLDatabase_Config _CBLDatabase_Config =
      _CBLDatabase_Config_ptr.asFunction<_dart_CBLDatabase_Config>();

  /// Registers a database change listener callback. It will be called after one or more
  /// documents are changed on disk.
  /// @param db  The database to observe.
  /// @param listener  The callback to be invoked.
  /// @param context  An opaque value that will be passed to the callback.
  /// @return  A token to be passed to \ref CBLListener_Remove when it's time to remove the
  /// listener.
  ffi.Pointer<CBLListenerToken> CBLDatabase_AddChangeListener(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<ffi.NativeFunction<CBLDatabaseChangeListener>> listener,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLDatabase_AddChangeListener(
      db,
      listener,
      context,
    );
  }

  late final _CBLDatabase_AddChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_AddChangeListener>>(
          'CBLDatabase_AddChangeListener');
  late final _dart_CBLDatabase_AddChangeListener
      _CBLDatabase_AddChangeListener = _CBLDatabase_AddChangeListener_ptr
          .asFunction<_dart_CBLDatabase_AddChangeListener>();

  /// Switches the database to buffered-notification mode. Notifications for objects belonging
  /// to this database (documents, queries, replicators, and of course the database) will not be
  /// called immediately; your \ref CBLNotificationsReadyCallback will be called instead.
  /// @param db  The database whose notifications are to be buffered.
  /// @param callback  The function to be called when a notification is available.
  /// @param context  An arbitrary value that will be passed to the callback.
  void CBLDatabase_BufferNotifications(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<ffi.NativeFunction<CBLNotificationsReadyCallback>> callback,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLDatabase_BufferNotifications(
      db,
      callback,
      context,
    );
  }

  late final _CBLDatabase_BufferNotifications_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_BufferNotifications>>(
          'CBLDatabase_BufferNotifications');
  late final _dart_CBLDatabase_BufferNotifications
      _CBLDatabase_BufferNotifications = _CBLDatabase_BufferNotifications_ptr
          .asFunction<_dart_CBLDatabase_BufferNotifications>();

  /// Immediately issues all pending notifications for this database, by calling their listener
  /// callbacks.
  void CBLDatabase_SendNotifications(
    ffi.Pointer<CBLDatabase> db,
  ) {
    return _CBLDatabase_SendNotifications(
      db,
    );
  }

  late final _CBLDatabase_SendNotifications_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_SendNotifications>>(
          'CBLDatabase_SendNotifications');
  late final _dart_CBLDatabase_SendNotifications
      _CBLDatabase_SendNotifications = _CBLDatabase_SendNotifications_ptr
          .asFunction<_dart_CBLDatabase_SendNotifications>();

  /// Reads a document from the database, creating a new (immutable) \ref CBLDocument object.
  /// Each call to this function creates a new object (which must later be released.)
  /// @note  If you are reading the document in order to make changes to it, call
  /// \ref CBLDatabase_GetMutableDocument instead.
  /// @param database  The database.
  /// @param docID  The ID of the document.
  /// @return  A new \ref CBLDocument instance, or NULL if no document with that ID exists.
  ffi.Pointer<CBLDocument> CBLDatabase_GetDocument(
    ffi.Pointer<CBLDatabase> database,
    ffi.Pointer<ffi.Int8> docID,
  ) {
    return _CBLDatabase_GetDocument(
      database,
      docID,
    );
  }

  late final _CBLDatabase_GetDocument_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_GetDocument>>(
          'CBLDatabase_GetDocument');
  late final _dart_CBLDatabase_GetDocument _CBLDatabase_GetDocument =
      _CBLDatabase_GetDocument_ptr.asFunction<_dart_CBLDatabase_GetDocument>();

  ffi.Pointer<CBLDocument> CBLDatabase_GetDocument_s(
    ffi.Pointer<CBLDatabase> database,
    FLSlice docID,
  ) {
    return _CBLDatabase_GetDocument_s(
      database,
      docID,
    );
  }

  late final _CBLDatabase_GetDocument_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_GetDocument_s>>(
          'CBLDatabase_GetDocument_s');
  late final _dart_CBLDatabase_GetDocument_s _CBLDatabase_GetDocument_s =
      _CBLDatabase_GetDocument_s_ptr.asFunction<
          _dart_CBLDatabase_GetDocument_s>();

  /// Saves a (mutable) document to the database.
  /// If a conflicting revision has been saved since \p doc was loaded, the \p concurrency
  /// parameter specifies whether the save should fail, or the conflicting revision should
  /// be overwritten with the revision being saved.
  /// If you need finer-grained control, call \ref CBLDatabase_SaveDocumentResolving instead.
  /// @param db  The database to save to.
  /// @param doc  The mutable document to save.
  /// @param concurrency  Conflict-handling strategy (fail or overwrite).
  /// @param error  On failure, the error will be written here.
  /// @return  An updated document reflecting the saved changes, or NULL on failure.
  ffi.Pointer<CBLDocument> CBLDatabase_SaveDocument(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    int concurrency,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLDatabase_SaveDocument(
      db,
      doc,
      concurrency,
      error,
    );
  }

  late final _CBLDatabase_SaveDocument_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_SaveDocument>>(
          'CBLDatabase_SaveDocument');
  late final _dart_CBLDatabase_SaveDocument _CBLDatabase_SaveDocument =
      _CBLDatabase_SaveDocument_ptr.asFunction<
          _dart_CBLDatabase_SaveDocument>();

  /// Saves a (mutable) document to the database. This function is the same as \ref
  /// CBLDatabase_SaveDocument, except that it allows for custom conflict handling in the event
  /// that the document has been updated since \p doc was loaded.
  /// @param db  The database to save to.
  /// @param doc  The mutable document to save.
  /// @param conflictHandler  The callback to be invoked if there is a conflict.
  /// @param context  An arbitrary value to be passed to the \p conflictHandler.
  /// @param error  On failure, the error will be written here.
  /// @return  An updated document reflecting the saved changes, or NULL on failure.
  ffi.Pointer<CBLDocument> CBLDatabase_SaveDocumentResolving(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    ffi.Pointer<ffi.NativeFunction<CBLSaveConflictHandler>> conflictHandler,
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLDatabase_SaveDocumentResolving(
      db,
      doc,
      conflictHandler,
      context,
      error,
    );
  }

  late final _CBLDatabase_SaveDocumentResolving_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_SaveDocumentResolving>>(
          'CBLDatabase_SaveDocumentResolving');
  late final _dart_CBLDatabase_SaveDocumentResolving
      _CBLDatabase_SaveDocumentResolving =
      _CBLDatabase_SaveDocumentResolving_ptr.asFunction<
          _dart_CBLDatabase_SaveDocumentResolving>();

  /// Deletes a document from the database. Deletions are replicated.
  /// @warning  You are still responsible for releasing the CBLDocument.
  /// @param document  The document to delete.
  /// @param concurrency  Conflict-handling strategy.
  /// @param error  On failure, the error will be written here.
  /// @return  True if the document was deleted, false if an error occurred.
  bool CBLDocument_Delete(
    ffi.Pointer<CBLDocument> document,
    int concurrency,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLDocument_Delete(
          document,
          concurrency,
          error,
        ) !=
        0;
  }

  late final _CBLDocument_Delete_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_Delete>>('CBLDocument_Delete');
  late final _dart_CBLDocument_Delete _CBLDocument_Delete =
      _CBLDocument_Delete_ptr.asFunction<_dart_CBLDocument_Delete>();

  /// Purges a document. This removes all traces of the document from the database.
  /// Purges are _not_ replicated. If the document is changed on a server, it will be re-created
  /// when pulled.
  /// @warning  You are still responsible for releasing the \ref CBLDocument reference.
  /// @note If you don't have the document in memory already, \ref CBLDatabase_PurgeDocumentByID is a
  /// simpler shortcut.
  /// @param document  The document to delete.
  /// @param error  On failure, the error will be written here.
  /// @return  True if the document was purged, false if it doesn't exist or the purge failed.
  bool CBLDocument_Purge(
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLDocument_Purge(
          document,
          error,
        ) !=
        0;
  }

  late final _CBLDocument_Purge_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_Purge>>('CBLDocument_Purge');
  late final _dart_CBLDocument_Purge _CBLDocument_Purge =
      _CBLDocument_Purge_ptr.asFunction<_dart_CBLDocument_Purge>();

  /// Purges a document, given only its ID.
  /// @note  If no document with that ID exists, this function will return false but the error
  /// code will be zero.
  /// @param database  The database.
  /// @param docID  The document ID to purge.
  /// @param error  On failure, the error will be written here.
  /// @return  True if the document was purged, false if it doesn't exist or the purge failed.
  bool CBLDatabase_PurgeDocumentByID(
    ffi.Pointer<CBLDatabase> database,
    ffi.Pointer<ffi.Int8> docID,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLDatabase_PurgeDocumentByID(
          database,
          docID,
          error,
        ) !=
        0;
  }

  late final _CBLDatabase_PurgeDocumentByID_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_PurgeDocumentByID>>(
          'CBLDatabase_PurgeDocumentByID');
  late final _dart_CBLDatabase_PurgeDocumentByID
      _CBLDatabase_PurgeDocumentByID = _CBLDatabase_PurgeDocumentByID_ptr
          .asFunction<_dart_CBLDatabase_PurgeDocumentByID>();

  bool CBLDatabase_PurgeDocumentByID_s(
    ffi.Pointer<CBLDatabase> database,
    FLSlice docID,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLDatabase_PurgeDocumentByID_s(
          database,
          docID,
          error,
        ) !=
        0;
  }

  late final _CBLDatabase_PurgeDocumentByID_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_PurgeDocumentByID_s>>(
          'CBLDatabase_PurgeDocumentByID_s');
  late final _dart_CBLDatabase_PurgeDocumentByID_s
      _CBLDatabase_PurgeDocumentByID_s = _CBLDatabase_PurgeDocumentByID_s_ptr
          .asFunction<_dart_CBLDatabase_PurgeDocumentByID_s>();

  /// Reads a document from the database, in mutable form that can be updated and saved.
  /// (This function is otherwise identical to \ref CBLDatabase_GetDocument.)
  /// @note  You must release the document when you're done with it.
  /// @param database  The database.
  /// @param docID  The ID of the document.
  /// @return  A new mutable CBLDocument instance, or NULL if no document with that ID exists.
  ffi.Pointer<CBLDocument> CBLDatabase_GetMutableDocument(
    ffi.Pointer<CBLDatabase> database,
    ffi.Pointer<ffi.Int8> docID,
  ) {
    return _CBLDatabase_GetMutableDocument(
      database,
      docID,
    );
  }

  late final _CBLDatabase_GetMutableDocument_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_GetMutableDocument>>(
          'CBLDatabase_GetMutableDocument');
  late final _dart_CBLDatabase_GetMutableDocument
      _CBLDatabase_GetMutableDocument = _CBLDatabase_GetMutableDocument_ptr
          .asFunction<_dart_CBLDatabase_GetMutableDocument>();

  ffi.Pointer<CBLDocument> CBLDatabase_GetMutableDocument_s(
    ffi.Pointer<CBLDatabase> database,
    FLSlice docID,
  ) {
    return _CBLDatabase_GetMutableDocument_s(
      database,
      docID,
    );
  }

  late final _CBLDatabase_GetMutableDocument_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_GetMutableDocument_s>>(
          'CBLDatabase_GetMutableDocument_s');
  late final _dart_CBLDatabase_GetMutableDocument_s
      _CBLDatabase_GetMutableDocument_s = _CBLDatabase_GetMutableDocument_s_ptr
          .asFunction<_dart_CBLDatabase_GetMutableDocument_s>();

  /// Creates a new, empty document in memory. It will not be added to a database until saved.
  /// @param docID  The ID of the new document, or NULL to assign a new unique ID.
  /// @return  The mutable document instance.
  ffi.Pointer<CBLDocument> CBLDocument_New(
    ffi.Pointer<ffi.Int8> docID,
  ) {
    return _CBLDocument_New(
      docID,
    );
  }

  late final _CBLDocument_New_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_New>>('CBLDocument_New');
  late final _dart_CBLDocument_New _CBLDocument_New =
      _CBLDocument_New_ptr.asFunction<_dart_CBLDocument_New>();

  ffi.Pointer<CBLDocument> CBLDocument_New_s(
    FLSlice docID,
  ) {
    return _CBLDocument_New_s(
      docID,
    );
  }

  late final _CBLDocument_New_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_New_s>>('CBLDocument_New_s');
  late final _dart_CBLDocument_New_s _CBLDocument_New_s =
      _CBLDocument_New_s_ptr.asFunction<_dart_CBLDocument_New_s>();

  /// Creates a new mutable CBLDocument instance that refers to the same document as the original.
  /// If the original document has unsaved changes, the new one will also start out with the same
  /// changes; but mutating one document thereafter will not affect the other.
  /// @note  You must release the new reference when you're done with it.
  ffi.Pointer<CBLDocument> CBLDocument_MutableCopy(
    ffi.Pointer<CBLDocument> original,
  ) {
    return _CBLDocument_MutableCopy(
      original,
    );
  }

  late final _CBLDocument_MutableCopy_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_MutableCopy>>(
          'CBLDocument_MutableCopy');
  late final _dart_CBLDocument_MutableCopy _CBLDocument_MutableCopy =
      _CBLDocument_MutableCopy_ptr.asFunction<_dart_CBLDocument_MutableCopy>();

  /// Returns a document's ID.
  ffi.Pointer<ffi.Int8> CBLDocument_ID(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_ID(
      arg0,
    );
  }

  late final _CBLDocument_ID_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_ID>>('CBLDocument_ID');
  late final _dart_CBLDocument_ID _CBLDocument_ID =
      _CBLDocument_ID_ptr.asFunction<_dart_CBLDocument_ID>();

  /// Returns a document's revision ID, which is a short opaque string that's guaranteed to be
  /// unique to every change made to the document.
  /// If the document doesn't exist yet, this function returns NULL.
  ffi.Pointer<ffi.Int8> CBLDocument_RevisionID(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_RevisionID(
      arg0,
    );
  }

  late final _CBLDocument_RevisionID_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_RevisionID>>(
          'CBLDocument_RevisionID');
  late final _dart_CBLDocument_RevisionID _CBLDocument_RevisionID =
      _CBLDocument_RevisionID_ptr.asFunction<_dart_CBLDocument_RevisionID>();

  /// Returns a document's current sequence in the local database.
  /// This number increases every time the document is saved, and a more recently saved document
  /// will have a greater sequence number than one saved earlier, so sequences may be used as an
  /// abstract 'clock' to tell relative modification times.
  int CBLDocument_Sequence(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_Sequence(
      arg0,
    );
  }

  late final _CBLDocument_Sequence_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_Sequence>>(
          'CBLDocument_Sequence');
  late final _dart_CBLDocument_Sequence _CBLDocument_Sequence =
      _CBLDocument_Sequence_ptr.asFunction<_dart_CBLDocument_Sequence>();

  /// Returns a document's properties as a dictionary.
  /// @note  The dictionary object is owned by the document; you do not need to release it.
  /// @warning  When the document is released, this reference to the properties becomes invalid.
  /// If you need to use any properties after releasing the document, you must retain them
  /// by calling \ref FLValue_Retain (and of course later release them.)
  /// @warning  This dictionary _reference_ is immutable, but if the document is mutable the
  /// underlying dictionary itself is mutable and could be modified through a mutable
  /// reference obtained via \ref CBLDocument_MutableProperties. If you need to preserve the
  /// properties, call \ref FLDict_MutableCopy to make a deep copy.
  ffi.Pointer<FLDict> CBLDocument_Properties(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_Properties(
      arg0,
    );
  }

  late final _CBLDocument_Properties_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_Properties>>(
          'CBLDocument_Properties');
  late final _dart_CBLDocument_Properties _CBLDocument_Properties =
      _CBLDocument_Properties_ptr.asFunction<_dart_CBLDocument_Properties>();

  /// Returns a mutable document's properties as a mutable dictionary.
  /// You may modify this dictionary and then call \ref CBLDatabase_SaveDocument to persist the changes.
  /// @note  The dictionary object is owned by the document; you do not need to release it.
  /// @note  Every call to this function returns the same mutable collection. This is the
  /// same collection returned by \ref CBLDocument_Properties.
  /// @warning  When the document is released, this reference to the properties becomes invalid.
  /// If you need to use any properties after releasing the document, you must retain them
  /// by calling \ref FLValue_Retain (and of course later release them.)
  ffi.Pointer<FLDict> CBLDocument_MutableProperties(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_MutableProperties(
      arg0,
    );
  }

  late final _CBLDocument_MutableProperties_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_MutableProperties>>(
          'CBLDocument_MutableProperties');
  late final _dart_CBLDocument_MutableProperties
      _CBLDocument_MutableProperties = _CBLDocument_MutableProperties_ptr
          .asFunction<_dart_CBLDocument_MutableProperties>();

  /// Sets a mutable document's properties.
  /// Call \ref CBLDatabase_SaveDocument to persist the changes.
  /// @note  The dictionary object will be retained by the document. You are responsible for
  /// releasing any retained reference(s) you have to it.
  void CBLDocument_SetProperties(
    ffi.Pointer<CBLDocument> arg0,
    ffi.Pointer<FLDict> properties,
  ) {
    return _CBLDocument_SetProperties(
      arg0,
      properties,
    );
  }

  late final _CBLDocument_SetProperties_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_SetProperties>>(
          'CBLDocument_SetProperties');
  late final _dart_CBLDocument_SetProperties _CBLDocument_SetProperties =
      _CBLDocument_SetProperties_ptr.asFunction<
          _dart_CBLDocument_SetProperties>();

  ffi.Pointer<FLDoc> CBLDocument_CreateFleeceDoc(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_CreateFleeceDoc(
      arg0,
    );
  }

  late final _CBLDocument_CreateFleeceDoc_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_CreateFleeceDoc>>(
          'CBLDocument_CreateFleeceDoc');
  late final _dart_CBLDocument_CreateFleeceDoc _CBLDocument_CreateFleeceDoc =
      _CBLDocument_CreateFleeceDoc_ptr.asFunction<
          _dart_CBLDocument_CreateFleeceDoc>();

  /// Returns a document's properties as a null-terminated JSON string.
  /// @note You are responsible for calling `free()` on the returned string.
  ffi.Pointer<ffi.Int8> CBLDocument_PropertiesAsJSON(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_PropertiesAsJSON(
      arg0,
    );
  }

  late final _CBLDocument_PropertiesAsJSON_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_PropertiesAsJSON>>(
          'CBLDocument_PropertiesAsJSON');
  late final _dart_CBLDocument_PropertiesAsJSON _CBLDocument_PropertiesAsJSON =
      _CBLDocument_PropertiesAsJSON_ptr.asFunction<
          _dart_CBLDocument_PropertiesAsJSON>();

  /// Sets a mutable document's properties from a JSON string.
  bool CBLDocument_SetPropertiesAsJSON(
    ffi.Pointer<CBLDocument> arg0,
    ffi.Pointer<ffi.Int8> json,
    ffi.Pointer<CBLError> arg2,
  ) {
    return _CBLDocument_SetPropertiesAsJSON(
          arg0,
          json,
          arg2,
        ) !=
        0;
  }

  late final _CBLDocument_SetPropertiesAsJSON_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_SetPropertiesAsJSON>>(
          'CBLDocument_SetPropertiesAsJSON');
  late final _dart_CBLDocument_SetPropertiesAsJSON
      _CBLDocument_SetPropertiesAsJSON = _CBLDocument_SetPropertiesAsJSON_ptr
          .asFunction<_dart_CBLDocument_SetPropertiesAsJSON>();

  bool CBLDocument_SetPropertiesAsJSON_s(
    ffi.Pointer<CBLDocument> arg0,
    FLSlice json,
    ffi.Pointer<CBLError> arg2,
  ) {
    return _CBLDocument_SetPropertiesAsJSON_s(
          arg0,
          json,
          arg2,
        ) !=
        0;
  }

  late final _CBLDocument_SetPropertiesAsJSON_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_SetPropertiesAsJSON_s>>(
          'CBLDocument_SetPropertiesAsJSON_s');
  late final _dart_CBLDocument_SetPropertiesAsJSON_s
      _CBLDocument_SetPropertiesAsJSON_s =
      _CBLDocument_SetPropertiesAsJSON_s_ptr.asFunction<
          _dart_CBLDocument_SetPropertiesAsJSON_s>();

  /// Returns the time, if any, at which a given document will expire and be purged.
  /// Documents don't normally expire; you have to call \ref CBLDatabase_SetDocumentExpiration
  /// to set a document's expiration time.
  /// @param db  The database.
  /// @param docID  The ID of the document.
  /// @param error  On failure, an error is written here.
  /// @return  The expiration time as a CBLTimestamp (milliseconds since Unix epoch),
  /// or 0 if the document does not have an expiration,
  /// or -1 if the call failed.
  int CBLDatabase_GetDocumentExpiration(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<ffi.Int8> docID,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLDatabase_GetDocumentExpiration(
      db,
      docID,
      error,
    );
  }

  late final _CBLDatabase_GetDocumentExpiration_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_GetDocumentExpiration>>(
          'CBLDatabase_GetDocumentExpiration');
  late final _dart_CBLDatabase_GetDocumentExpiration
      _CBLDatabase_GetDocumentExpiration =
      _CBLDatabase_GetDocumentExpiration_ptr.asFunction<
          _dart_CBLDatabase_GetDocumentExpiration>();

  int CBLDatabase_GetDocumentExpiration_s(
    ffi.Pointer<CBLDatabase> db,
    FLSlice docID,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLDatabase_GetDocumentExpiration_s(
      db,
      docID,
      error,
    );
  }

  late final _CBLDatabase_GetDocumentExpiration_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_GetDocumentExpiration_s>>(
          'CBLDatabase_GetDocumentExpiration_s');
  late final _dart_CBLDatabase_GetDocumentExpiration_s
      _CBLDatabase_GetDocumentExpiration_s =
      _CBLDatabase_GetDocumentExpiration_s_ptr.asFunction<
          _dart_CBLDatabase_GetDocumentExpiration_s>();

  /// Sets or clears the expiration time of a document.
  /// @param db  The database.
  /// @param docID  The ID of the document.
  /// @param expiration  The expiration time as a CBLTimestamp (milliseconds since Unix epoch),
  /// or 0 if the document should never expire.
  /// @param error  On failure, an error is written here.
  /// @return  True on success, false on failure.
  bool CBLDatabase_SetDocumentExpiration(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<ffi.Int8> docID,
    int expiration,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLDatabase_SetDocumentExpiration(
          db,
          docID,
          expiration,
          error,
        ) !=
        0;
  }

  late final _CBLDatabase_SetDocumentExpiration_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_SetDocumentExpiration>>(
          'CBLDatabase_SetDocumentExpiration');
  late final _dart_CBLDatabase_SetDocumentExpiration
      _CBLDatabase_SetDocumentExpiration =
      _CBLDatabase_SetDocumentExpiration_ptr.asFunction<
          _dart_CBLDatabase_SetDocumentExpiration>();

  bool CBLDatabase_SetDocumentExpiration_s(
    ffi.Pointer<CBLDatabase> db,
    FLSlice docID,
    int expiration,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLDatabase_SetDocumentExpiration_s(
          db,
          docID,
          expiration,
          error,
        ) !=
        0;
  }

  late final _CBLDatabase_SetDocumentExpiration_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_SetDocumentExpiration_s>>(
          'CBLDatabase_SetDocumentExpiration_s');
  late final _dart_CBLDatabase_SetDocumentExpiration_s
      _CBLDatabase_SetDocumentExpiration_s =
      _CBLDatabase_SetDocumentExpiration_s_ptr.asFunction<
          _dart_CBLDatabase_SetDocumentExpiration_s>();

  /// Registers a document change listener callback. It will be called after a specific document
  /// is changed on disk.
  /// @param db  The database to observe.
  /// @param docID  The ID of the document to observe.
  /// @param listener  The callback to be invoked.
  /// @param context  An opaque value that will be passed to the callback.
  /// @return  A token to be passed to \ref CBLListener_Remove when it's time to remove the
  /// listener.
  ffi.Pointer<CBLListenerToken> CBLDatabase_AddDocumentChangeListener(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<ffi.Int8> docID,
    ffi.Pointer<ffi.NativeFunction<CBLDocumentChangeListener>> listener,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLDatabase_AddDocumentChangeListener(
      db,
      docID,
      listener,
      context,
    );
  }

  late final _CBLDatabase_AddDocumentChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_AddDocumentChangeListener>>(
          'CBLDatabase_AddDocumentChangeListener');
  late final _dart_CBLDatabase_AddDocumentChangeListener
      _CBLDatabase_AddDocumentChangeListener =
      _CBLDatabase_AddDocumentChangeListener_ptr.asFunction<
          _dart_CBLDatabase_AddDocumentChangeListener>();

  /// Formats and writes a message to the log, in the given domain at the given level.
  /// \warning This function takes a `printf`-style format string, with extra parameters to match the format placeholders, and has the same security vulnerabilities as other `printf`-style functions.
  /// If you are logging a fixed string, call \ref CBL_Log_s instead, otherwise any `%` characters in the
  /// `format` string will be misinterpreted as placeholders and the dreaded Undefined Behavior will result,
  /// possibly including crashes or overwriting the stack.
  /// @param domain  The log domain to associate this message with.
  /// @param level  The severity of the message. If this is lower than the current minimum level for the domain
  /// (as set by \ref CBLLog_SetConsoleLevel), nothing is logged.
  /// @param format  A `printf`-style format string. `%` characters in this string introduce parameters,
  /// and corresponding arguments must follow.
  void CBL_Log(
    int domain,
    int level,
    ffi.Pointer<ffi.Int8> format,
  ) {
    return _CBL_Log(
      domain,
      level,
      format,
    );
  }

  late final _CBL_Log_ptr = _lookup<ffi.NativeFunction<_c_CBL_Log>>('CBL_Log');
  late final _dart_CBL_Log _CBL_Log = _CBL_Log_ptr.asFunction<_dart_CBL_Log>();

  /// Writes a pre-formatted message to the log, exactly as given.
  /// @param domain  The log domain to associate this message with.
  /// @param level  The severity of the message. If this is lower than the current minimum level for the domain
  /// (as set by \ref CBLLog_SetConsoleLevel), nothing is logged.
  /// @param message  The exact message to write to the log.
  void CBL_Log_s(
    int domain,
    int level,
    FLSlice message,
  ) {
    return _CBL_Log_s(
      domain,
      level,
      message,
    );
  }

  late final _CBL_Log_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_Log_s>>('CBL_Log_s');
  late final _dart_CBL_Log_s _CBL_Log_s =
      _CBL_Log_s_ptr.asFunction<_dart_CBL_Log_s>();

  /// Gets the current log level for debug console logging.
  /// Only messages at this level or higher will be logged to the console or callback.
  int CBLLog_ConsoleLevel() {
    return _CBLLog_ConsoleLevel();
  }

  late final _CBLLog_ConsoleLevel_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_ConsoleLevel>>(
          'CBLLog_ConsoleLevel');
  late final _dart_CBLLog_ConsoleLevel _CBLLog_ConsoleLevel =
      _CBLLog_ConsoleLevel_ptr.asFunction<_dart_CBLLog_ConsoleLevel>();

  /// Sets the detail level of logging.
  /// Only messages whose level is  the given level will be logged to the console or callback.
  void CBLLog_SetConsoleLevel(
    int arg0,
  ) {
    return _CBLLog_SetConsoleLevel(
      arg0,
    );
  }

  late final _CBLLog_SetConsoleLevel_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_SetConsoleLevel>>(
          'CBLLog_SetConsoleLevel');
  late final _dart_CBLLog_SetConsoleLevel _CBLLog_SetConsoleLevel =
      _CBLLog_SetConsoleLevel_ptr.asFunction<_dart_CBLLog_SetConsoleLevel>();

  /// Returns true if a message with the given domain and level would be logged to the console.
  bool CBLLog_WillLogToConsole(
    int domain,
    int level,
  ) {
    return _CBLLog_WillLogToConsole(
          domain,
          level,
        ) !=
        0;
  }

  late final _CBLLog_WillLogToConsole_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_WillLogToConsole>>(
          'CBLLog_WillLogToConsole');
  late final _dart_CBLLog_WillLogToConsole _CBLLog_WillLogToConsole =
      _CBLLog_WillLogToConsole_ptr.asFunction<_dart_CBLLog_WillLogToConsole>();

  /// Gets the current log callback.
  ffi.Pointer<ffi.NativeFunction<CBLLogCallback>> CBLLog_Callback() {
    return _CBLLog_Callback();
  }

  late final _CBLLog_Callback_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_Callback>>('CBLLog_Callback');
  late final _dart_CBLLog_Callback _CBLLog_Callback =
      _CBLLog_Callback_ptr.asFunction<_dart_CBLLog_Callback>();

  /// Sets the callback for receiving log messages. If set to NULL, no messages are logged to the console.
  void CBLLog_SetCallback(
    ffi.Pointer<ffi.NativeFunction<CBLLogCallback>> arg0,
  ) {
    return _CBLLog_SetCallback(
      arg0,
    );
  }

  late final _CBLLog_SetCallback_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_SetCallback>>('CBLLog_SetCallback');
  late final _dart_CBLLog_SetCallback _CBLLog_SetCallback =
      _CBLLog_SetCallback_ptr.asFunction<_dart_CBLLog_SetCallback>();

  /// Gets the current file logging configuration.
  ffi.Pointer<CBLLogFileConfiguration> CBLLog_FileConfig() {
    return _CBLLog_FileConfig();
  }

  late final _CBLLog_FileConfig_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_FileConfig>>('CBLLog_FileConfig');
  late final _dart_CBLLog_FileConfig _CBLLog_FileConfig =
      _CBLLog_FileConfig_ptr.asFunction<_dart_CBLLog_FileConfig>();

  /// Sets the file logging configuration.
  void CBLLog_SetFileConfig(
    CBLLogFileConfiguration arg0,
  ) {
    return _CBLLog_SetFileConfig(
      arg0,
    );
  }

  late final _CBLLog_SetFileConfig_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_SetFileConfig>>(
          'CBLLog_SetFileConfig');
  late final _dart_CBLLog_SetFileConfig _CBLLog_SetFileConfig =
      _CBLLog_SetFileConfig_ptr.asFunction<_dart_CBLLog_SetFileConfig>();

  /// Creates a new query by compiling the input string.
  /// This is fast, but not instantaneous. If you need to run the same query many times, keep the
  /// \ref CBLQuery around instead of compiling it each time. If you need to run related queries
  /// with only some values different, create one query with placeholder parameter(s), and substitute
  /// the desired value(s) with \ref CBLQuery_SetParameters each time you run the query.
  /// @note  You must release the \ref CBLQuery when you're finished with it.
  /// @param db  The database to query.
  /// @param language  The query language,
  /// [JSON](https://github.com/couchbase/couchbase-lite-core/wiki/JSON-Query-Schema) or
  /// [N1QL](https://docs.couchbase.com/server/4.0/n1ql/n1ql-language-reference/index.html).
  /// @param queryString  The query string.
  /// @param outErrorPos  If non-NULL, then on a parse error the approximate byte offset in the
  /// input expression will be stored here (or -1 if not known/applicable.)
  /// @param error  On failure, the error will be written here.
  /// @return  The new query object.
  ffi.Pointer<CBLQuery> CBLQuery_New(
    ffi.Pointer<CBLDatabase> db,
    int language,
    ffi.Pointer<ffi.Int8> queryString,
    ffi.Pointer<ffi.Int32> outErrorPos,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLQuery_New(
      db,
      language,
      queryString,
      outErrorPos,
      error,
    );
  }

  late final _CBLQuery_New_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_New>>('CBLQuery_New');
  late final _dart_CBLQuery_New _CBLQuery_New =
      _CBLQuery_New_ptr.asFunction<_dart_CBLQuery_New>();

  ffi.Pointer<CBLQuery> CBLQuery_New_s(
    ffi.Pointer<CBLDatabase> db,
    int language,
    FLSlice queryString,
    ffi.Pointer<ffi.Int32> outErrorPos,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLQuery_New_s(
      db,
      language,
      queryString,
      outErrorPos,
      error,
    );
  }

  late final _CBLQuery_New_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_New_s>>('CBLQuery_New_s');
  late final _dart_CBLQuery_New_s _CBLQuery_New_s =
      _CBLQuery_New_s_ptr.asFunction<_dart_CBLQuery_New_s>();

  /// Assigns values to the query's parameters.
  /// These values will be substited for those parameters whenever the query is executed,
  /// until they are next assigned.
  ///
  /// Parameters are specified in the query source as
  /// e.g. `$PARAM` (N1QL) or `["$PARAM"]` (JSON). In this example, the `parameters` dictionary
  /// to this call should have a key `PARAM` that maps to the value of the parameter.
  /// @param query  The query.
  /// @param parameters  The parameters in the form of a Fleece \ref FLDict "dictionary" whose
  /// keys are the parameter names. (It's easiest to construct this by using the mutable
  /// API, i.e. calling \ref FLMutableDict_New and adding keys/values.)
  void CBLQuery_SetParameters(
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<FLDict> parameters,
  ) {
    return _CBLQuery_SetParameters(
      query,
      parameters,
    );
  }

  late final _CBLQuery_SetParameters_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_SetParameters>>(
          'CBLQuery_SetParameters');
  late final _dart_CBLQuery_SetParameters _CBLQuery_SetParameters =
      _CBLQuery_SetParameters_ptr.asFunction<_dart_CBLQuery_SetParameters>();

  /// Returns the query's current parameter bindings, if any.
  ffi.Pointer<FLDict> CBLQuery_Parameters(
    ffi.Pointer<CBLQuery> query,
  ) {
    return _CBLQuery_Parameters(
      query,
    );
  }

  late final _CBLQuery_Parameters_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_Parameters>>(
          'CBLQuery_Parameters');
  late final _dart_CBLQuery_Parameters _CBLQuery_Parameters =
      _CBLQuery_Parameters_ptr.asFunction<_dart_CBLQuery_Parameters>();

  /// Assigns values to the query's parameters, from JSON data.
  /// See \ref CBLQuery_SetParameters for details.
  /// @param query  The query.
  /// @param json  The parameters in the form of a JSON-encoded object whose
  /// keys are the parameter names. (You may use JSON5 syntax.)
  bool CBLQuery_SetParametersAsJSON(
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<ffi.Int8> json,
  ) {
    return _CBLQuery_SetParametersAsJSON(
          query,
          json,
        ) !=
        0;
  }

  late final _CBLQuery_SetParametersAsJSON_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_SetParametersAsJSON>>(
          'CBLQuery_SetParametersAsJSON');
  late final _dart_CBLQuery_SetParametersAsJSON _CBLQuery_SetParametersAsJSON =
      _CBLQuery_SetParametersAsJSON_ptr.asFunction<
          _dart_CBLQuery_SetParametersAsJSON>();

  bool CBLQuery_SetParametersAsJSON_s(
    ffi.Pointer<CBLQuery> query,
    FLSlice json,
  ) {
    return _CBLQuery_SetParametersAsJSON_s(
          query,
          json,
        ) !=
        0;
  }

  late final _CBLQuery_SetParametersAsJSON_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_SetParametersAsJSON_s>>(
          'CBLQuery_SetParametersAsJSON_s');
  late final _dart_CBLQuery_SetParametersAsJSON_s
      _CBLQuery_SetParametersAsJSON_s = _CBLQuery_SetParametersAsJSON_s_ptr
          .asFunction<_dart_CBLQuery_SetParametersAsJSON_s>();

  /// Runs the query, returning the results.
  /// To obtain the results you'll typically call \ref CBLResultSet_Next in a `while` loop,
  /// examining the values in the \ref CBLResultSet each time around.
  /// @note  You must release the result set when you're finished with it.
  ffi.Pointer<CBLResultSet> CBLQuery_Execute(
    ffi.Pointer<CBLQuery> arg0,
    ffi.Pointer<CBLError> arg1,
  ) {
    return _CBLQuery_Execute(
      arg0,
      arg1,
    );
  }

  late final _CBLQuery_Execute_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_Execute>>('CBLQuery_Execute');
  late final _dart_CBLQuery_Execute _CBLQuery_Execute =
      _CBLQuery_Execute_ptr.asFunction<_dart_CBLQuery_Execute>();

  /// Returns information about the query, including the translated SQLite form, and the search
  /// strategy. You can use this to help optimize the query: the word `SCAN` in the strategy
  /// indicates a linear scan of the entire database, which should be avoided by adding an index.
  /// The strategy will also show which index(es), if any, are used.
  FLSliceResult CBLQuery_Explain(
    ffi.Pointer<CBLQuery> arg0,
  ) {
    return _CBLQuery_Explain(
      arg0,
    );
  }

  late final _CBLQuery_Explain_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_Explain>>('CBLQuery_Explain');
  late final _dart_CBLQuery_Explain _CBLQuery_Explain =
      _CBLQuery_Explain_ptr.asFunction<_dart_CBLQuery_Explain>();

  /// Returns the number of columns in each result.
  int CBLQuery_ColumnCount(
    ffi.Pointer<CBLQuery> arg0,
  ) {
    return _CBLQuery_ColumnCount(
      arg0,
    );
  }

  late final _CBLQuery_ColumnCount_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_ColumnCount>>(
          'CBLQuery_ColumnCount');
  late final _dart_CBLQuery_ColumnCount _CBLQuery_ColumnCount =
      _CBLQuery_ColumnCount_ptr.asFunction<_dart_CBLQuery_ColumnCount>();

  /// Returns the name of a column in the result.
  /// The column name is based on its expression in the `SELECT...` or `WHAT:` section of the
  /// query. A column that returns a property or property path will be named after that property.
  /// A column that returns an expression will have an automatically-generated name like `$1`.
  /// To give a column a custom name, use the `AS` syntax in the query.
  /// Every column is guaranteed to have a unique name.
  FLSlice CBLQuery_ColumnName(
    ffi.Pointer<CBLQuery> arg0,
    int columnIndex,
  ) {
    return _CBLQuery_ColumnName(
      arg0,
      columnIndex,
    );
  }

  late final _CBLQuery_ColumnName_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_ColumnName>>(
          'CBLQuery_ColumnName');
  late final _dart_CBLQuery_ColumnName _CBLQuery_ColumnName =
      _CBLQuery_ColumnName_ptr.asFunction<_dart_CBLQuery_ColumnName>();

  /// Moves the result-set iterator to the next result.
  /// Returns false if there are no more results.
  /// @warning This must be called _before_ examining the first result.
  bool CBLResultSet_Next(
    ffi.Pointer<CBLResultSet> arg0,
  ) {
    return _CBLResultSet_Next(
          arg0,
        ) !=
        0;
  }

  late final _CBLResultSet_Next_ptr =
      _lookup<ffi.NativeFunction<_c_CBLResultSet_Next>>('CBLResultSet_Next');
  late final _dart_CBLResultSet_Next _CBLResultSet_Next =
      _CBLResultSet_Next_ptr.asFunction<_dart_CBLResultSet_Next>();

  /// Returns the value of a column of the current result, given its (zero-based) numeric index.
  /// This may return a NULL pointer, indicating `MISSING`, if the value doesn't exist, e.g. if
  /// the column is a property that doesn't exist in the document.
  ffi.Pointer<FLValue> CBLResultSet_ValueAtIndex(
    ffi.Pointer<CBLResultSet> arg0,
    int index,
  ) {
    return _CBLResultSet_ValueAtIndex(
      arg0,
      index,
    );
  }

  late final _CBLResultSet_ValueAtIndex_ptr =
      _lookup<ffi.NativeFunction<_c_CBLResultSet_ValueAtIndex>>(
          'CBLResultSet_ValueAtIndex');
  late final _dart_CBLResultSet_ValueAtIndex _CBLResultSet_ValueAtIndex =
      _CBLResultSet_ValueAtIndex_ptr.asFunction<
          _dart_CBLResultSet_ValueAtIndex>();

  /// Returns the value of a column of the current result, given its name.
  /// This may return a NULL pointer, indicating `MISSING`, if the value doesn't exist, e.g. if
  /// the column is a property that doesn't exist in the document. (Or, of course, if the key
  /// is not a column name in this query.)
  /// @note  See \ref CBLQuery_ColumnName for a discussion of column names.
  ffi.Pointer<FLValue> CBLResultSet_ValueForKey(
    ffi.Pointer<CBLResultSet> arg0,
    ffi.Pointer<ffi.Int8> key,
  ) {
    return _CBLResultSet_ValueForKey(
      arg0,
      key,
    );
  }

  late final _CBLResultSet_ValueForKey_ptr =
      _lookup<ffi.NativeFunction<_c_CBLResultSet_ValueForKey>>(
          'CBLResultSet_ValueForKey');
  late final _dart_CBLResultSet_ValueForKey _CBLResultSet_ValueForKey =
      _CBLResultSet_ValueForKey_ptr.asFunction<
          _dart_CBLResultSet_ValueForKey>();

  ffi.Pointer<FLValue> CBLResultSet_ValueForKey_s(
    ffi.Pointer<CBLResultSet> arg0,
    FLSlice key,
  ) {
    return _CBLResultSet_ValueForKey_s(
      arg0,
      key,
    );
  }

  late final _CBLResultSet_ValueForKey_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLResultSet_ValueForKey_s>>(
          'CBLResultSet_ValueForKey_s');
  late final _dart_CBLResultSet_ValueForKey_s _CBLResultSet_ValueForKey_s =
      _CBLResultSet_ValueForKey_s_ptr.asFunction<
          _dart_CBLResultSet_ValueForKey_s>();

  /// Returns the current result as an array of column values.
  /// @warning The array reference is only valid until the result-set is advanced or released.
  /// If you want to keep it for longer, call \ref FLArray_Retain (and release it when done.)
  ffi.Pointer<FLArray> CBLResultSet_RowArray(
    ffi.Pointer<CBLResultSet> arg0,
  ) {
    return _CBLResultSet_RowArray(
      arg0,
    );
  }

  late final _CBLResultSet_RowArray_ptr =
      _lookup<ffi.NativeFunction<_c_CBLResultSet_RowArray>>(
          'CBLResultSet_RowArray');
  late final _dart_CBLResultSet_RowArray _CBLResultSet_RowArray =
      _CBLResultSet_RowArray_ptr.asFunction<_dart_CBLResultSet_RowArray>();

  /// Returns the current result as a dictionary mapping column names to values.
  /// @warning The dict reference is only valid until the result-set is advanced or released.
  /// If you want to keep it for longer, call \ref FLDict_Retain (and release it when done.)
  ffi.Pointer<FLDict> CBLResultSet_RowDict(
    ffi.Pointer<CBLResultSet> arg0,
  ) {
    return _CBLResultSet_RowDict(
      arg0,
    );
  }

  late final _CBLResultSet_RowDict_ptr =
      _lookup<ffi.NativeFunction<_c_CBLResultSet_RowDict>>(
          'CBLResultSet_RowDict');
  late final _dart_CBLResultSet_RowDict _CBLResultSet_RowDict =
      _CBLResultSet_RowDict_ptr.asFunction<_dart_CBLResultSet_RowDict>();

  /// Returns the Query that created this ResultSet.
  ffi.Pointer<CBLQuery> CBLResultSet_GetQuery(
    ffi.Pointer<CBLResultSet> rs,
  ) {
    return _CBLResultSet_GetQuery(
      rs,
    );
  }

  late final _CBLResultSet_GetQuery_ptr =
      _lookup<ffi.NativeFunction<_c_CBLResultSet_GetQuery>>(
          'CBLResultSet_GetQuery');
  late final _dart_CBLResultSet_GetQuery _CBLResultSet_GetQuery =
      _CBLResultSet_GetQuery_ptr.asFunction<_dart_CBLResultSet_GetQuery>();

  /// Registers a change listener callback with a query, turning it into a "live query" until
  /// the listener is removed (via \ref CBLListener_Remove).
  ///
  /// When the first change listener is added, the query will run (in the background) and notify
  /// the listener(s) of the results when ready. After that, it will run in the background after
  /// the database changes, and only notify the listeners when the result set changes.
  /// @param query  The query to observe.
  /// @param listener  The callback to be invoked.
  /// @param context  An opaque value that will be passed to the callback.
  /// @return  A token to be passed to \ref CBLListener_Remove when it's time to remove the
  /// listener.
  ffi.Pointer<CBLListenerToken> CBLQuery_AddChangeListener(
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<ffi.NativeFunction<CBLQueryChangeListener>> listener,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLQuery_AddChangeListener(
      query,
      listener,
      context,
    );
  }

  late final _CBLQuery_AddChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_AddChangeListener>>(
          'CBLQuery_AddChangeListener');
  late final _dart_CBLQuery_AddChangeListener _CBLQuery_AddChangeListener =
      _CBLQuery_AddChangeListener_ptr.asFunction<
          _dart_CBLQuery_AddChangeListener>();

  /// Returns the query's _entire_ current result set, after it's been announced via a call to the
  /// listener's callback.
  /// @note  You must release the result set when you're finished with it.
  /// @param query  The query being listened to.
  /// @param listener  The query listener that was notified.
  /// @param error  If the query failed to run, the error will be stored here.
  /// @return  A new object containing the query's current results, or NULL if the query failed to run.
  ffi.Pointer<CBLResultSet> CBLQuery_CopyCurrentResults(
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<CBLListenerToken> listener,
    ffi.Pointer<CBLError> error,
  ) {
    return _CBLQuery_CopyCurrentResults(
      query,
      listener,
      error,
    );
  }

  late final _CBLQuery_CopyCurrentResults_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_CopyCurrentResults>>(
          'CBLQuery_CopyCurrentResults');
  late final _dart_CBLQuery_CopyCurrentResults _CBLQuery_CopyCurrentResults =
      _CBLQuery_CopyCurrentResults_ptr.asFunction<
          _dart_CBLQuery_CopyCurrentResults>();

  /// Creates a database index.
  /// Indexes are persistent.
  /// If an identical index with that name already exists, nothing happens (and no error is returned.)
  /// If a non-identical index with that name already exists, it is deleted and re-created.
  bool CBLDatabase_CreateIndex(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<ffi.Int8> name,
    CBLIndexSpec arg2,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_CreateIndex(
          db,
          name,
          arg2,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_CreateIndex_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_CreateIndex>>(
          'CBLDatabase_CreateIndex');
  late final _dart_CBLDatabase_CreateIndex _CBLDatabase_CreateIndex =
      _CBLDatabase_CreateIndex_ptr.asFunction<_dart_CBLDatabase_CreateIndex>();

  bool CBLDatabase_CreateIndex_s(
    ffi.Pointer<CBLDatabase> db,
    FLSlice name,
    CBLIndexSpec_s arg2,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_CreateIndex_s(
          db,
          name,
          arg2,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_CreateIndex_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_CreateIndex_s>>(
          'CBLDatabase_CreateIndex_s');
  late final _dart_CBLDatabase_CreateIndex_s _CBLDatabase_CreateIndex_s =
      _CBLDatabase_CreateIndex_s_ptr.asFunction<
          _dart_CBLDatabase_CreateIndex_s>();

  /// Deletes an index given its name.
  bool CBLDatabase_DeleteIndex(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_DeleteIndex(
          db,
          name,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_DeleteIndex_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_DeleteIndex>>(
          'CBLDatabase_DeleteIndex');
  late final _dart_CBLDatabase_DeleteIndex _CBLDatabase_DeleteIndex =
      _CBLDatabase_DeleteIndex_ptr.asFunction<_dart_CBLDatabase_DeleteIndex>();

  /// Returns the names of the indexes on this database, as a Fleece array of strings.
  /// @note  You are responsible for releasing the returned Fleece array.
  ffi.Pointer<FLArray> CBLDatabase_IndexNames(
    ffi.Pointer<CBLDatabase> db,
  ) {
    return _CBLDatabase_IndexNames(
      db,
    );
  }

  late final _CBLDatabase_IndexNames_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_IndexNames>>(
          'CBLDatabase_IndexNames');
  late final _dart_CBLDatabase_IndexNames _CBLDatabase_IndexNames =
      _CBLDatabase_IndexNames_ptr.asFunction<_dart_CBLDatabase_IndexNames>();

  /// The name of the HTTP cookie used by Sync Gateway to store session keys.
  late final ffi.Pointer<ffi.Pointer<ffi.Int8>> _kCBLAuthDefaultCookieName =
      _lookup<ffi.Pointer<ffi.Int8>>('kCBLAuthDefaultCookieName');

  ffi.Pointer<ffi.Int8> get kCBLAuthDefaultCookieName =>
      _kCBLAuthDefaultCookieName.value;

  set kCBLAuthDefaultCookieName(ffi.Pointer<ffi.Int8> value) =>
      _kCBLAuthDefaultCookieName.value = value;

  /// Creates a new endpoint representing a server-based database at the given URL.
  /// The URL's scheme must be `ws` or `wss`, it must of course have a valid hostname,
  /// and its path must be the name of the database on that server.
  /// The port can be omitted; it defaults to 80 for `ws` and 443 for `wss`.
  /// For example: `wss://example.org/dbname`
  ffi.Pointer<CBLEndpoint> CBLEndpoint_NewWithURL(
    ffi.Pointer<ffi.Int8> url,
  ) {
    return _CBLEndpoint_NewWithURL(
      url,
    );
  }

  late final _CBLEndpoint_NewWithURL_ptr =
      _lookup<ffi.NativeFunction<_c_CBLEndpoint_NewWithURL>>(
          'CBLEndpoint_NewWithURL');
  late final _dart_CBLEndpoint_NewWithURL _CBLEndpoint_NewWithURL =
      _CBLEndpoint_NewWithURL_ptr.asFunction<_dart_CBLEndpoint_NewWithURL>();

  ffi.Pointer<CBLEndpoint> CBLEndpoint_NewWithURL_s(
    FLSlice url,
  ) {
    return _CBLEndpoint_NewWithURL_s(
      url,
    );
  }

  late final _CBLEndpoint_NewWithURL_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLEndpoint_NewWithURL_s>>(
          'CBLEndpoint_NewWithURL_s');
  late final _dart_CBLEndpoint_NewWithURL_s _CBLEndpoint_NewWithURL_s =
      _CBLEndpoint_NewWithURL_s_ptr.asFunction<
          _dart_CBLEndpoint_NewWithURL_s>();

  /// Frees a CBLEndpoint object.
  void CBLEndpoint_Free(
    ffi.Pointer<CBLEndpoint> arg0,
  ) {
    return _CBLEndpoint_Free(
      arg0,
    );
  }

  late final _CBLEndpoint_Free_ptr =
      _lookup<ffi.NativeFunction<_c_CBLEndpoint_Free>>('CBLEndpoint_Free');
  late final _dart_CBLEndpoint_Free _CBLEndpoint_Free =
      _CBLEndpoint_Free_ptr.asFunction<_dart_CBLEndpoint_Free>();

  /// Creates an authenticator for HTTP Basic (username/password) auth.
  ffi.Pointer<CBLAuthenticator> CBLAuth_NewBasic(
    ffi.Pointer<ffi.Int8> username,
    ffi.Pointer<ffi.Int8> password,
  ) {
    return _CBLAuth_NewBasic(
      username,
      password,
    );
  }

  late final _CBLAuth_NewBasic_ptr =
      _lookup<ffi.NativeFunction<_c_CBLAuth_NewBasic>>('CBLAuth_NewBasic');
  late final _dart_CBLAuth_NewBasic _CBLAuth_NewBasic =
      _CBLAuth_NewBasic_ptr.asFunction<_dart_CBLAuth_NewBasic>();

  ffi.Pointer<CBLAuthenticator> CBLAuth_NewBasic_s(
    FLSlice username,
    FLSlice password,
  ) {
    return _CBLAuth_NewBasic_s(
      username,
      password,
    );
  }

  late final _CBLAuth_NewBasic_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLAuth_NewBasic_s>>('CBLAuth_NewBasic_s');
  late final _dart_CBLAuth_NewBasic_s _CBLAuth_NewBasic_s =
      _CBLAuth_NewBasic_s_ptr.asFunction<_dart_CBLAuth_NewBasic_s>();

  /// Creates an authenticator using a Couchbase Sync Gateway login session identifier,
  /// and optionally a cookie name (pass NULL for the default.)
  ffi.Pointer<CBLAuthenticator> CBLAuth_NewSession(
    ffi.Pointer<ffi.Int8> sessionID,
    ffi.Pointer<ffi.Int8> cookieName,
  ) {
    return _CBLAuth_NewSession(
      sessionID,
      cookieName,
    );
  }

  late final _CBLAuth_NewSession_ptr =
      _lookup<ffi.NativeFunction<_c_CBLAuth_NewSession>>('CBLAuth_NewSession');
  late final _dart_CBLAuth_NewSession _CBLAuth_NewSession =
      _CBLAuth_NewSession_ptr.asFunction<_dart_CBLAuth_NewSession>();

  ffi.Pointer<CBLAuthenticator> CBLAuth_NewSession_s(
    FLSlice sessionID,
    FLSlice cookieName,
  ) {
    return _CBLAuth_NewSession_s(
      sessionID,
      cookieName,
    );
  }

  late final _CBLAuth_NewSession_s_ptr =
      _lookup<ffi.NativeFunction<_c_CBLAuth_NewSession_s>>(
          'CBLAuth_NewSession_s');
  late final _dart_CBLAuth_NewSession_s _CBLAuth_NewSession_s =
      _CBLAuth_NewSession_s_ptr.asFunction<_dart_CBLAuth_NewSession_s>();

  /// Frees a CBLAuthenticator object.
  void CBLAuth_Free(
    ffi.Pointer<CBLAuthenticator> arg0,
  ) {
    return _CBLAuth_Free(
      arg0,
    );
  }

  late final _CBLAuth_Free_ptr =
      _lookup<ffi.NativeFunction<_c_CBLAuth_Free>>('CBLAuth_Free');
  late final _dart_CBLAuth_Free _CBLAuth_Free =
      _CBLAuth_Free_ptr.asFunction<_dart_CBLAuth_Free>();

  /// Default conflict resolver. This always returns `localDocument`.
  late final ffi.Pointer<ffi.Pointer<ffi.NativeFunction<CBLConflictResolver>>>
      _CBLDefaultConflictResolver =
      _lookup<ffi.Pointer<ffi.NativeFunction<CBLConflictResolver>>>(
          'CBLDefaultConflictResolver');

  ffi.Pointer<ffi.NativeFunction<CBLConflictResolver>>
      get CBLDefaultConflictResolver => _CBLDefaultConflictResolver.value;

  set CBLDefaultConflictResolver(
          ffi.Pointer<ffi.NativeFunction<CBLConflictResolver>> value) =>
      _CBLDefaultConflictResolver.value = value;

  /// Creates a replicator with the given configuration.
  ffi.Pointer<CBLReplicator> CBLReplicator_New(
    ffi.Pointer<CBLReplicatorConfiguration> arg0,
    ffi.Pointer<CBLError> arg1,
  ) {
    return _CBLReplicator_New(
      arg0,
      arg1,
    );
  }

  late final _CBLReplicator_New_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_New>>('CBLReplicator_New');
  late final _dart_CBLReplicator_New _CBLReplicator_New =
      _CBLReplicator_New_ptr.asFunction<_dart_CBLReplicator_New>();

  /// Returns the configuration of an existing replicator.
  ffi.Pointer<CBLReplicatorConfiguration> CBLReplicator_Config(
    ffi.Pointer<CBLReplicator> arg0,
  ) {
    return _CBLReplicator_Config(
      arg0,
    );
  }

  late final _CBLReplicator_Config_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_Config>>(
          'CBLReplicator_Config');
  late final _dart_CBLReplicator_Config _CBLReplicator_Config =
      _CBLReplicator_Config_ptr.asFunction<_dart_CBLReplicator_Config>();

  /// Instructs the replicator to ignore existing checkpoints the next time it runs.
  /// This will cause it to scan through all the documents on the remote database, which takes
  /// a lot longer, but it can resolve problems with missing documents if the client and
  /// server have gotten out of sync somehow.
  void CBLReplicator_ResetCheckpoint(
    ffi.Pointer<CBLReplicator> arg0,
  ) {
    return _CBLReplicator_ResetCheckpoint(
      arg0,
    );
  }

  late final _CBLReplicator_ResetCheckpoint_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_ResetCheckpoint>>(
          'CBLReplicator_ResetCheckpoint');
  late final _dart_CBLReplicator_ResetCheckpoint
      _CBLReplicator_ResetCheckpoint = _CBLReplicator_ResetCheckpoint_ptr
          .asFunction<_dart_CBLReplicator_ResetCheckpoint>();

  /// Starts a replicator, asynchronously. Does nothing if it's already started.
  void CBLReplicator_Start(
    ffi.Pointer<CBLReplicator> arg0,
  ) {
    return _CBLReplicator_Start(
      arg0,
    );
  }

  late final _CBLReplicator_Start_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_Start>>(
          'CBLReplicator_Start');
  late final _dart_CBLReplicator_Start _CBLReplicator_Start =
      _CBLReplicator_Start_ptr.asFunction<_dart_CBLReplicator_Start>();

  /// Stops a running replicator, asynchronously. Does nothing if it's not already started.
  /// The replicator will call your \ref CBLReplicatorChangeListener with an activity level of
  /// \ref kCBLReplicatorStopped after it stops. Until then, consider it still active.
  void CBLReplicator_Stop(
    ffi.Pointer<CBLReplicator> arg0,
  ) {
    return _CBLReplicator_Stop(
      arg0,
    );
  }

  late final _CBLReplicator_Stop_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_Stop>>('CBLReplicator_Stop');
  late final _dart_CBLReplicator_Stop _CBLReplicator_Stop =
      _CBLReplicator_Stop_ptr.asFunction<_dart_CBLReplicator_Stop>();

  /// Informs the replicator whether it's considered possible to reach the remote host with
  /// the current network configuration. The default value is true. This only affects the
  /// replicator's behavior while it's in the Offline state:
  /// Setting it to false will cancel any pending retry and prevent future automatic retries.
  /// Setting it back to true will initiate an immediate retry.
  void CBLReplicator_SetHostReachable(
    ffi.Pointer<CBLReplicator> arg0,
    bool reachable,
  ) {
    return _CBLReplicator_SetHostReachable(
      arg0,
      reachable ? 1 : 0,
    );
  }

  late final _CBLReplicator_SetHostReachable_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_SetHostReachable>>(
          'CBLReplicator_SetHostReachable');
  late final _dart_CBLReplicator_SetHostReachable
      _CBLReplicator_SetHostReachable = _CBLReplicator_SetHostReachable_ptr
          .asFunction<_dart_CBLReplicator_SetHostReachable>();

  /// Puts the replicator in or out of "suspended" state. The default is false.
  /// Setting suspended=true causes the replicator to disconnect and enter Offline state;
  /// it will not attempt to reconnect while it's suspended.
  /// Setting suspended=false causes the replicator to attempt to reconnect, _if_ it was
  /// connected when suspended, and is still in Offline state.
  void CBLReplicator_SetSuspended(
    ffi.Pointer<CBLReplicator> repl,
    bool suspended,
  ) {
    return _CBLReplicator_SetSuspended(
      repl,
      suspended ? 1 : 0,
    );
  }

  late final _CBLReplicator_SetSuspended_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_SetSuspended>>(
          'CBLReplicator_SetSuspended');
  late final _dart_CBLReplicator_SetSuspended _CBLReplicator_SetSuspended =
      _CBLReplicator_SetSuspended_ptr.asFunction<
          _dart_CBLReplicator_SetSuspended>();

  /// Returns the replicator's current status.
  CBLReplicatorStatus CBLReplicator_Status(
    ffi.Pointer<CBLReplicator> arg0,
  ) {
    return _CBLReplicator_Status(
      arg0,
    );
  }

  late final _CBLReplicator_Status_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_Status>>(
          'CBLReplicator_Status');
  late final _dart_CBLReplicator_Status _CBLReplicator_Status =
      _CBLReplicator_Status_ptr.asFunction<_dart_CBLReplicator_Status>();

  /// Indicates which documents have local changes that have not yet been pushed to the server
  /// by this replicator. This is of course a snapshot, that will go out of date as the replicator
  /// makes progress and/or documents are saved locally.
  ///
  /// The result is, effectively, a set of document IDs: a dictionary whose keys are the IDs and
  /// values are `true`.
  /// If there are no pending documents, the dictionary is empty.
  /// On error, NULL is returned.
  ///
  /// \note  This function can be called on a stopped or un-started replicator.
  /// \note  Documents that would never be pushed by this replicator, due to its configuration's
  /// `pushFilter` or `docIDs`, are ignored.
  /// \warning  You are responsible for releasing the returned array via \ref FLValue_Release.
  ffi.Pointer<FLDict> CBLReplicator_PendingDocumentIDs(
    ffi.Pointer<CBLReplicator> arg0,
    ffi.Pointer<CBLError> arg1,
  ) {
    return _CBLReplicator_PendingDocumentIDs(
      arg0,
      arg1,
    );
  }

  late final _CBLReplicator_PendingDocumentIDs_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_PendingDocumentIDs>>(
          'CBLReplicator_PendingDocumentIDs');
  late final _dart_CBLReplicator_PendingDocumentIDs
      _CBLReplicator_PendingDocumentIDs = _CBLReplicator_PendingDocumentIDs_ptr
          .asFunction<_dart_CBLReplicator_PendingDocumentIDs>();

  /// Indicates whether the document with the given ID has local changes that have not yet been
  /// pushed to the server by this replicator.
  ///
  /// This is equivalent to, but faster than, calling \ref CBLReplicator_PendingDocumentIDs and
  /// checking whether the result contains \p docID. See that function's documentation for details.
  ///
  /// \note  A `false` result means the document is not pending, _or_ there was an error.
  /// To tell the difference, compare the error code to zero.
  bool CBLReplicator_IsDocumentPending(
    ffi.Pointer<CBLReplicator> repl,
    FLSlice docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLReplicator_IsDocumentPending(
          repl,
          docID,
          outError,
        ) !=
        0;
  }

  late final _CBLReplicator_IsDocumentPending_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_IsDocumentPending>>(
          'CBLReplicator_IsDocumentPending');
  late final _dart_CBLReplicator_IsDocumentPending
      _CBLReplicator_IsDocumentPending = _CBLReplicator_IsDocumentPending_ptr
          .asFunction<_dart_CBLReplicator_IsDocumentPending>();

  /// Adds a listener that will be called when the replicator's status changes.
  ffi.Pointer<CBLListenerToken> CBLReplicator_AddChangeListener(
    ffi.Pointer<CBLReplicator> arg0,
    ffi.Pointer<ffi.NativeFunction<CBLReplicatorChangeListener>> arg1,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLReplicator_AddChangeListener(
      arg0,
      arg1,
      context,
    );
  }

  late final _CBLReplicator_AddChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_AddChangeListener>>(
          'CBLReplicator_AddChangeListener');
  late final _dart_CBLReplicator_AddChangeListener
      _CBLReplicator_AddChangeListener = _CBLReplicator_AddChangeListener_ptr
          .asFunction<_dart_CBLReplicator_AddChangeListener>();

  /// Adds a listener that will be called when documents are replicated.
  ffi.Pointer<CBLListenerToken> CBLReplicator_AddDocumentListener(
    ffi.Pointer<CBLReplicator> arg0,
    ffi.Pointer<ffi.NativeFunction<CBLReplicatedDocumentListener>> arg1,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLReplicator_AddDocumentListener(
      arg0,
      arg1,
      context,
    );
  }

  late final _CBLReplicator_AddDocumentListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_AddDocumentListener>>(
          'CBLReplicator_AddDocumentListener');
  late final _dart_CBLReplicator_AddDocumentListener
      _CBLReplicator_AddDocumentListener =
      _CBLReplicator_AddDocumentListener_ptr.asFunction<
          _dart_CBLReplicator_AddDocumentListener>();

  int CBLDart_PostCObject(
    ffi.Pointer<ffi.NativeFunction<Dart_PostCObjectType>> function_pointer,
  ) {
    return _CBLDart_PostCObject(
      function_pointer,
    );
  }

  late final _CBLDart_PostCObject_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_PostCObject>>(
          'CBLDart_PostCObject');
  late final _dart_CBLDart_PostCObject _CBLDart_PostCObject =
      _CBLDart_PostCObject_ptr.asFunction<_dart_CBLDart_PostCObject>();

  int CBLDart_NewNativePort(
    int function_pointer,
  ) {
    return _CBLDart_NewNativePort(
      function_pointer,
    );
  }

  late final _CBLDart_NewNativePort_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_NewNativePort>>(
          'CBLDart_NewNativePort');
  late final _dart_CBLDart_NewNativePort _CBLDart_NewNativePort =
      _CBLDart_NewNativePort_ptr.asFunction<_dart_CBLDart_NewNativePort>();

  int CBLDart_CloseNativePort(
    ffi.Pointer<ffi.NativeFunction<Dart_CloseNativePortType>> function_pointer,
  ) {
    return _CBLDart_CloseNativePort(
      function_pointer,
    );
  }

  late final _CBLDart_CloseNativePort_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_CloseNativePort>>(
          'CBLDart_CloseNativePort');
  late final _dart_CBLDart_CloseNativePort _CBLDart_CloseNativePort =
      _CBLDart_CloseNativePort_ptr.asFunction<_dart_CBLDart_CloseNativePort>();

  int CBLDart_RegisterPorts(
    int database_listener_port,
    int document_listener_port,
    int query_listener_port,
    int replicator_status_port,
    int replicator_filter_port,
    int replicator_conflict_port,
    ffi.Pointer<ffi.NativeFunction<CBLDart_ReplicatorStatusCallback>>
        replicator_status_callback,
    ffi.Pointer<ffi.NativeFunction<CBLDart_ReplicatorFilterCallback>>
        replicator_filter_callback,
    ffi.Pointer<ffi.NativeFunction<CBLDart_ConflictResolverCallback>>
        replicator_conflict_callback,
  ) {
    return _CBLDart_RegisterPorts(
      database_listener_port,
      document_listener_port,
      query_listener_port,
      replicator_status_port,
      replicator_filter_port,
      replicator_conflict_port,
      replicator_status_callback,
      replicator_filter_callback,
      replicator_conflict_callback,
    );
  }

  late final _CBLDart_RegisterPorts_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_RegisterPorts>>(
          'CBLDart_RegisterPorts');
  late final _dart_CBLDart_RegisterPorts _CBLDart_RegisterPorts =
      _CBLDart_RegisterPorts_ptr.asFunction<_dart_CBLDart_RegisterPorts>();

  int CBLDart_ExecuteCallback(
    ffi.Pointer<ffi.Int32> work_ptr,
  ) {
    return _CBLDart_ExecuteCallback(
      work_ptr,
    );
  }

  late final _CBLDart_ExecuteCallback_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_ExecuteCallback>>(
          'CBLDart_ExecuteCallback');
  late final _dart_CBLDart_ExecuteCallback _CBLDart_ExecuteCallback =
      _CBLDart_ExecuteCallback_ptr.asFunction<_dart_CBLDart_ExecuteCallback>();

  int CBLDart_DatabaseChangeListener(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDatabase> db,
    int numDocs,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> docIDs,
  ) {
    return _CBLDart_DatabaseChangeListener(
      context,
      db,
      numDocs,
      docIDs,
    );
  }

  late final _CBLDart_DatabaseChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_DatabaseChangeListener>>(
          'CBLDart_DatabaseChangeListener');
  late final _dart_CBLDart_DatabaseChangeListener
      _CBLDart_DatabaseChangeListener = _CBLDart_DatabaseChangeListener_ptr
          .asFunction<_dart_CBLDart_DatabaseChangeListener>();

  int CBLDart_DocumentChangeListener(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<ffi.Int8> docID,
  ) {
    return _CBLDart_DocumentChangeListener(
      context,
      db,
      docID,
    );
  }

  late final _CBLDart_DocumentChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_DocumentChangeListener>>(
          'CBLDart_DocumentChangeListener');
  late final _dart_CBLDart_DocumentChangeListener
      _CBLDart_DocumentChangeListener = _CBLDart_DocumentChangeListener_ptr
          .asFunction<_dart_CBLDart_DocumentChangeListener>();

  int CBLDart_QueryChangeListener(
    ffi.Pointer<ffi.Void> queryId,
    ffi.Pointer<CBLQuery> query,
  ) {
    return _CBLDart_QueryChangeListener(
      queryId,
      query,
    );
  }

  late final _CBLDart_QueryChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_QueryChangeListener>>(
          'CBLDart_QueryChangeListener');
  late final _dart_CBLDart_QueryChangeListener _CBLDart_QueryChangeListener =
      _CBLDart_QueryChangeListener_ptr.asFunction<
          _dart_CBLDart_QueryChangeListener>();

  int CBLDart_ReplicatorChangeListener(
    ffi.Pointer<ffi.Void> id,
    ffi.Pointer<CBLReplicator> repl,
    ffi.Pointer<CBLReplicatorStatus> status,
  ) {
    return _CBLDart_ReplicatorChangeListener(
      id,
      repl,
      status,
    );
  }

  late final _CBLDart_ReplicatorChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_ReplicatorChangeListener>>(
          'CBLDart_ReplicatorChangeListener');
  late final _dart_CBLDart_ReplicatorChangeListener
      _CBLDart_ReplicatorChangeListener = _CBLDart_ReplicatorChangeListener_ptr
          .asFunction<_dart_CBLDart_ReplicatorChangeListener>();

  int CBLDart_PushReplicationFilter(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDocument> document,
    bool isDeleted,
  ) {
    return _CBLDart_PushReplicationFilter(
      context,
      document,
      isDeleted ? 1 : 0,
    );
  }

  late final _CBLDart_PushReplicationFilter_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_PushReplicationFilter>>(
          'CBLDart_PushReplicationFilter');
  late final _dart_CBLDart_PushReplicationFilter
      _CBLDart_PushReplicationFilter = _CBLDart_PushReplicationFilter_ptr
          .asFunction<_dart_CBLDart_PushReplicationFilter>();

  int CBLDart_PullReplicationFilter(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDocument> document,
    bool isDeleted,
  ) {
    return _CBLDart_PullReplicationFilter(
      context,
      document,
      isDeleted ? 1 : 0,
    );
  }

  late final _CBLDart_PullReplicationFilter_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_PullReplicationFilter>>(
          'CBLDart_PullReplicationFilter');
  late final _dart_CBLDart_PullReplicationFilter
      _CBLDart_PullReplicationFilter = _CBLDart_PullReplicationFilter_ptr
          .asFunction<_dart_CBLDart_PullReplicationFilter>();
}

/// A simple reference to a block of memory. Does not imply ownership.
/// (This is equivalent to the C++ class `slice`.)
class FLSlice extends ffi.Struct {
  external ffi.Pointer<ffi.Void> buf;

  @ffi.Uint64()
  external int size;
}

/// A block of memory returned from an API call. The caller takes ownership, and must call
/// FLSlice_Release (or FLSlice_Free) when done. The heap block may be shared with other users,
/// so it must not be modified.
/// (This is equivalent to the C++ class `alloc_slice`.)
class FLSliceResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> buf;

  @ffi.Uint64()
  external int size;
}

/// A struct holding information about an error. It's declared on the stack by a caller, and
/// its address is passed to an API function. If the function's return value indicates that
/// there was an error (usually by returning NULL or false), then the CBLError will have been
/// filled in with the details.
class CBLError extends ffi.Struct {
  /// < Domain of errors; a namespace for the `code`.
  @ffi.Uint32()
  external int domain;

  /// < Error code, specific to the domain. 0 always means no error.
  @ffi.Int32()
  external int code;

  @ffi.Int32()
  external int internal_info;
}

class CBLRefCounted extends ffi.Opaque {}

class CBLDatabase extends ffi.Opaque {}

class CBLDocument extends ffi.Opaque {}

class CBLBlob extends ffi.Opaque {}

class CBLQuery extends ffi.Opaque {}

class CBLResultSet extends ffi.Opaque {}

class CBLReplicator extends ffi.Opaque {}

class CBLListenerToken extends ffi.Opaque {}

/// Error codes returned from some API calls.
abstract class FLError {
  static const int kFLNoError = 0;
  static const int kFLMemoryError = 1;
  static const int kFLOutOfRange = 2;
  static const int kFLInvalidData = 3;
  static const int kFLEncodeError = 4;
  static const int kFLJSONError = 5;
  static const int kFLUnknownValue = 6;
  static const int kFLInternalError = 7;
  static const int kFLNotFound = 8;
  static const int kFLSharedKeysStateError = 9;
  static const int kFLPOSIXError = 10;
  static const int kFLUnsupported = 11;
}

/// Specifies whether not input data is trusted to be 100% valid Fleece.
abstract class FLTrust {
  /// Input data is not trusted to be valid, and will be fully validated by the API call.
  static const int kFLUntrusted = 0;

  /// Input data is trusted to be valid. The API will perform only minimal validation when
  /// reading it. This is faster than kFLUntrusted, but should only be used if
  /// the data was generated by a trusted encoder and has not been altered or corrupted. For
  /// example, this can be used to parse Fleece data previously stored by your code in local
  /// storage.
  /// If invalid data is read by this call, subsequent calls to Value accessor functions can
  /// crash or return bogus results (including data from arbitrary memory locations.)
  static const int kFLTrusted = 1;
}

class FLDoc extends ffi.Opaque {}

class FLSharedKeys extends ffi.Opaque {}

class FLValue extends ffi.Opaque {}

/// Types of Fleece values. Basically JSON, with the addition of Data (raw blob).
abstract class FLValueType {
  /// < Type of a NULL pointer, i.e. no such value, like JSON `undefined`. Also the type of a value created by FLEncoder_WriteUndefined().
  static const int kFLUndefined = -1;

  /// < Equivalent to a JSON 'null'
  static const int kFLNull = 0;

  /// < A `true` or `false` value
  static const int kFLBoolean = 1;

  /// < A numeric value, either integer or floating-point
  static const int kFLNumber = 2;

  /// < A string
  static const int kFLString = 3;

  /// < Binary data (no JSON equivalent)
  static const int kFLData = 4;

  /// < An array of values
  static const int kFLArray = 5;

  /// < A mapping of strings to values
  static const int kFLDict = 6;
}

class FLArray extends ffi.Opaque {}

class FLDict extends ffi.Opaque {}

class FLSlot extends ffi.Opaque {}

/// Opaque array iterator. Declare one on the stack and pass its address to
/// `FLArrayIteratorBegin`.
class FLArrayIterator extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _private1;

  @ffi.Uint32()
  external int _private2;

  @ffi.Uint8()
  external int _private3;

  external ffi.Pointer<ffi.Void> _private4;
}

/// \name Mutable Arrays
/// @{
abstract class FLCopyFlags {
  static const int kFLDefaultCopy = 0;
  static const int kFLDeepCopy = 1;
  static const int kFLCopyImmutables = 2;
  static const int kFLDeepCopyImmutables = 3;
}

/// Opaque dictionary iterator. Declare one on the stack, and pass its address to
/// FLDictIterator_Begin.
class FLDictIterator extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _private1;

  @ffi.Uint32()
  external int _private2;

  @ffi.Uint8()
  external int _private3;

  external ffi.Pointer<ffi.Void> _unique__private4_item_0;
  external ffi.Pointer<ffi.Void> _unique__private4_item_1;
  external ffi.Pointer<ffi.Void> _unique__private4_item_2;
  external ffi.Pointer<ffi.Void> _unique__private4_item_3;

  /// Helper for array `_private4`.
  ArrayHelper_FLDictIterator__private4_level0 get _private4 =>
      ArrayHelper_FLDictIterator__private4_level0(this, [4], 0, 0);
  @ffi.Int32()
  external int _private5;
}

/// Helper for array `_private4` in struct `FLDictIterator`.
class ArrayHelper_FLDictIterator__private4_level0 {
  final FLDictIterator _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_FLDictIterator__private4_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..$length exclusive.');
    }
  }

  ffi.Pointer<ffi.Void> operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique__private4_item_0;
      case 1:
        return _struct._unique__private4_item_1;
      case 2:
        return _struct._unique__private4_item_2;
      case 3:
        return _struct._unique__private4_item_3;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, ffi.Pointer<ffi.Void> value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique__private4_item_0 = value;
        break;
      case 1:
        _struct._unique__private4_item_1 = value;
        break;
      case 2:
        _struct._unique__private4_item_2 = value;
        break;
      case 3:
        _struct._unique__private4_item_3 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Opaque key for a dictionary. You are responsible for creating space for these; they can
/// go on the stack, on the heap, inside other objects, anywhere.
/// Be aware that the lookup operations that use these will write into the struct to store
/// "hints" that speed up future searches.
class FLDictKey extends ffi.Struct {
  external FLSlice _private1;

  external ffi.Pointer<ffi.Void> _private2;

  @ffi.Uint32()
  external int _private3;

  @ffi.Uint32()
  external int private4;

  @ffi.Uint8()
  external int private5;
}

class FLDeepIterator extends ffi.Opaque {}

class FLPathComponent extends ffi.Struct {
  /// < Dict key, or kFLSliceNull if none
  external FLSlice key;

  /// < Array index, only if there's no key
  @ffi.Uint32()
  external int index;
}

class FLKeyPath extends ffi.Opaque {}

/// Output formats a FLEncoder can generate.
abstract class FLEncoderFormat {
  /// < Fleece encoding
  static const int kFLEncodeFleece = 0;

  /// < JSON encoding
  static const int kFLEncodeJSON = 1;

  /// < [JSON5](http://json5.org), an extension of JSON with a more readable syntax
  static const int kFLEncodeJSON5 = 2;
}

class FLEncoder extends ffi.Opaque {}

class FILE extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _Placeholder;
}

class CBLBlobReadStream extends ffi.Opaque {}

class CBLBlobWriteStream extends ffi.Opaque {}

/// Encryption key specified in a \ref CBLDatabaseConfiguration.
class CBLEncryptionKey extends ffi.Struct {
  /// < Encryption algorithm
  @ffi.Uint32()
  external int algorithm;

  @ffi.Uint8()
  external int _unique_bytes_item_0;
  @ffi.Uint8()
  external int _unique_bytes_item_1;
  @ffi.Uint8()
  external int _unique_bytes_item_2;
  @ffi.Uint8()
  external int _unique_bytes_item_3;
  @ffi.Uint8()
  external int _unique_bytes_item_4;
  @ffi.Uint8()
  external int _unique_bytes_item_5;
  @ffi.Uint8()
  external int _unique_bytes_item_6;
  @ffi.Uint8()
  external int _unique_bytes_item_7;
  @ffi.Uint8()
  external int _unique_bytes_item_8;
  @ffi.Uint8()
  external int _unique_bytes_item_9;
  @ffi.Uint8()
  external int _unique_bytes_item_10;
  @ffi.Uint8()
  external int _unique_bytes_item_11;
  @ffi.Uint8()
  external int _unique_bytes_item_12;
  @ffi.Uint8()
  external int _unique_bytes_item_13;
  @ffi.Uint8()
  external int _unique_bytes_item_14;
  @ffi.Uint8()
  external int _unique_bytes_item_15;
  @ffi.Uint8()
  external int _unique_bytes_item_16;
  @ffi.Uint8()
  external int _unique_bytes_item_17;
  @ffi.Uint8()
  external int _unique_bytes_item_18;
  @ffi.Uint8()
  external int _unique_bytes_item_19;
  @ffi.Uint8()
  external int _unique_bytes_item_20;
  @ffi.Uint8()
  external int _unique_bytes_item_21;
  @ffi.Uint8()
  external int _unique_bytes_item_22;
  @ffi.Uint8()
  external int _unique_bytes_item_23;
  @ffi.Uint8()
  external int _unique_bytes_item_24;
  @ffi.Uint8()
  external int _unique_bytes_item_25;
  @ffi.Uint8()
  external int _unique_bytes_item_26;
  @ffi.Uint8()
  external int _unique_bytes_item_27;
  @ffi.Uint8()
  external int _unique_bytes_item_28;
  @ffi.Uint8()
  external int _unique_bytes_item_29;
  @ffi.Uint8()
  external int _unique_bytes_item_30;
  @ffi.Uint8()
  external int _unique_bytes_item_31;

  /// Helper for array `bytes`.
  ArrayHelper_CBLEncryptionKey_bytes_level0 get bytes =>
      ArrayHelper_CBLEncryptionKey_bytes_level0(this, [32], 0, 0);
}

/// Helper for array `bytes` in struct `CBLEncryptionKey`.
class ArrayHelper_CBLEncryptionKey_bytes_level0 {
  final CBLEncryptionKey _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_CBLEncryptionKey_bytes_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..$length exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_bytes_item_0;
      case 1:
        return _struct._unique_bytes_item_1;
      case 2:
        return _struct._unique_bytes_item_2;
      case 3:
        return _struct._unique_bytes_item_3;
      case 4:
        return _struct._unique_bytes_item_4;
      case 5:
        return _struct._unique_bytes_item_5;
      case 6:
        return _struct._unique_bytes_item_6;
      case 7:
        return _struct._unique_bytes_item_7;
      case 8:
        return _struct._unique_bytes_item_8;
      case 9:
        return _struct._unique_bytes_item_9;
      case 10:
        return _struct._unique_bytes_item_10;
      case 11:
        return _struct._unique_bytes_item_11;
      case 12:
        return _struct._unique_bytes_item_12;
      case 13:
        return _struct._unique_bytes_item_13;
      case 14:
        return _struct._unique_bytes_item_14;
      case 15:
        return _struct._unique_bytes_item_15;
      case 16:
        return _struct._unique_bytes_item_16;
      case 17:
        return _struct._unique_bytes_item_17;
      case 18:
        return _struct._unique_bytes_item_18;
      case 19:
        return _struct._unique_bytes_item_19;
      case 20:
        return _struct._unique_bytes_item_20;
      case 21:
        return _struct._unique_bytes_item_21;
      case 22:
        return _struct._unique_bytes_item_22;
      case 23:
        return _struct._unique_bytes_item_23;
      case 24:
        return _struct._unique_bytes_item_24;
      case 25:
        return _struct._unique_bytes_item_25;
      case 26:
        return _struct._unique_bytes_item_26;
      case 27:
        return _struct._unique_bytes_item_27;
      case 28:
        return _struct._unique_bytes_item_28;
      case 29:
        return _struct._unique_bytes_item_29;
      case 30:
        return _struct._unique_bytes_item_30;
      case 31:
        return _struct._unique_bytes_item_31;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_bytes_item_0 = value;
        break;
      case 1:
        _struct._unique_bytes_item_1 = value;
        break;
      case 2:
        _struct._unique_bytes_item_2 = value;
        break;
      case 3:
        _struct._unique_bytes_item_3 = value;
        break;
      case 4:
        _struct._unique_bytes_item_4 = value;
        break;
      case 5:
        _struct._unique_bytes_item_5 = value;
        break;
      case 6:
        _struct._unique_bytes_item_6 = value;
        break;
      case 7:
        _struct._unique_bytes_item_7 = value;
        break;
      case 8:
        _struct._unique_bytes_item_8 = value;
        break;
      case 9:
        _struct._unique_bytes_item_9 = value;
        break;
      case 10:
        _struct._unique_bytes_item_10 = value;
        break;
      case 11:
        _struct._unique_bytes_item_11 = value;
        break;
      case 12:
        _struct._unique_bytes_item_12 = value;
        break;
      case 13:
        _struct._unique_bytes_item_13 = value;
        break;
      case 14:
        _struct._unique_bytes_item_14 = value;
        break;
      case 15:
        _struct._unique_bytes_item_15 = value;
        break;
      case 16:
        _struct._unique_bytes_item_16 = value;
        break;
      case 17:
        _struct._unique_bytes_item_17 = value;
        break;
      case 18:
        _struct._unique_bytes_item_18 = value;
        break;
      case 19:
        _struct._unique_bytes_item_19 = value;
        break;
      case 20:
        _struct._unique_bytes_item_20 = value;
        break;
      case 21:
        _struct._unique_bytes_item_21 = value;
        break;
      case 22:
        _struct._unique_bytes_item_22 = value;
        break;
      case 23:
        _struct._unique_bytes_item_23 = value;
        break;
      case 24:
        _struct._unique_bytes_item_24 = value;
        break;
      case 25:
        _struct._unique_bytes_item_25 = value;
        break;
      case 26:
        _struct._unique_bytes_item_26 = value;
        break;
      case 27:
        _struct._unique_bytes_item_27 = value;
        break;
      case 28:
        _struct._unique_bytes_item_28 = value;
        break;
      case 29:
        _struct._unique_bytes_item_29 = value;
        break;
      case 30:
        _struct._unique_bytes_item_30 = value;
        break;
      case 31:
        _struct._unique_bytes_item_31 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Database configuration options.
class CBLDatabaseConfiguration extends ffi.Struct {
  /// < The parent directory of the database
  external ffi.Pointer<ffi.Int8> directory;

  /// < Options for opening the database
  @ffi.Uint32()
  external int flags;

  /// < The database's encryption key (if any)
  external ffi.Pointer<CBLEncryptionKey> encryptionKey;
}

class CBLDatabaseConfiguration_s extends ffi.Struct {
  /// < The parent directory of the database
  external FLSlice directory;

  /// < Options for opening the database
  @ffi.Uint32()
  external int flags;

  /// < The database's encryption key (if any)
  external ffi.Pointer<CBLEncryptionKey> encryptionKey;
}

/// The properties for configuring logging to files.
/// @warning `usePlaintext` results in significantly larger log files and higher CPU usage that may slow
/// down your app; we recommend turning it off in production.
class CBLLogFileConfiguration extends ffi.Struct {
  /// < The directory where log files will be created.
  external ffi.Pointer<ffi.Int8> directory;

  /// < Max number of older logs to keep (i.e. total number will be one more.)
  @ffi.Uint32()
  external int maxRotateCount;

  /// < The size in bytes at which a file will be rotated out (best effort).
  @ffi.Uint64()
  external int maxSize;

  /// < Whether or not to log in plaintext (as opposed to binary)
  @ffi.Uint8()
  external int usePlaintext;
}

/// Parameters for creating a database index.
class CBLIndexSpec extends ffi.Struct {
  /// The type of index to create.
  @ffi.Uint32()
  external int type;

  /// A JSON array describing each column of the index.
  external ffi.Pointer<ffi.Int8> keyExpressionsJSON;

  /// In a full-text index, should diacritical marks (accents) be ignored?
  /// Defaults to false. Generally this should be left `false` for non-English text.
  @ffi.Uint8()
  external int ignoreAccents;

  /// In a full-text index, the dominant language. Setting this enables word stemming, i.e.
  /// matching different cases of the same word ("big" and "bigger", for instance) and ignoring
  /// common "stop-words" ("the", "a", "of", etc.)
  ///
  /// Can be an ISO-639 language code or a lowercase (English) language name; supported
  /// languages are: da/danish, nl/dutch, en/english, fi/finnish, fr/french, de/german,
  /// hu/hungarian, it/italian, no/norwegian, pt/portuguese, ro/romanian, ru/russian,
  /// es/spanish, sv/swedish, tr/turkish.
  ///
  /// If left null,  or set to an unrecognized language, no language-specific behaviors
  /// such as stemming and stop-word removal occur.
  external ffi.Pointer<ffi.Int8> language;
}

class CBLIndexSpec_s extends ffi.Struct {
  @ffi.Uint32()
  external int type;

  external FLSlice keyExpressionsJSON;

  @ffi.Uint8()
  external int ignoreAccents;

  external FLSlice language;
}

class CBLEndpoint extends ffi.Opaque {}

class CBLAuthenticator extends ffi.Opaque {}

/// Proxy settings for the replicator.
class CBLProxySettings extends ffi.Struct {
  /// < Type of proxy
  @ffi.Uint8()
  external int type;

  /// < Proxy server hostname or IP address
  external ffi.Pointer<ffi.Int8> hostname;

  /// < Proxy server port
  @ffi.Uint16()
  external int port;

  /// < Username for proxy auth (optional)
  external ffi.Pointer<ffi.Int8> username;

  /// < Password for proxy auth
  external ffi.Pointer<ffi.Int8> password;
}

/// The configuration of a replicator.
class CBLReplicatorConfiguration extends ffi.Struct {
  /// < The database to replicate
  external ffi.Pointer<CBLDatabase> database;

  /// < The address of the other database to replicate with
  external ffi.Pointer<CBLEndpoint> endpoint;

  /// < Push, pull or both
  @ffi.Uint8()
  external int replicatorType;

  /// < Continuous replication?
  @ffi.Uint8()
  external int continuous;

  /// < Authentication credentials, if needed
  external ffi.Pointer<CBLAuthenticator> authenticator;

  /// < HTTP client proxy settings
  external ffi.Pointer<CBLProxySettings> proxy;

  /// < Extra HTTP headers to add to the WebSocket request
  external ffi.Pointer<FLDict> headers;

  /// < An X.509 cert to "pin" TLS connections to (PEM or DER)
  external FLSlice pinnedServerCertificate;

  /// < Set of anchor certs (PEM format)
  external FLSlice trustedRootCertificates;

  /// < Optional set of channels to pull from
  external ffi.Pointer<FLArray> channels;

  /// < Optional set of document IDs to replicate
  external ffi.Pointer<FLArray> documentIDs;

  /// < Optional callback to filter which docs are pushed
  external ffi.Pointer<ffi.NativeFunction<CBLReplicationFilter>> pushFilter;

  /// < Optional callback to validate incoming docs
  external ffi.Pointer<ffi.NativeFunction<CBLReplicationFilter>> pullFilter;

  /// < Optional conflict-resolver callback
  external ffi.Pointer<ffi.NativeFunction<CBLConflictResolver>>
      conflictResolver;

  /// < Arbitrary value that will be passed to callbacks
  external ffi.Pointer<ffi.Void> context;
}

/// A fractional progress value, ranging from 0.0 to 1.0 as replication progresses.
/// The value is very approximate and may bounce around during replication; making it more
/// accurate would require slowing down the replicator and incurring more load on the server.
/// It's fine to use in a progress bar, though.
class CBLReplicatorProgress extends ffi.Struct {
  @ffi.Float()
  external double fractionComplete;

  /// < Number of documents transferred so far
  @ffi.Uint64()
  external int documentCount;
}

/// A replicator's current status.
class CBLReplicatorStatus extends ffi.Struct {
  /// < Current state
  @ffi.Uint8()
  external int activity;

  /// < Approximate fraction complete
  external CBLReplicatorProgress progress;

  /// < Error, if any
  external CBLError error;
}

/// Information about a document that's been pushed or pulled.
class CBLReplicatedDocument extends ffi.Struct {
  /// < The document ID
  external ffi.Pointer<ffi.Int8> ID;

  /// < Indicates whether the document was deleted or removed
  @ffi.Uint32()
  external int flags;

  /// < If the code is nonzero, the document failed to replicate.
  external CBLError error;
}

const int CBLDomain = 1;

const int CBLPOSIXDomain = 2;

const int CBLSQLiteDomain = 3;

const int CBLFleeceDomain = 4;

const int CBLNetworkDomain = 5;

const int CBLWebSocketDomain = 6;

const int CBLMaxErrorDomainPlus1 = 7;

const int CBLErrorAssertionFailed = 1;

const int CBLErrorUnimplemented = 2;

const int CBLErrorUnsupportedEncryption = 3;

const int CBLErrorBadRevisionID = 4;

const int CBLErrorCorruptRevisionData = 5;

const int CBLErrorNotOpen = 6;

const int CBLErrorNotFound = 7;

const int CBLErrorConflict = 8;

const int CBLErrorInvalidParameter = 9;

const int CBLErrorUnexpectedError = 10;

const int CBLErrorCantOpenFile = 11;

const int CBLErrorIOError = 12;

const int CBLErrorMemoryError = 13;

const int CBLErrorNotWriteable = 14;

const int CBLErrorCorruptData = 15;

const int CBLErrorBusy = 16;

const int CBLErrorNotInTransaction = 17;

const int CBLErrorTransactionNotClosed = 18;

const int CBLErrorUnsupported = 19;

const int CBLErrorNotADatabaseFile = 20;

const int CBLErrorWrongFormat = 21;

const int CBLErrorCrypto = 22;

const int CBLErrorInvalidQuery = 23;

const int CBLErrorMissingIndex = 24;

const int CBLErrorInvalidQueryParam = 25;

const int CBLErrorRemoteError = 26;

const int CBLErrorDatabaseTooOld = 27;

const int CBLErrorDatabaseTooNew = 28;

const int CBLErrorBadDocID = 29;

const int CBLErrorCantUpgradeDatabase = 30;

const int CBLNumErrorCodesPlus1 = 31;

const int CBLNetErrDNSFailure = 1;

const int CBLNetErrUnknownHost = 2;

const int CBLNetErrTimeout = 3;

const int CBLNetErrInvalidURL = 4;

const int CBLNetErrTooManyRedirects = 5;

const int CBLNetErrTLSHandshakeFailed = 6;

const int CBLNetErrTLSCertExpired = 7;

const int CBLNetErrTLSCertUntrusted = 8;

const int CBLNetErrTLSClientCertRequired = 9;

const int CBLNetErrTLSClientCertRejected = 10;

const int CBLNetErrTLSCertUnknownRoot = 11;

const int CBLNetErrInvalidRedirect = 12;

const int CBLNetErrUnknown = 13;

const int CBLNetErrTLSCertRevoked = 14;

const int CBLNetErrTLSCertNameMismatch = 15;

const int kCBLDatabase_Create = 1;

const int kCBLDatabase_ReadOnly = 2;

const int kCBLDatabase_NoUpgrade = 4;

const int kCBLEncryptionNone = 0;

const int kCBLEncryptionKeySizeAES256 = 32;

const int kCBLConcurrencyControlLastWriteWins = 0;

const int kCBLConcurrencyControlFailOnConflict = 1;

const int kCBLLogDomainAll = 0;

const int kCBLLogDomainDatabase = 1;

const int kCBLLogDomainQuery = 2;

const int kCBLLogDomainReplicator = 3;

const int kCBLLogDomainNetwork = 4;

const int CBLLogDebug = 0;

const int CBLLogVerbose = 1;

const int CBLLogInfo = 2;

const int CBLLogWarning = 3;

const int CBLLogError = 4;

const int CBLLogNone = 5;

const int kCBLJSONLanguage = 0;

const int kCBLN1QLLanguage = 1;

const int kCBLValueIndex = 0;

const int kCBLFullTextIndex = 1;

const int kCBLReplicatorTypePushAndPull = 0;

const int kCBLReplicatorTypePush = 1;

const int kCBLReplicatorTypePull = 2;

const int kCBLProxyHTTP = 0;

const int kCBLProxyHTTPS = 1;

const int kCBLReplicatorStopped = 0;

const int kCBLReplicatorOffline = 1;

const int kCBLReplicatorConnecting = 2;

const int kCBLReplicatorIdle = 3;

const int kCBLReplicatorBusy = 4;

const int kCBLDocumentFlagsDeleted = 1;

const int kCBLDocumentFlagsAccessRemoved = 2;

const int kCBLReplicatorFilterTypePush = 0;

const int kCBLReplicatorFilterTypePull = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const int __bool_true_false_are_defined = 1;

const int false_1 = 0;

const int true_1 = 1;

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int _WCHAR_T_DEFINED = 1;

const int NULL = 0;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_NODISCARD = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -2147483648;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 2147483647;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 4294967295;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int WCHAR_MIN = 0;

const int WCHAR_MAX = 65535;

const int WINT_MIN = 0;

const int WINT_MAX = 65535;

const int _ARGMAX = 100;

const int _TRUNCATE = -1;

const int _CRT_INT_MAX = 2147483647;

const int _CRT_SIZE_MAX = -1;

const String __FILEW__ = 't';

const int _CRT_FUNCTIONS_REQUIRED = 1;

const int _CRT_HAS_CXX17 = 0;

const int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = 1;

const int _CRT_BUILD_DESKTOP_APP = 1;

const int _CRT_INTERNAL_NONSTDC_NAMES = 1;

const int __STDC_SECURE_LIB__ = 200411;

const int __GOT_SECURE_LIB__ = 200411;

const int __STDC_WANT_SECURE_LIB__ = 1;

const int _SECURECRT_FILL_BUFFER_PATTERN = 254;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;

const int _MAX_ITOSTR_BASE16_COUNT = 9;

const int _MAX_ITOSTR_BASE10_COUNT = 12;

const int _MAX_ITOSTR_BASE8_COUNT = 12;

const int _MAX_ITOSTR_BASE2_COUNT = 33;

const int _MAX_LTOSTR_BASE16_COUNT = 9;

const int _MAX_LTOSTR_BASE10_COUNT = 12;

const int _MAX_LTOSTR_BASE8_COUNT = 12;

const int _MAX_LTOSTR_BASE2_COUNT = 33;

const int _MAX_ULTOSTR_BASE16_COUNT = 9;

const int _MAX_ULTOSTR_BASE10_COUNT = 11;

const int _MAX_ULTOSTR_BASE8_COUNT = 12;

const int _MAX_ULTOSTR_BASE2_COUNT = 33;

const int _MAX_I64TOSTR_BASE16_COUNT = 17;

const int _MAX_I64TOSTR_BASE10_COUNT = 21;

const int _MAX_I64TOSTR_BASE8_COUNT = 23;

const int _MAX_I64TOSTR_BASE2_COUNT = 65;

const int _MAX_U64TOSTR_BASE16_COUNT = 17;

const int _MAX_U64TOSTR_BASE10_COUNT = 21;

const int _MAX_U64TOSTR_BASE8_COUNT = 23;

const int _MAX_U64TOSTR_BASE2_COUNT = 65;

const int CHAR_BIT = 8;

const int SCHAR_MIN = -128;

const int SCHAR_MAX = 127;

const int UCHAR_MAX = 255;

const int CHAR_MIN = -128;

const int CHAR_MAX = 127;

const int MB_LEN_MAX = 5;

const int SHRT_MIN = -32768;

const int SHRT_MAX = 32767;

const int USHRT_MAX = 65535;

const int INT_MIN = -2147483648;

const int INT_MAX = 2147483647;

const int UINT_MAX = 4294967295;

const int LONG_MIN = -2147483648;

const int LONG_MAX = 2147483647;

const int ULONG_MAX = 4294967295;

const int LLONG_MAX = 9223372036854775807;

const int LLONG_MIN = -9223372036854775808;

const int ULLONG_MAX = -1;

const int _I8_MIN = -128;

const int _I8_MAX = 127;

const int _UI8_MAX = 255;

const int _I16_MIN = -32768;

const int _I16_MAX = 32767;

const int _UI16_MAX = 65535;

const int _I32_MIN = -2147483648;

const int _I32_MAX = 2147483647;

const int _UI32_MAX = 4294967295;

const int _I64_MIN = -9223372036854775808;

const int _I64_MAX = 9223372036854775807;

const int _UI64_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int EXIT_SUCCESS = 0;

const int EXIT_FAILURE = 1;

const int _WRITE_ABORT_MSG = 1;

const int _CALL_REPORTFAULT = 2;

const int _OUT_TO_DEFAULT = 0;

const int _OUT_TO_STDERR = 1;

const int _OUT_TO_MSGBOX = 2;

const int _REPORT_ERRMODE = 3;

const int RAND_MAX = 32767;

const int _CVTBUFSIZE = 349;

const int _MAX_PATH = 260;

const int _MAX_DRIVE = 3;

const int _MAX_DIR = 256;

const int _MAX_FNAME = 256;

const int _MAX_EXT = 256;

const int _MAX_ENV = 32767;

const int EPERM = 1;

const int ENOENT = 2;

const int ESRCH = 3;

const int EINTR = 4;

const int EIO = 5;

const int ENXIO = 6;

const int E2BIG = 7;

const int ENOEXEC = 8;

const int EBADF = 9;

const int ECHILD = 10;

const int EAGAIN = 11;

const int ENOMEM = 12;

const int EACCES = 13;

const int EFAULT = 14;

const int EBUSY = 16;

const int EEXIST = 17;

const int EXDEV = 18;

const int ENODEV = 19;

const int ENOTDIR = 20;

const int EISDIR = 21;

const int ENFILE = 23;

const int EMFILE = 24;

const int ENOTTY = 25;

const int EFBIG = 27;

const int ENOSPC = 28;

const int ESPIPE = 29;

const int EROFS = 30;

const int EMLINK = 31;

const int EPIPE = 32;

const int EDOM = 33;

const int EDEADLK = 36;

const int ENAMETOOLONG = 38;

const int ENOLCK = 39;

const int ENOSYS = 40;

const int ENOTEMPTY = 41;

const int EINVAL = 22;

const int ERANGE = 34;

const int EILSEQ = 42;

const int STRUNCATE = 80;

const int EDEADLOCK = 36;

const int EADDRINUSE = 100;

const int EADDRNOTAVAIL = 101;

const int EAFNOSUPPORT = 102;

const int EALREADY = 103;

const int EBADMSG = 104;

const int ECANCELED = 105;

const int ECONNABORTED = 106;

const int ECONNREFUSED = 107;

const int ECONNRESET = 108;

const int EDESTADDRREQ = 109;

const int EHOSTUNREACH = 110;

const int EIDRM = 111;

const int EINPROGRESS = 112;

const int EISCONN = 113;

const int ELOOP = 114;

const int EMSGSIZE = 115;

const int ENETDOWN = 116;

const int ENETRESET = 117;

const int ENETUNREACH = 118;

const int ENOBUFS = 119;

const int ENODATA = 120;

const int ENOLINK = 121;

const int ENOMSG = 122;

const int ENOPROTOOPT = 123;

const int ENOSR = 124;

const int ENOSTR = 125;

const int ENOTCONN = 126;

const int ENOTRECOVERABLE = 127;

const int ENOTSOCK = 128;

const int ENOTSUP = 129;

const int EOPNOTSUPP = 130;

const int EOTHER = 131;

const int EOVERFLOW = 132;

const int EOWNERDEAD = 133;

const int EPROTO = 134;

const int EPROTONOSUPPORT = 135;

const int EPROTOTYPE = 136;

const int ETIME = 137;

const int ETIMEDOUT = 138;

const int ETXTBSY = 139;

const int EWOULDBLOCK = 140;

const int _NLSCMPERROR = 2147483647;

const String _CRT_INTERNAL_STDIO_SYMBOL_PREFIX = '';

const int _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION = 1;

const int _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR = 2;

const int _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS = 4;

const int _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY = 8;

const int _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS = 16;

const int _CRT_INTERNAL_SCANF_SECURECRT = 1;

const int _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS = 2;

const int _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY = 4;

const int WEOF = 65535;

const int BUFSIZ = 512;

const int _NFILE = 512;

const int _NSTREAM_ = 512;

const int _IOB_ENTRIES = 3;

const int EOF = -1;

const int _IOFBF = 0;

const int _IOLBF = 64;

const int _IONBF = 4;

const int L_tmpnam = 260;

const int L_tmpnam_s = 260;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const int SEEK_SET = 0;

const int FILENAME_MAX = 260;

const int FOPEN_MAX = 20;

const int _SYS_OPEN = 20;

const int TMP_MAX = 2147483647;

const int TMP_MAX_S = 2147483647;

const int _TMP_MAX_S = 2147483647;

const int SYS_OPEN = 20;

const int FLTimestampNone = -9223372036854775808;

typedef _c_FLSlice_Equal = ffi.Uint8 Function(
  FLSlice a,
  FLSlice b,
);

typedef _dart_FLSlice_Equal = int Function(
  FLSlice a,
  FLSlice b,
);

typedef _c_FLSlice_Compare = ffi.Int32 Function(
  FLSlice arg0,
  FLSlice arg1,
);

typedef _dart_FLSlice_Compare = int Function(
  FLSlice arg0,
  FLSlice arg1,
);

typedef _c_FLSliceResult_New = FLSliceResult Function(
  ffi.Uint64 arg0,
);

typedef _dart_FLSliceResult_New = FLSliceResult Function(
  int arg0,
);

typedef _c_FLSlice_Copy = FLSliceResult Function(
  FLSlice arg0,
);

typedef _dart_FLSlice_Copy = FLSliceResult Function(
  FLSlice arg0,
);

typedef _c_FLBuf_Retain = ffi.Void Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _dart_FLBuf_Retain = void Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _c_FLBuf_Release = ffi.Void Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _dart_FLBuf_Release = void Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _c_CBLError_Message = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLError> arg0,
);

typedef _dart_CBLError_Message = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLError> arg0,
);

typedef _c_CBLError_Message_s = FLSliceResult Function(
  ffi.Pointer<CBLError> arg0,
);

typedef _dart_CBLError_Message_s = FLSliceResult Function(
  ffi.Pointer<CBLError> arg0,
);

typedef _c_CBL_Now = ffi.Int64 Function();

typedef _dart_CBL_Now = int Function();

typedef _c_CBL_Retain = ffi.Pointer<CBLRefCounted> Function(
  ffi.Pointer<CBLRefCounted> arg0,
);

typedef _dart_CBL_Retain = ffi.Pointer<CBLRefCounted> Function(
  ffi.Pointer<CBLRefCounted> arg0,
);

typedef _c_CBL_Release = ffi.Void Function(
  ffi.Pointer<CBLRefCounted> arg0,
);

typedef _dart_CBL_Release = void Function(
  ffi.Pointer<CBLRefCounted> arg0,
);

typedef _c_CBL_InstanceCount = ffi.Uint32 Function();

typedef _dart_CBL_InstanceCount = int Function();

typedef _c_CBL_DumpInstances = ffi.Void Function();

typedef _dart_CBL_DumpInstances = void Function();

typedef _c_CBLListener_Remove = ffi.Void Function(
  ffi.Pointer<CBLListenerToken> arg0,
);

typedef _dart_CBLListener_Remove = void Function(
  ffi.Pointer<CBLListenerToken> arg0,
);

typedef _c_FLDoc_FromResultData = ffi.Pointer<FLDoc> Function(
  FLSliceResult data,
  ffi.Int32 arg1,
  ffi.Pointer<FLSharedKeys> arg2,
  FLSlice externData,
);

typedef _dart_FLDoc_FromResultData = ffi.Pointer<FLDoc> Function(
  FLSliceResult data,
  int arg1,
  ffi.Pointer<FLSharedKeys> arg2,
  FLSlice externData,
);

typedef _c_FLDoc_FromJSON = ffi.Pointer<FLDoc> Function(
  FLSlice json,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _dart_FLDoc_FromJSON = ffi.Pointer<FLDoc> Function(
  FLSlice json,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _c_FLDoc_Release = ffi.Void Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _dart_FLDoc_Release = void Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _c_FLDoc_Retain = ffi.Pointer<FLDoc> Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _dart_FLDoc_Retain = ffi.Pointer<FLDoc> Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _c_FLDoc_GetData = FLSlice Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _dart_FLDoc_GetData = FLSlice Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _c_FLDoc_GetAllocedData = FLSliceResult Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _dart_FLDoc_GetAllocedData = FLSliceResult Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _c_FLDoc_GetRoot = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _dart_FLDoc_GetRoot = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _c_FLDoc_GetSharedKeys = ffi.Pointer<FLSharedKeys> Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _dart_FLDoc_GetSharedKeys = ffi.Pointer<FLSharedKeys> Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _c_FLValue_FindDoc = ffi.Pointer<FLDoc> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_FindDoc = ffi.Pointer<FLDoc> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_FromData = ffi.Pointer<FLValue> Function(
  FLSlice data,
  ffi.Int32 arg1,
);

typedef _dart_FLValue_FromData = ffi.Pointer<FLValue> Function(
  FLSlice data,
  int arg1,
);

typedef _c_FLData_ConvertJSON = FLSliceResult Function(
  FLSlice json,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _dart_FLData_ConvertJSON = FLSliceResult Function(
  FLSlice json,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _c_FLData_Dump = FLSliceResult Function(
  FLSlice data,
);

typedef _dart_FLData_Dump = FLSliceResult Function(
  FLSlice data,
);

typedef _c_FLValue_ToJSON = FLSliceResult Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_ToJSON = FLSliceResult Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_ToJSON5 = FLSliceResult Function(
  ffi.Pointer<FLValue> v,
);

typedef _dart_FLValue_ToJSON5 = FLSliceResult Function(
  ffi.Pointer<FLValue> v,
);

typedef _c_FLValue_ToJSONX = FLSliceResult Function(
  ffi.Pointer<FLValue> v,
  ffi.Uint8 json5,
  ffi.Uint8 canonicalForm,
);

typedef _dart_FLValue_ToJSONX = FLSliceResult Function(
  ffi.Pointer<FLValue> v,
  int json5,
  int canonicalForm,
);

typedef _c_FLJSON5_ToJSON = FLSliceResult Function(
  FLSlice json5,
  ffi.Pointer<FLSliceResult> outErrorMessage,
  ffi.Pointer<ffi.Uint64> outErrorPos,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _dart_FLJSON5_ToJSON = FLSliceResult Function(
  FLSlice json5,
  ffi.Pointer<FLSliceResult> outErrorMessage,
  ffi.Pointer<ffi.Uint64> outErrorPos,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _c_FLDump = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLDump = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLDumpData = ffi.Pointer<ffi.Int8> Function(
  FLSlice data,
);

typedef _dart_FLDumpData = ffi.Pointer<ffi.Int8> Function(
  FLSlice data,
);

typedef _c_FLValue_GetType = ffi.Int32 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_GetType = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_IsInteger = ffi.Uint8 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_IsInteger = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_IsUnsigned = ffi.Uint8 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_IsUnsigned = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_IsDouble = ffi.Uint8 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_IsDouble = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsBool = ffi.Uint8 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsBool = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsInt = ffi.Int64 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsInt = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsUnsigned = ffi.Uint64 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsUnsigned = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsFloat = ffi.Float Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsFloat = double Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsDouble = ffi.Double Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsDouble = double Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsString = FLSlice Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsString = FLSlice Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsTimestamp = ffi.Int64 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsTimestamp = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsData = FLSlice Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsData = FLSlice Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_ToString = FLSliceResult Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_ToString = FLSliceResult Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_IsEqual = ffi.Uint8 Function(
  ffi.Pointer<FLValue> v1,
  ffi.Pointer<FLValue> v2,
);

typedef _dart_FLValue_IsEqual = int Function(
  ffi.Pointer<FLValue> v1,
  ffi.Pointer<FLValue> v2,
);

typedef _c_FLValue_Retain = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_Retain = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_Release = ffi.Void Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_Release = void Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLSlot_SetNull = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
);

typedef _dart_FLSlot_SetNull = void Function(
  ffi.Pointer<FLSlot> arg0,
);

typedef _c_FLSlot_SetBool = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  ffi.Uint8 arg1,
);

typedef _dart_FLSlot_SetBool = void Function(
  ffi.Pointer<FLSlot> arg0,
  int arg1,
);

typedef _c_FLSlot_SetInt = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  ffi.Int64 arg1,
);

typedef _dart_FLSlot_SetInt = void Function(
  ffi.Pointer<FLSlot> arg0,
  int arg1,
);

typedef _c_FLSlot_SetUInt = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  ffi.Uint64 arg1,
);

typedef _dart_FLSlot_SetUInt = void Function(
  ffi.Pointer<FLSlot> arg0,
  int arg1,
);

typedef _c_FLSlot_SetFloat = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  ffi.Float arg1,
);

typedef _dart_FLSlot_SetFloat = void Function(
  ffi.Pointer<FLSlot> arg0,
  double arg1,
);

typedef _c_FLSlot_SetDouble = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  ffi.Double arg1,
);

typedef _dart_FLSlot_SetDouble = void Function(
  ffi.Pointer<FLSlot> arg0,
  double arg1,
);

typedef _c_FLSlot_SetString = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  FLSlice arg1,
);

typedef _dart_FLSlot_SetString = void Function(
  ffi.Pointer<FLSlot> arg0,
  FLSlice arg1,
);

typedef _c_FLSlot_SetData = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  FLSlice arg1,
);

typedef _dart_FLSlot_SetData = void Function(
  ffi.Pointer<FLSlot> arg0,
  FLSlice arg1,
);

typedef _c_FLSlot_SetValue = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  ffi.Pointer<FLValue> arg1,
);

typedef _dart_FLSlot_SetValue = void Function(
  ffi.Pointer<FLSlot> arg0,
  ffi.Pointer<FLValue> arg1,
);

typedef _c_FLArray_Count = ffi.Uint32 Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _dart_FLArray_Count = int Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _c_FLArray_IsEmpty = ffi.Uint8 Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _dart_FLArray_IsEmpty = int Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _c_FLArray_AsMutable = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _dart_FLArray_AsMutable = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _c_FLArray_Get = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Uint32 index,
);

typedef _dart_FLArray_Get = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLArray> arg0,
  int index,
);

typedef _c_FLArrayIterator_Begin = ffi.Void Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Pointer<FLArrayIterator> arg1,
);

typedef _dart_FLArrayIterator_Begin = void Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Pointer<FLArrayIterator> arg1,
);

typedef _c_FLArrayIterator_GetValue = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLArrayIterator> arg0,
);

typedef _dart_FLArrayIterator_GetValue = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLArrayIterator> arg0,
);

typedef _c_FLArrayIterator_GetValueAt = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLArrayIterator> arg0,
  ffi.Uint32 offset,
);

typedef _dart_FLArrayIterator_GetValueAt = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLArrayIterator> arg0,
  int offset,
);

typedef _c_FLArrayIterator_GetCount = ffi.Uint32 Function(
  ffi.Pointer<FLArrayIterator> arg0,
);

typedef _dart_FLArrayIterator_GetCount = int Function(
  ffi.Pointer<FLArrayIterator> arg0,
);

typedef _c_FLArrayIterator_Next = ffi.Uint8 Function(
  ffi.Pointer<FLArrayIterator> arg0,
);

typedef _dart_FLArrayIterator_Next = int Function(
  ffi.Pointer<FLArrayIterator> arg0,
);

typedef _c_FLArray_MutableCopy = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Int32 arg1,
);

typedef _dart_FLArray_MutableCopy = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
  int arg1,
);

typedef _c_FLMutableArray_New = ffi.Pointer<FLArray> Function();

typedef _dart_FLMutableArray_New = ffi.Pointer<FLArray> Function();

typedef _c_FLMutableArray_GetSource = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _dart_FLMutableArray_GetSource = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _c_FLMutableArray_IsChanged = ffi.Uint8 Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _dart_FLMutableArray_IsChanged = int Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _c_FLMutableArray_Set = ffi.Pointer<FLSlot> Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Uint32 index,
);

typedef _dart_FLMutableArray_Set = ffi.Pointer<FLSlot> Function(
  ffi.Pointer<FLArray> arg0,
  int index,
);

typedef _c_FLMutableArray_Append = ffi.Pointer<FLSlot> Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _dart_FLMutableArray_Append = ffi.Pointer<FLSlot> Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _c_FLMutableArray_Insert = ffi.Void Function(
  ffi.Pointer<FLArray> array,
  ffi.Uint32 firstIndex,
  ffi.Uint32 count,
);

typedef _dart_FLMutableArray_Insert = void Function(
  ffi.Pointer<FLArray> array,
  int firstIndex,
  int count,
);

typedef _c_FLMutableArray_Remove = ffi.Void Function(
  ffi.Pointer<FLArray> array,
  ffi.Uint32 firstIndex,
  ffi.Uint32 count,
);

typedef _dart_FLMutableArray_Remove = void Function(
  ffi.Pointer<FLArray> array,
  int firstIndex,
  int count,
);

typedef _c_FLMutableArray_Resize = ffi.Void Function(
  ffi.Pointer<FLArray> array,
  ffi.Uint32 size,
);

typedef _dart_FLMutableArray_Resize = void Function(
  ffi.Pointer<FLArray> array,
  int size,
);

typedef _c_FLMutableArray_GetMutableArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Uint32 index,
);

typedef _dart_FLMutableArray_GetMutableArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
  int index,
);

typedef _c_FLMutableArray_GetMutableDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Uint32 index,
);

typedef _dart_FLMutableArray_GetMutableDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLArray> arg0,
  int index,
);

typedef _c_FLDict_Count = ffi.Uint32 Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _dart_FLDict_Count = int Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _c_FLDict_IsEmpty = ffi.Uint8 Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _dart_FLDict_IsEmpty = int Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _c_FLDict_AsMutable = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _dart_FLDict_AsMutable = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _c_FLDict_Get = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice keyString,
);

typedef _dart_FLDict_Get = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice keyString,
);

typedef _c_FLDictIterator_Begin = ffi.Void Function(
  ffi.Pointer<FLDict> arg0,
  ffi.Pointer<FLDictIterator> arg1,
);

typedef _dart_FLDictIterator_Begin = void Function(
  ffi.Pointer<FLDict> arg0,
  ffi.Pointer<FLDictIterator> arg1,
);

typedef _c_FLDictIterator_GetKey = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _dart_FLDictIterator_GetKey = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _c_FLDictIterator_GetKeyString = FLSlice Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _dart_FLDictIterator_GetKeyString = FLSlice Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _c_FLDictIterator_GetValue = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _dart_FLDictIterator_GetValue = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _c_FLDictIterator_GetCount = ffi.Uint32 Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _dart_FLDictIterator_GetCount = int Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _c_FLDictIterator_Next = ffi.Uint8 Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _dart_FLDictIterator_Next = int Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _c_FLDictIterator_End = ffi.Void Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _dart_FLDictIterator_End = void Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _c_FLDictKey_Init = FLDictKey Function(
  FLSlice string,
);

typedef _dart_FLDictKey_Init = FLDictKey Function(
  FLSlice string,
);

typedef _c_FLDictKey_GetString = FLSlice Function(
  ffi.Pointer<FLDictKey> arg0,
);

typedef _dart_FLDictKey_GetString = FLSlice Function(
  ffi.Pointer<FLDictKey> arg0,
);

typedef _c_FLDict_GetWithKey = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDict> arg0,
  ffi.Pointer<FLDictKey> arg1,
);

typedef _dart_FLDict_GetWithKey = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDict> arg0,
  ffi.Pointer<FLDictKey> arg1,
);

typedef _c_FLDict_MutableCopy = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> source,
  ffi.Int32 arg1,
);

typedef _dart_FLDict_MutableCopy = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> source,
  int arg1,
);

typedef _c_FLMutableDict_New = ffi.Pointer<FLDict> Function();

typedef _dart_FLMutableDict_New = ffi.Pointer<FLDict> Function();

typedef _c_FLMutableDict_GetSource = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _dart_FLMutableDict_GetSource = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _c_FLMutableDict_IsChanged = ffi.Uint8 Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _dart_FLMutableDict_IsChanged = int Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _c_FLMutableDict_Set = ffi.Pointer<FLSlot> Function(
  ffi.Pointer<FLDict> FL_NONNULL,
  FLSlice key,
);

typedef _dart_FLMutableDict_Set = ffi.Pointer<FLSlot> Function(
  ffi.Pointer<FLDict> FL_NONNULL,
  FLSlice key,
);

typedef _c_FLMutableDict_Remove = ffi.Void Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice key,
);

typedef _dart_FLMutableDict_Remove = void Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice key,
);

typedef _c_FLMutableDict_RemoveAll = ffi.Void Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _dart_FLMutableDict_RemoveAll = void Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _c_FLMutableDict_GetMutableArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice key,
);

typedef _dart_FLMutableDict_GetMutableArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice key,
);

typedef _c_FLMutableDict_GetMutableDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice key,
);

typedef _dart_FLMutableDict_GetMutableDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice key,
);

typedef _c_FLDeepIterator_New = ffi.Pointer<FLDeepIterator> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLDeepIterator_New = ffi.Pointer<FLDeepIterator> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLDeepIterator_Free = ffi.Void Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_Free = void Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_GetValue = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_GetValue = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_GetKey = FLSlice Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_GetKey = FLSlice Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_GetIndex = ffi.Uint32 Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_GetIndex = int Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_GetDepth = ffi.Uint64 Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_GetDepth = int Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_SkipChildren = ffi.Void Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_SkipChildren = void Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_Next = ffi.Uint8 Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_Next = int Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_GetPath = ffi.Void Function(
  ffi.Pointer<FLDeepIterator> arg0,
  ffi.Pointer<ffi.Pointer<FLPathComponent>> outPath,
  ffi.Pointer<ffi.Uint64> outDepth,
);

typedef _dart_FLDeepIterator_GetPath = void Function(
  ffi.Pointer<FLDeepIterator> arg0,
  ffi.Pointer<ffi.Pointer<FLPathComponent>> outPath,
  ffi.Pointer<ffi.Uint64> outDepth,
);

typedef _c_FLDeepIterator_GetPathString = FLSliceResult Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_GetPathString = FLSliceResult Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_GetJSONPointer = FLSliceResult Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_GetJSONPointer = FLSliceResult Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLKeyPath_New = ffi.Pointer<FLKeyPath> Function(
  FLSlice specifier,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_FLKeyPath_New = ffi.Pointer<FLKeyPath> Function(
  FLSlice specifier,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_FLKeyPath_Free = ffi.Void Function(
  ffi.Pointer<FLKeyPath> arg0,
);

typedef _dart_FLKeyPath_Free = void Function(
  ffi.Pointer<FLKeyPath> arg0,
);

typedef _c_FLKeyPath_Eval = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLKeyPath> arg0,
  ffi.Pointer<FLValue> root,
);

typedef _dart_FLKeyPath_Eval = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLKeyPath> arg0,
  ffi.Pointer<FLValue> root,
);

typedef _c_FLKeyPath_EvalOnce = ffi.Pointer<FLValue> Function(
  FLSlice specifier,
  ffi.Pointer<FLValue> root,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_FLKeyPath_EvalOnce = ffi.Pointer<FLValue> Function(
  FLSlice specifier,
  ffi.Pointer<FLValue> root,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_FLSharedKeys_Create = ffi.Pointer<FLSharedKeys> Function();

typedef _dart_FLSharedKeys_Create = ffi.Pointer<FLSharedKeys> Function();

typedef _c_FLSharedKeys_Retain = ffi.Pointer<FLSharedKeys> Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _dart_FLSharedKeys_Retain = ffi.Pointer<FLSharedKeys> Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _c_FLSharedKeys_Release = ffi.Void Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _dart_FLSharedKeys_Release = void Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _c_FLSharedKeys_CreateFromStateData = ffi.Pointer<FLSharedKeys>
    Function(
  FLSlice arg0,
);

typedef _dart_FLSharedKeys_CreateFromStateData = ffi.Pointer<FLSharedKeys>
    Function(
  FLSlice arg0,
);

typedef _c_FLSharedKeys_GetStateData = FLSliceResult Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _dart_FLSharedKeys_GetStateData = FLSliceResult Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _c_FLSharedKeys_Encode = ffi.Int32 Function(
  ffi.Pointer<FLSharedKeys> arg0,
  FLSlice arg1,
  ffi.Uint8 add,
);

typedef _dart_FLSharedKeys_Encode = int Function(
  ffi.Pointer<FLSharedKeys> arg0,
  FLSlice arg1,
  int add,
);

typedef _c_FLSharedKeys_Decode = FLSlice Function(
  ffi.Pointer<FLSharedKeys> arg0,
  ffi.Int32 key,
);

typedef _dart_FLSharedKeys_Decode = FLSlice Function(
  ffi.Pointer<FLSharedKeys> arg0,
  int key,
);

typedef _c_FLSharedKeys_Count = ffi.Uint32 Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _dart_FLSharedKeys_Count = int Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _c_FLEncoder_New = ffi.Pointer<FLEncoder> Function();

typedef _dart_FLEncoder_New = ffi.Pointer<FLEncoder> Function();

typedef _c_FLEncoder_NewWithOptions = ffi.Pointer<FLEncoder> Function(
  ffi.Int32 format,
  ffi.Uint64 reserveSize,
  ffi.Uint8 uniqueStrings,
);

typedef _dart_FLEncoder_NewWithOptions = ffi.Pointer<FLEncoder> Function(
  int format,
  int reserveSize,
  int uniqueStrings,
);

typedef _c_FLEncoder_NewWritingToFile = ffi.Pointer<FLEncoder> Function(
  ffi.Pointer<FILE> arg0,
  ffi.Uint8 uniqueStrings,
);

typedef _dart_FLEncoder_NewWritingToFile = ffi.Pointer<FLEncoder> Function(
  ffi.Pointer<FILE> arg0,
  int uniqueStrings,
);

typedef _c_FLEncoder_Free = ffi.Void Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_Free = void Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_SetSharedKeys = ffi.Void Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<FLSharedKeys> arg1,
);

typedef _dart_FLEncoder_SetSharedKeys = void Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<FLSharedKeys> arg1,
);

typedef _c_FLEncoder_SetExtraInfo = ffi.Void Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<ffi.Void> info,
);

typedef _dart_FLEncoder_SetExtraInfo = void Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<ffi.Void> info,
);

typedef _c_FLEncoder_GetExtraInfo = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_GetExtraInfo = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_Amend = ffi.Void Function(
  ffi.Pointer<FLEncoder> e,
  FLSlice base,
  ffi.Uint8 reuseStrings,
  ffi.Uint8 externPointers,
);

typedef _dart_FLEncoder_Amend = void Function(
  ffi.Pointer<FLEncoder> e,
  FLSlice base,
  int reuseStrings,
  int externPointers,
);

typedef _c_FLEncoder_GetBase = FLSlice Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_GetBase = FLSlice Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_SuppressTrailer = ffi.Void Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_SuppressTrailer = void Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_Reset = ffi.Void Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_Reset = void Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_BytesWritten = ffi.Uint64 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_BytesWritten = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_GetNextWritePos = ffi.Uint64 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_GetNextWritePos = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_WriteNull = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_WriteNull = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_WriteUndefined = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_WriteUndefined = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_WriteBool = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Uint8 arg1,
);

typedef _dart_FLEncoder_WriteBool = int Function(
  ffi.Pointer<FLEncoder> arg0,
  int arg1,
);

typedef _c_FLEncoder_WriteInt = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Int64 arg1,
);

typedef _dart_FLEncoder_WriteInt = int Function(
  ffi.Pointer<FLEncoder> arg0,
  int arg1,
);

typedef _c_FLEncoder_WriteUInt = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Uint64 arg1,
);

typedef _dart_FLEncoder_WriteUInt = int Function(
  ffi.Pointer<FLEncoder> arg0,
  int arg1,
);

typedef _c_FLEncoder_WriteFloat = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Float arg1,
);

typedef _dart_FLEncoder_WriteFloat = int Function(
  ffi.Pointer<FLEncoder> arg0,
  double arg1,
);

typedef _c_FLEncoder_WriteDouble = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Double arg1,
);

typedef _dart_FLEncoder_WriteDouble = int Function(
  ffi.Pointer<FLEncoder> arg0,
  double arg1,
);

typedef _c_FLEncoder_WriteString = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _dart_FLEncoder_WriteString = int Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _c_FLEncoder_WriteDateString = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> encoder,
  ffi.Int64 ts,
  ffi.Uint8 asUTC,
);

typedef _dart_FLEncoder_WriteDateString = int Function(
  ffi.Pointer<FLEncoder> encoder,
  int ts,
  int asUTC,
);

typedef _c_FLEncoder_WriteData = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _dart_FLEncoder_WriteData = int Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _c_FLEncoder_WriteRaw = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _dart_FLEncoder_WriteRaw = int Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _c_FLEncoder_BeginArray = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Uint64 reserveCount,
);

typedef _dart_FLEncoder_BeginArray = int Function(
  ffi.Pointer<FLEncoder> arg0,
  int reserveCount,
);

typedef _c_FLEncoder_EndArray = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_EndArray = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_BeginDict = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Uint64 reserveCount,
);

typedef _dart_FLEncoder_BeginDict = int Function(
  ffi.Pointer<FLEncoder> arg0,
  int reserveCount,
);

typedef _c_FLEncoder_WriteKey = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _dart_FLEncoder_WriteKey = int Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _c_FLEncoder_WriteKeyValue = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<FLValue> arg1,
);

typedef _dart_FLEncoder_WriteKeyValue = int Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<FLValue> arg1,
);

typedef _c_FLEncoder_EndDict = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_EndDict = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_WriteValue = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<FLValue> arg1,
);

typedef _dart_FLEncoder_WriteValue = int Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<FLValue> arg1,
);

typedef _c_FLEncoder_ConvertJSON = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice json,
);

typedef _dart_FLEncoder_ConvertJSON = int Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice json,
);

typedef _c_FLEncoder_FinishItem = ffi.Uint64 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_FinishItem = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_FinishDoc = ffi.Pointer<FLDoc> Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<ffi.Int32> arg1,
);

typedef _dart_FLEncoder_FinishDoc = ffi.Pointer<FLDoc> Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<ffi.Int32> arg1,
);

typedef _c_FLEncoder_Finish = FLSliceResult Function(
  ffi.Pointer<FLEncoder> e,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _dart_FLEncoder_Finish = FLSliceResult Function(
  ffi.Pointer<FLEncoder> e,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _c_FLEncoder_GetError = ffi.Int32 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_GetError = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_GetErrorMessage = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_GetErrorMessage = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLCreateJSONDelta = FLSliceResult Function(
  ffi.Pointer<FLValue> old,
  ffi.Pointer<FLValue> nuu,
);

typedef _dart_FLCreateJSONDelta = FLSliceResult Function(
  ffi.Pointer<FLValue> old,
  ffi.Pointer<FLValue> nuu,
);

typedef _c_FLEncodeJSONDelta = ffi.Uint8 Function(
  ffi.Pointer<FLValue> old,
  ffi.Pointer<FLValue> nuu,
  ffi.Pointer<FLEncoder> jsonEncoder,
);

typedef _dart_FLEncodeJSONDelta = int Function(
  ffi.Pointer<FLValue> old,
  ffi.Pointer<FLValue> nuu,
  ffi.Pointer<FLEncoder> jsonEncoder,
);

typedef _c_FLApplyJSONDelta = FLSliceResult Function(
  ffi.Pointer<FLValue> old,
  FLSlice jsonDelta,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_FLApplyJSONDelta = FLSliceResult Function(
  ffi.Pointer<FLValue> old,
  FLSlice jsonDelta,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_FLEncodeApplyingJSONDelta = ffi.Uint8 Function(
  ffi.Pointer<FLValue> old,
  FLSlice jsonDelta,
  ffi.Pointer<FLEncoder> encoder,
);

typedef _dart_FLEncodeApplyingJSONDelta = int Function(
  ffi.Pointer<FLValue> old,
  FLSlice jsonDelta,
  ffi.Pointer<FLEncoder> encoder,
);

typedef _c_CBL_IsBlob = ffi.Uint8 Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _dart_CBL_IsBlob = int Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _c_CBLBlob_Get = ffi.Pointer<CBLBlob> Function(
  ffi.Pointer<FLDict> blobDict,
);

typedef _dart_CBLBlob_Get = ffi.Pointer<CBLBlob> Function(
  ffi.Pointer<FLDict> blobDict,
);

typedef _c_CBLBlob_Length = ffi.Uint64 Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _dart_CBLBlob_Length = int Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _c_CBLBlob_Digest = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _dart_CBLBlob_Digest = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _c_CBLBlob_ContentType = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _dart_CBLBlob_ContentType = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _c_CBLBlob_Properties = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _dart_CBLBlob_Properties = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _c_CBLBlob_LoadContent = FLSliceResult Function(
  ffi.Pointer<CBLBlob> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLBlob_LoadContent = FLSliceResult Function(
  ffi.Pointer<CBLBlob> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLBlob_OpenContentStream = ffi.Pointer<CBLBlobReadStream> Function(
  ffi.Pointer<CBLBlob> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLBlob_OpenContentStream = ffi.Pointer<CBLBlobReadStream>
    Function(
  ffi.Pointer<CBLBlob> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLBlobReader_Read = ffi.Int32 Function(
  ffi.Pointer<CBLBlobReadStream> stream,
  ffi.Pointer<ffi.Void> dst,
  ffi.Uint64 maxLength,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLBlobReader_Read = int Function(
  ffi.Pointer<CBLBlobReadStream> stream,
  ffi.Pointer<ffi.Void> dst,
  int maxLength,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLBlobReader_Close = ffi.Void Function(
  ffi.Pointer<CBLBlobReadStream> arg0,
);

typedef _dart_CBLBlobReader_Close = void Function(
  ffi.Pointer<CBLBlobReadStream> arg0,
);

typedef _c_CBLBlob_CreateWithData = ffi.Pointer<CBLBlob> Function(
  ffi.Pointer<ffi.Int8> contentType,
  FLSlice contents,
);

typedef _dart_CBLBlob_CreateWithData = ffi.Pointer<CBLBlob> Function(
  ffi.Pointer<ffi.Int8> contentType,
  FLSlice contents,
);

typedef _c_CBLBlob_CreateWithData_s = ffi.Pointer<CBLBlob> Function(
  FLSlice contentType,
  FLSlice contents,
);

typedef _dart_CBLBlob_CreateWithData_s = ffi.Pointer<CBLBlob> Function(
  FLSlice contentType,
  FLSlice contents,
);

typedef _c_CBLBlobWriter_New = ffi.Pointer<CBLBlobWriteStream> Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLBlobWriter_New = ffi.Pointer<CBLBlobWriteStream> Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLBlobWriter_Close = ffi.Void Function(
  ffi.Pointer<CBLBlobWriteStream> arg0,
);

typedef _dart_CBLBlobWriter_Close = void Function(
  ffi.Pointer<CBLBlobWriteStream> arg0,
);

typedef _c_CBLBlobWriter_Write = ffi.Uint8 Function(
  ffi.Pointer<CBLBlobWriteStream> writer,
  ffi.Pointer<ffi.Void> data,
  ffi.Uint64 length,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLBlobWriter_Write = int Function(
  ffi.Pointer<CBLBlobWriteStream> writer,
  ffi.Pointer<ffi.Void> data,
  int length,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLBlob_CreateWithStream = ffi.Pointer<CBLBlob> Function(
  ffi.Pointer<ffi.Int8> contentType,
  ffi.Pointer<CBLBlobWriteStream> writer,
);

typedef _dart_CBLBlob_CreateWithStream = ffi.Pointer<CBLBlob> Function(
  ffi.Pointer<ffi.Int8> contentType,
  ffi.Pointer<CBLBlobWriteStream> writer,
);

typedef _c_CBLBlob_CreateWithStream_s = ffi.Pointer<CBLBlob> Function(
  FLSlice contentType,
  ffi.Pointer<CBLBlobWriteStream> writer,
);

typedef _dart_CBLBlob_CreateWithStream_s = ffi.Pointer<CBLBlob> Function(
  FLSlice contentType,
  ffi.Pointer<CBLBlobWriteStream> writer,
);

typedef _c_FLSlot_SetBlob = ffi.Void Function(
  ffi.Pointer<FLSlot> slot,
  ffi.Pointer<CBLBlob> blob,
);

typedef _dart_FLSlot_SetBlob = void Function(
  ffi.Pointer<FLSlot> slot,
  ffi.Pointer<CBLBlob> blob,
);

typedef _c_FLMutableArray_SetBlob = ffi.Void Function(
  ffi.Pointer<FLArray> array,
  ffi.Uint32 index,
  ffi.Pointer<CBLBlob> blob,
);

typedef _dart_FLMutableArray_SetBlob = void Function(
  ffi.Pointer<FLArray> array,
  int index,
  ffi.Pointer<CBLBlob> blob,
);

typedef _c_FLMutableDict_SetBlob = ffi.Void Function(
  ffi.Pointer<FLDict> dict,
  FLSlice key,
  ffi.Pointer<CBLBlob> blob,
);

typedef _dart_FLMutableDict_SetBlob = void Function(
  ffi.Pointer<FLDict> dict,
  FLSlice key,
  ffi.Pointer<CBLBlob> blob,
);

typedef _c_CBLDatabaseConfiguration_Default = CBLDatabaseConfiguration
    Function();

typedef _dart_CBLDatabaseConfiguration_Default = CBLDatabaseConfiguration
    Function();

typedef _c_CBLDatabaseConfiguration_Default_s = CBLDatabaseConfiguration_s
    Function();

typedef _dart_CBLDatabaseConfiguration_Default_s = CBLDatabaseConfiguration_s
    Function();

typedef _c_CBL_DatabaseExists = ffi.Uint8 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> inDirectory,
);

typedef _dart_CBL_DatabaseExists = int Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> inDirectory,
);

typedef _c_CBL_DatabaseExists_s = ffi.Uint8 Function(
  FLSlice name,
  FLSlice inDirectory,
);

typedef _dart_CBL_DatabaseExists_s = int Function(
  FLSlice name,
  FLSlice inDirectory,
);

typedef _c_CBL_CopyDatabase = ffi.Uint8 Function(
  ffi.Pointer<ffi.Int8> fromPath,
  ffi.Pointer<ffi.Int8> toName,
  ffi.Pointer<CBLDatabaseConfiguration> config,
  ffi.Pointer<CBLError> arg3,
);

typedef _dart_CBL_CopyDatabase = int Function(
  ffi.Pointer<ffi.Int8> fromPath,
  ffi.Pointer<ffi.Int8> toName,
  ffi.Pointer<CBLDatabaseConfiguration> config,
  ffi.Pointer<CBLError> arg3,
);

typedef _c_CBL_CopyDatabase_s = ffi.Uint8 Function(
  FLSlice fromPath,
  FLSlice toName,
  ffi.Pointer<CBLDatabaseConfiguration_s> config,
  ffi.Pointer<CBLError> arg3,
);

typedef _dart_CBL_CopyDatabase_s = int Function(
  FLSlice fromPath,
  FLSlice toName,
  ffi.Pointer<CBLDatabaseConfiguration_s> config,
  ffi.Pointer<CBLError> arg3,
);

typedef _c_CBL_DeleteDatabase = ffi.Uint8 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> inDirectory,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBL_DeleteDatabase = int Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> inDirectory,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBL_DeleteDatabase_s = ffi.Uint8 Function(
  FLSlice name,
  FLSlice inDirectory,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBL_DeleteDatabase_s = int Function(
  FLSlice name,
  FLSlice inDirectory,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_Open = ffi.Pointer<CBLDatabase> Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<CBLDatabaseConfiguration> config,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLDatabase_Open = ffi.Pointer<CBLDatabase> Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<CBLDatabaseConfiguration> config,
  ffi.Pointer<CBLError> error,
);

typedef _c_CBLDatabase_Open_s = ffi.Pointer<CBLDatabase> Function(
  FLSlice name,
  ffi.Pointer<CBLDatabaseConfiguration_s> config,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLDatabase_Open_s = ffi.Pointer<CBLDatabase> Function(
  FLSlice name,
  ffi.Pointer<CBLDatabaseConfiguration_s> config,
  ffi.Pointer<CBLError> error,
);

typedef _c_CBLDatabase_Close = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _dart_CBLDatabase_Close = int Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _c_CBLDatabase_Delete = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _dart_CBLDatabase_Delete = int Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _c_CBLDatabase_Compact = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _dart_CBLDatabase_Compact = int Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _c_CBLDatabase_BeginBatch = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _dart_CBLDatabase_BeginBatch = int Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _c_CBLDatabase_EndBatch = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _dart_CBLDatabase_EndBatch = int Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _c_CBLDatabase_Name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef _dart_CBLDatabase_Name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef _c_CBLDatabase_Path = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef _dart_CBLDatabase_Path = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef _c_CBLDatabase_Count = ffi.Uint64 Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef _dart_CBLDatabase_Count = int Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef _c_CBLDatabase_Config = CBLDatabaseConfiguration Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef _dart_CBLDatabase_Config = CBLDatabaseConfiguration Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef CBLDatabaseChangeListener = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLDatabase>,
  ffi.Uint32,
  ffi.Pointer<ffi.Pointer<ffi.Int8>>,
);

typedef _c_CBLDatabase_AddChangeListener = ffi.Pointer<CBLListenerToken>
    Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.NativeFunction<CBLDatabaseChangeListener>> listener,
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_CBLDatabase_AddChangeListener = ffi.Pointer<CBLListenerToken>
    Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.NativeFunction<CBLDatabaseChangeListener>> listener,
  ffi.Pointer<ffi.Void> context,
);

typedef CBLNotificationsReadyCallback = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLDatabase>,
);

typedef _c_CBLDatabase_BufferNotifications = ffi.Void Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.NativeFunction<CBLNotificationsReadyCallback>> callback,
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_CBLDatabase_BufferNotifications = void Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.NativeFunction<CBLNotificationsReadyCallback>> callback,
  ffi.Pointer<ffi.Void> context,
);

typedef _c_CBLDatabase_SendNotifications = ffi.Void Function(
  ffi.Pointer<CBLDatabase> db,
);

typedef _dart_CBLDatabase_SendNotifications = void Function(
  ffi.Pointer<CBLDatabase> db,
);

typedef _c_CBLDatabase_GetDocument = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDatabase> database,
  ffi.Pointer<ffi.Int8> docID,
);

typedef _dart_CBLDatabase_GetDocument = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDatabase> database,
  ffi.Pointer<ffi.Int8> docID,
);

typedef _c_CBLDatabase_GetDocument_s = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDatabase> database,
  FLSlice docID,
);

typedef _dart_CBLDatabase_GetDocument_s = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDatabase> database,
  FLSlice docID,
);

typedef _c_CBLDatabase_SaveDocument = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> doc,
  ffi.Uint8 concurrency,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLDatabase_SaveDocument = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> doc,
  int concurrency,
  ffi.Pointer<CBLError> error,
);

typedef CBLSaveConflictHandler = ffi.Uint8 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLDocument>,
  ffi.Pointer<CBLDocument>,
);

typedef _c_CBLDatabase_SaveDocumentResolving = ffi.Pointer<CBLDocument>
    Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> doc,
  ffi.Pointer<ffi.NativeFunction<CBLSaveConflictHandler>> conflictHandler,
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLDatabase_SaveDocumentResolving = ffi.Pointer<CBLDocument>
    Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> doc,
  ffi.Pointer<ffi.NativeFunction<CBLSaveConflictHandler>> conflictHandler,
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLError> error,
);

typedef _c_CBLDocument_Delete = ffi.Uint8 Function(
  ffi.Pointer<CBLDocument> document,
  ffi.Uint8 concurrency,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLDocument_Delete = int Function(
  ffi.Pointer<CBLDocument> document,
  int concurrency,
  ffi.Pointer<CBLError> error,
);

typedef _c_CBLDocument_Purge = ffi.Uint8 Function(
  ffi.Pointer<CBLDocument> document,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLDocument_Purge = int Function(
  ffi.Pointer<CBLDocument> document,
  ffi.Pointer<CBLError> error,
);

typedef _c_CBLDatabase_PurgeDocumentByID = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> database,
  ffi.Pointer<ffi.Int8> docID,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLDatabase_PurgeDocumentByID = int Function(
  ffi.Pointer<CBLDatabase> database,
  ffi.Pointer<ffi.Int8> docID,
  ffi.Pointer<CBLError> error,
);

typedef _c_CBLDatabase_PurgeDocumentByID_s = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> database,
  FLSlice docID,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLDatabase_PurgeDocumentByID_s = int Function(
  ffi.Pointer<CBLDatabase> database,
  FLSlice docID,
  ffi.Pointer<CBLError> error,
);

typedef _c_CBLDatabase_GetMutableDocument = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDatabase> database,
  ffi.Pointer<ffi.Int8> docID,
);

typedef _dart_CBLDatabase_GetMutableDocument = ffi.Pointer<CBLDocument>
    Function(
  ffi.Pointer<CBLDatabase> database,
  ffi.Pointer<ffi.Int8> docID,
);

typedef _c_CBLDatabase_GetMutableDocument_s = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDatabase> database,
  FLSlice docID,
);

typedef _dart_CBLDatabase_GetMutableDocument_s = ffi.Pointer<CBLDocument>
    Function(
  ffi.Pointer<CBLDatabase> database,
  FLSlice docID,
);

typedef _c_CBLDocument_New = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<ffi.Int8> docID,
);

typedef _dart_CBLDocument_New = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<ffi.Int8> docID,
);

typedef _c_CBLDocument_New_s = ffi.Pointer<CBLDocument> Function(
  FLSlice docID,
);

typedef _dart_CBLDocument_New_s = ffi.Pointer<CBLDocument> Function(
  FLSlice docID,
);

typedef _c_CBLDocument_MutableCopy = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDocument> original,
);

typedef _dart_CBLDocument_MutableCopy = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDocument> original,
);

typedef _c_CBLDocument_ID = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _dart_CBLDocument_ID = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _c_CBLDocument_RevisionID = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _dart_CBLDocument_RevisionID = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _c_CBLDocument_Sequence = ffi.Uint64 Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _dart_CBLDocument_Sequence = int Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _c_CBLDocument_Properties = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _dart_CBLDocument_Properties = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _c_CBLDocument_MutableProperties = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _dart_CBLDocument_MutableProperties = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _c_CBLDocument_SetProperties = ffi.Void Function(
  ffi.Pointer<CBLDocument> arg0,
  ffi.Pointer<FLDict> properties,
);

typedef _dart_CBLDocument_SetProperties = void Function(
  ffi.Pointer<CBLDocument> arg0,
  ffi.Pointer<FLDict> properties,
);

typedef _c_CBLDocument_CreateFleeceDoc = ffi.Pointer<FLDoc> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _dart_CBLDocument_CreateFleeceDoc = ffi.Pointer<FLDoc> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _c_CBLDocument_PropertiesAsJSON = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _dart_CBLDocument_PropertiesAsJSON = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _c_CBLDocument_SetPropertiesAsJSON = ffi.Uint8 Function(
  ffi.Pointer<CBLDocument> arg0,
  ffi.Pointer<ffi.Int8> json,
  ffi.Pointer<CBLError> arg2,
);

typedef _dart_CBLDocument_SetPropertiesAsJSON = int Function(
  ffi.Pointer<CBLDocument> arg0,
  ffi.Pointer<ffi.Int8> json,
  ffi.Pointer<CBLError> arg2,
);

typedef _c_CBLDocument_SetPropertiesAsJSON_s = ffi.Uint8 Function(
  ffi.Pointer<CBLDocument> arg0,
  FLSlice json,
  ffi.Pointer<CBLError> arg2,
);

typedef _dart_CBLDocument_SetPropertiesAsJSON_s = int Function(
  ffi.Pointer<CBLDocument> arg0,
  FLSlice json,
  ffi.Pointer<CBLError> arg2,
);

typedef _c_CBLDatabase_GetDocumentExpiration = ffi.Int64 Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.Int8> docID,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLDatabase_GetDocumentExpiration = int Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.Int8> docID,
  ffi.Pointer<CBLError> error,
);

typedef _c_CBLDatabase_GetDocumentExpiration_s = ffi.Int64 Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice docID,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLDatabase_GetDocumentExpiration_s = int Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice docID,
  ffi.Pointer<CBLError> error,
);

typedef _c_CBLDatabase_SetDocumentExpiration = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.Int8> docID,
  ffi.Int64 expiration,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLDatabase_SetDocumentExpiration = int Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.Int8> docID,
  int expiration,
  ffi.Pointer<CBLError> error,
);

typedef _c_CBLDatabase_SetDocumentExpiration_s = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice docID,
  ffi.Int64 expiration,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLDatabase_SetDocumentExpiration_s = int Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice docID,
  int expiration,
  ffi.Pointer<CBLError> error,
);

typedef CBLDocumentChangeListener = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLDatabase>,
  ffi.Pointer<ffi.Int8>,
);

typedef _c_CBLDatabase_AddDocumentChangeListener = ffi.Pointer<CBLListenerToken>
    Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.Int8> docID,
  ffi.Pointer<ffi.NativeFunction<CBLDocumentChangeListener>> listener,
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_CBLDatabase_AddDocumentChangeListener
    = ffi.Pointer<CBLListenerToken> Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.Int8> docID,
  ffi.Pointer<ffi.NativeFunction<CBLDocumentChangeListener>> listener,
  ffi.Pointer<ffi.Void> context,
);

typedef _c_CBL_Log = ffi.Void Function(
  ffi.Uint8 domain,
  ffi.Uint8 level,
  ffi.Pointer<ffi.Int8> format,
);

typedef _dart_CBL_Log = void Function(
  int domain,
  int level,
  ffi.Pointer<ffi.Int8> format,
);

typedef _c_CBL_Log_s = ffi.Void Function(
  ffi.Uint8 domain,
  ffi.Uint8 level,
  FLSlice message,
);

typedef _dart_CBL_Log_s = void Function(
  int domain,
  int level,
  FLSlice message,
);

typedef _c_CBLLog_ConsoleLevel = ffi.Uint8 Function();

typedef _dart_CBLLog_ConsoleLevel = int Function();

typedef _c_CBLLog_SetConsoleLevel = ffi.Void Function(
  ffi.Uint8 arg0,
);

typedef _dart_CBLLog_SetConsoleLevel = void Function(
  int arg0,
);

typedef _c_CBLLog_WillLogToConsole = ffi.Uint8 Function(
  ffi.Uint8 domain,
  ffi.Uint8 level,
);

typedef _dart_CBLLog_WillLogToConsole = int Function(
  int domain,
  int level,
);

typedef CBLLogCallback = ffi.Void Function(
  ffi.Uint8,
  ffi.Uint8,
  ffi.Pointer<ffi.Int8>,
);

typedef _c_CBLLog_Callback = ffi.Pointer<ffi.NativeFunction<CBLLogCallback>>
    Function();

typedef _dart_CBLLog_Callback = ffi.Pointer<ffi.NativeFunction<CBLLogCallback>>
    Function();

typedef _c_CBLLog_SetCallback = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<CBLLogCallback>> arg0,
);

typedef _dart_CBLLog_SetCallback = void Function(
  ffi.Pointer<ffi.NativeFunction<CBLLogCallback>> arg0,
);

typedef _c_CBLLog_FileConfig = ffi.Pointer<CBLLogFileConfiguration> Function();

typedef _dart_CBLLog_FileConfig = ffi.Pointer<CBLLogFileConfiguration>
    Function();

typedef _c_CBLLog_SetFileConfig = ffi.Void Function(
  CBLLogFileConfiguration arg0,
);

typedef _dart_CBLLog_SetFileConfig = void Function(
  CBLLogFileConfiguration arg0,
);

typedef _c_CBLQuery_New = ffi.Pointer<CBLQuery> Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Uint32 language,
  ffi.Pointer<ffi.Int8> queryString,
  ffi.Pointer<ffi.Int32> outErrorPos,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLQuery_New = ffi.Pointer<CBLQuery> Function(
  ffi.Pointer<CBLDatabase> db,
  int language,
  ffi.Pointer<ffi.Int8> queryString,
  ffi.Pointer<ffi.Int32> outErrorPos,
  ffi.Pointer<CBLError> error,
);

typedef _c_CBLQuery_New_s = ffi.Pointer<CBLQuery> Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Uint32 language,
  FLSlice queryString,
  ffi.Pointer<ffi.Int32> outErrorPos,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLQuery_New_s = ffi.Pointer<CBLQuery> Function(
  ffi.Pointer<CBLDatabase> db,
  int language,
  FLSlice queryString,
  ffi.Pointer<ffi.Int32> outErrorPos,
  ffi.Pointer<CBLError> error,
);

typedef _c_CBLQuery_SetParameters = ffi.Void Function(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<FLDict> parameters,
);

typedef _dart_CBLQuery_SetParameters = void Function(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<FLDict> parameters,
);

typedef _c_CBLQuery_Parameters = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLQuery> query,
);

typedef _dart_CBLQuery_Parameters = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLQuery> query,
);

typedef _c_CBLQuery_SetParametersAsJSON = ffi.Uint8 Function(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<ffi.Int8> json,
);

typedef _dart_CBLQuery_SetParametersAsJSON = int Function(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<ffi.Int8> json,
);

typedef _c_CBLQuery_SetParametersAsJSON_s = ffi.Uint8 Function(
  ffi.Pointer<CBLQuery> query,
  FLSlice json,
);

typedef _dart_CBLQuery_SetParametersAsJSON_s = int Function(
  ffi.Pointer<CBLQuery> query,
  FLSlice json,
);

typedef _c_CBLQuery_Execute = ffi.Pointer<CBLResultSet> Function(
  ffi.Pointer<CBLQuery> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _dart_CBLQuery_Execute = ffi.Pointer<CBLResultSet> Function(
  ffi.Pointer<CBLQuery> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _c_CBLQuery_Explain = FLSliceResult Function(
  ffi.Pointer<CBLQuery> arg0,
);

typedef _dart_CBLQuery_Explain = FLSliceResult Function(
  ffi.Pointer<CBLQuery> arg0,
);

typedef _c_CBLQuery_ColumnCount = ffi.Uint32 Function(
  ffi.Pointer<CBLQuery> arg0,
);

typedef _dart_CBLQuery_ColumnCount = int Function(
  ffi.Pointer<CBLQuery> arg0,
);

typedef _c_CBLQuery_ColumnName = FLSlice Function(
  ffi.Pointer<CBLQuery> arg0,
  ffi.Uint32 columnIndex,
);

typedef _dart_CBLQuery_ColumnName = FLSlice Function(
  ffi.Pointer<CBLQuery> arg0,
  int columnIndex,
);

typedef _c_CBLResultSet_Next = ffi.Uint8 Function(
  ffi.Pointer<CBLResultSet> arg0,
);

typedef _dart_CBLResultSet_Next = int Function(
  ffi.Pointer<CBLResultSet> arg0,
);

typedef _c_CBLResultSet_ValueAtIndex = ffi.Pointer<FLValue> Function(
  ffi.Pointer<CBLResultSet> arg0,
  ffi.Uint32 index,
);

typedef _dart_CBLResultSet_ValueAtIndex = ffi.Pointer<FLValue> Function(
  ffi.Pointer<CBLResultSet> arg0,
  int index,
);

typedef _c_CBLResultSet_ValueForKey = ffi.Pointer<FLValue> Function(
  ffi.Pointer<CBLResultSet> arg0,
  ffi.Pointer<ffi.Int8> key,
);

typedef _dart_CBLResultSet_ValueForKey = ffi.Pointer<FLValue> Function(
  ffi.Pointer<CBLResultSet> arg0,
  ffi.Pointer<ffi.Int8> key,
);

typedef _c_CBLResultSet_ValueForKey_s = ffi.Pointer<FLValue> Function(
  ffi.Pointer<CBLResultSet> arg0,
  FLSlice key,
);

typedef _dart_CBLResultSet_ValueForKey_s = ffi.Pointer<FLValue> Function(
  ffi.Pointer<CBLResultSet> arg0,
  FLSlice key,
);

typedef _c_CBLResultSet_RowArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<CBLResultSet> arg0,
);

typedef _dart_CBLResultSet_RowArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<CBLResultSet> arg0,
);

typedef _c_CBLResultSet_RowDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLResultSet> arg0,
);

typedef _dart_CBLResultSet_RowDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLResultSet> arg0,
);

typedef _c_CBLResultSet_GetQuery = ffi.Pointer<CBLQuery> Function(
  ffi.Pointer<CBLResultSet> rs,
);

typedef _dart_CBLResultSet_GetQuery = ffi.Pointer<CBLQuery> Function(
  ffi.Pointer<CBLResultSet> rs,
);

typedef CBLQueryChangeListener = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLQuery>,
);

typedef _c_CBLQuery_AddChangeListener = ffi.Pointer<CBLListenerToken> Function(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<ffi.NativeFunction<CBLQueryChangeListener>> listener,
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_CBLQuery_AddChangeListener = ffi.Pointer<CBLListenerToken>
    Function(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<ffi.NativeFunction<CBLQueryChangeListener>> listener,
  ffi.Pointer<ffi.Void> context,
);

typedef _c_CBLQuery_CopyCurrentResults = ffi.Pointer<CBLResultSet> Function(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<CBLListenerToken> listener,
  ffi.Pointer<CBLError> error,
);

typedef _dart_CBLQuery_CopyCurrentResults = ffi.Pointer<CBLResultSet> Function(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<CBLListenerToken> listener,
  ffi.Pointer<CBLError> error,
);

typedef _c_CBLDatabase_CreateIndex = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.Int8> name,
  CBLIndexSpec arg2,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_CreateIndex = int Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.Int8> name,
  CBLIndexSpec arg2,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_CreateIndex_s = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice name,
  CBLIndexSpec_s arg2,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_CreateIndex_s = int Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice name,
  CBLIndexSpec_s arg2,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_DeleteIndex = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_DeleteIndex = int Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_IndexNames = ffi.Pointer<FLArray> Function(
  ffi.Pointer<CBLDatabase> db,
);

typedef _dart_CBLDatabase_IndexNames = ffi.Pointer<FLArray> Function(
  ffi.Pointer<CBLDatabase> db,
);

typedef _c_CBLEndpoint_NewWithURL = ffi.Pointer<CBLEndpoint> Function(
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_CBLEndpoint_NewWithURL = ffi.Pointer<CBLEndpoint> Function(
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_CBLEndpoint_NewWithURL_s = ffi.Pointer<CBLEndpoint> Function(
  FLSlice url,
);

typedef _dart_CBLEndpoint_NewWithURL_s = ffi.Pointer<CBLEndpoint> Function(
  FLSlice url,
);

typedef _c_CBLEndpoint_Free = ffi.Void Function(
  ffi.Pointer<CBLEndpoint> arg0,
);

typedef _dart_CBLEndpoint_Free = void Function(
  ffi.Pointer<CBLEndpoint> arg0,
);

typedef _c_CBLAuth_NewBasic = ffi.Pointer<CBLAuthenticator> Function(
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> password,
);

typedef _dart_CBLAuth_NewBasic = ffi.Pointer<CBLAuthenticator> Function(
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> password,
);

typedef _c_CBLAuth_NewBasic_s = ffi.Pointer<CBLAuthenticator> Function(
  FLSlice username,
  FLSlice password,
);

typedef _dart_CBLAuth_NewBasic_s = ffi.Pointer<CBLAuthenticator> Function(
  FLSlice username,
  FLSlice password,
);

typedef _c_CBLAuth_NewSession = ffi.Pointer<CBLAuthenticator> Function(
  ffi.Pointer<ffi.Int8> sessionID,
  ffi.Pointer<ffi.Int8> cookieName,
);

typedef _dart_CBLAuth_NewSession = ffi.Pointer<CBLAuthenticator> Function(
  ffi.Pointer<ffi.Int8> sessionID,
  ffi.Pointer<ffi.Int8> cookieName,
);

typedef _c_CBLAuth_NewSession_s = ffi.Pointer<CBLAuthenticator> Function(
  FLSlice sessionID,
  FLSlice cookieName,
);

typedef _dart_CBLAuth_NewSession_s = ffi.Pointer<CBLAuthenticator> Function(
  FLSlice sessionID,
  FLSlice cookieName,
);

typedef _c_CBLAuth_Free = ffi.Void Function(
  ffi.Pointer<CBLAuthenticator> arg0,
);

typedef _dart_CBLAuth_Free = void Function(
  ffi.Pointer<CBLAuthenticator> arg0,
);

typedef CBLConflictResolver = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<CBLDocument>,
  ffi.Pointer<CBLDocument>,
);

typedef _c_CBLReplicator_New = ffi.Pointer<CBLReplicator> Function(
  ffi.Pointer<CBLReplicatorConfiguration> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _dart_CBLReplicator_New = ffi.Pointer<CBLReplicator> Function(
  ffi.Pointer<CBLReplicatorConfiguration> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _c_CBLReplicator_Config = ffi.Pointer<CBLReplicatorConfiguration>
    Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _dart_CBLReplicator_Config = ffi.Pointer<CBLReplicatorConfiguration>
    Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _c_CBLReplicator_ResetCheckpoint = ffi.Void Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _dart_CBLReplicator_ResetCheckpoint = void Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _c_CBLReplicator_Start = ffi.Void Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _dart_CBLReplicator_Start = void Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _c_CBLReplicator_Stop = ffi.Void Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _dart_CBLReplicator_Stop = void Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _c_CBLReplicator_SetHostReachable = ffi.Void Function(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Uint8 reachable,
);

typedef _dart_CBLReplicator_SetHostReachable = void Function(
  ffi.Pointer<CBLReplicator> arg0,
  int reachable,
);

typedef _c_CBLReplicator_SetSuspended = ffi.Void Function(
  ffi.Pointer<CBLReplicator> repl,
  ffi.Uint8 suspended,
);

typedef _dart_CBLReplicator_SetSuspended = void Function(
  ffi.Pointer<CBLReplicator> repl,
  int suspended,
);

typedef _c_CBLReplicator_Status = CBLReplicatorStatus Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _dart_CBLReplicator_Status = CBLReplicatorStatus Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _c_CBLReplicator_PendingDocumentIDs = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _dart_CBLReplicator_PendingDocumentIDs = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Pointer<CBLError> arg1,
);

typedef _c_CBLReplicator_IsDocumentPending = ffi.Uint8 Function(
  ffi.Pointer<CBLReplicator> repl,
  FLSlice docID,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLReplicator_IsDocumentPending = int Function(
  ffi.Pointer<CBLReplicator> repl,
  FLSlice docID,
  ffi.Pointer<CBLError> outError,
);

typedef CBLReplicatorChangeListener = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLReplicator>,
  ffi.Pointer<CBLReplicatorStatus>,
);

typedef _c_CBLReplicator_AddChangeListener = ffi.Pointer<CBLListenerToken>
    Function(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Pointer<ffi.NativeFunction<CBLReplicatorChangeListener>> arg1,
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_CBLReplicator_AddChangeListener = ffi.Pointer<CBLListenerToken>
    Function(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Pointer<ffi.NativeFunction<CBLReplicatorChangeListener>> arg1,
  ffi.Pointer<ffi.Void> context,
);

typedef CBLReplicatedDocumentListener = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLReplicator>,
  ffi.Uint8,
  ffi.Uint32,
  ffi.Pointer<CBLReplicatedDocument>,
);

typedef _c_CBLReplicator_AddDocumentListener = ffi.Pointer<CBLListenerToken>
    Function(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Pointer<ffi.NativeFunction<CBLReplicatedDocumentListener>> arg1,
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_CBLReplicator_AddDocumentListener = ffi.Pointer<CBLListenerToken>
    Function(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Pointer<ffi.NativeFunction<CBLReplicatedDocumentListener>> arg1,
  ffi.Pointer<ffi.Void> context,
);

typedef Dart_PostCObjectType = ffi.Uint8 Function(
  ffi.Int32,
  ffi.Pointer<ffi.Int32>,
);

typedef _c_CBLDart_PostCObject = ffi.Int32 Function(
  ffi.Pointer<ffi.NativeFunction<Dart_PostCObjectType>> function_pointer,
);

typedef _dart_CBLDart_PostCObject = int Function(
  ffi.Pointer<ffi.NativeFunction<Dart_PostCObjectType>> function_pointer,
);

typedef _c_CBLDart_NewNativePort = ffi.Int32 Function(
  ffi.Int32 function_pointer,
);

typedef _dart_CBLDart_NewNativePort = int Function(
  int function_pointer,
);

typedef Dart_Port = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32>,
);

typedef Dart_CloseNativePortType = ffi.Uint8 Function(
  ffi.Pointer<ffi.NativeFunction<Dart_Port>>,
);

typedef _c_CBLDart_CloseNativePort = ffi.Int32 Function(
  ffi.Pointer<ffi.NativeFunction<Dart_CloseNativePortType>> function_pointer,
);

typedef _dart_CBLDart_CloseNativePort = int Function(
  ffi.Pointer<ffi.NativeFunction<Dart_CloseNativePortType>> function_pointer,
);

typedef CBLDart_ReplicatorStatusCallback = ffi.Void Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<FLDict>,
);

typedef CBLDart_ReplicatorFilterCallback = ffi.Uint8 Function(
  ffi.Uint8,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<CBLDocument>,
  ffi.Uint8,
);

typedef CBLDart_ConflictResolverCallback = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<CBLDocument>,
  ffi.Pointer<CBLDocument>,
);

typedef _c_CBLDart_RegisterPorts = ffi.Int32 Function(
  ffi.Uint64 database_listener_port,
  ffi.Uint64 document_listener_port,
  ffi.Uint64 query_listener_port,
  ffi.Uint64 replicator_status_port,
  ffi.Uint64 replicator_filter_port,
  ffi.Uint64 replicator_conflict_port,
  ffi.Pointer<ffi.NativeFunction<CBLDart_ReplicatorStatusCallback>>
      replicator_status_callback,
  ffi.Pointer<ffi.NativeFunction<CBLDart_ReplicatorFilterCallback>>
      replicator_filter_callback,
  ffi.Pointer<ffi.NativeFunction<CBLDart_ConflictResolverCallback>>
      replicator_conflict_callback,
);

typedef _dart_CBLDart_RegisterPorts = int Function(
  int database_listener_port,
  int document_listener_port,
  int query_listener_port,
  int replicator_status_port,
  int replicator_filter_port,
  int replicator_conflict_port,
  ffi.Pointer<ffi.NativeFunction<CBLDart_ReplicatorStatusCallback>>
      replicator_status_callback,
  ffi.Pointer<ffi.NativeFunction<CBLDart_ReplicatorFilterCallback>>
      replicator_filter_callback,
  ffi.Pointer<ffi.NativeFunction<CBLDart_ConflictResolverCallback>>
      replicator_conflict_callback,
);

typedef _c_CBLDart_ExecuteCallback = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> work_ptr,
);

typedef _dart_CBLDart_ExecuteCallback = int Function(
  ffi.Pointer<ffi.Int32> work_ptr,
);

typedef _c_CBLDart_DatabaseChangeListener = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLDatabase> db,
  ffi.Uint32 numDocs,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> docIDs,
);

typedef _dart_CBLDart_DatabaseChangeListener = int Function(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLDatabase> db,
  int numDocs,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> docIDs,
);

typedef _c_CBLDart_DocumentChangeListener = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.Int8> docID,
);

typedef _dart_CBLDart_DocumentChangeListener = int Function(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.Int8> docID,
);

typedef _c_CBLDart_QueryChangeListener = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> queryId,
  ffi.Pointer<CBLQuery> query,
);

typedef _dart_CBLDart_QueryChangeListener = int Function(
  ffi.Pointer<ffi.Void> queryId,
  ffi.Pointer<CBLQuery> query,
);

typedef _c_CBLDart_ReplicatorChangeListener = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> id,
  ffi.Pointer<CBLReplicator> repl,
  ffi.Pointer<CBLReplicatorStatus> status,
);

typedef _dart_CBLDart_ReplicatorChangeListener = int Function(
  ffi.Pointer<ffi.Void> id,
  ffi.Pointer<CBLReplicator> repl,
  ffi.Pointer<CBLReplicatorStatus> status,
);

typedef _c_CBLDart_PushReplicationFilter = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLDocument> document,
  ffi.Uint8 isDeleted,
);

typedef _dart_CBLDart_PushReplicationFilter = int Function(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLDocument> document,
  int isDeleted,
);

typedef _c_CBLDart_PullReplicationFilter = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLDocument> document,
  ffi.Uint8 isDeleted,
);

typedef _dart_CBLDart_PullReplicationFilter = int Function(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLDocument> document,
  int isDeleted,
);

typedef CBLReplicationFilter = ffi.Uint8 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLDocument>,
  ffi.Uint8,
);
