// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for CouchbaseLiteC
class CblCBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  CblCBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  CblCBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Equality test of two slices.
  bool FLSlice_Equal(
    FLSlice a,
    FLSlice b,
  ) {
    return _FLSlice_Equal(
          a,
          b,
        ) !=
        0;
  }

  late final _FLSlice_Equal_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlice_Equal>>('FLSlice_Equal');
  late final _dart_FLSlice_Equal _FLSlice_Equal =
      _FLSlice_Equal_ptr.asFunction<_dart_FLSlice_Equal>();

  /// Lexicographic comparison of two slices; basically like memcmp(), but taking into account
  /// differences in length.
  int FLSlice_Compare(
    FLSlice arg0,
    FLSlice arg1,
  ) {
    return _FLSlice_Compare(
      arg0,
      arg1,
    );
  }

  late final _FLSlice_Compare_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlice_Compare>>('FLSlice_Compare');
  late final _dart_FLSlice_Compare _FLSlice_Compare =
      _FLSlice_Compare_ptr.asFunction<_dart_FLSlice_Compare>();

  /// Computes a 32-bit hash of a slice's data, suitable for use in hash tables.
  int FLSlice_Hash(
    FLSlice s,
  ) {
    return _FLSlice_Hash(
      s,
    );
  }

  late final _FLSlice_Hash_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlice_Hash>>('FLSlice_Hash');
  late final _dart_FLSlice_Hash _FLSlice_Hash =
      _FLSlice_Hash_ptr.asFunction<_dart_FLSlice_Hash>();

  /// Copies a slice to a buffer, adding a trailing zero byte to make it a valid C string.
  /// If there is not enough capacity the slice will be truncated, but the trailing zero byte is
  /// always written.
  /// @param s  The FLSlice to copy.
  /// @param buffer  Where to copy the bytes. At least `capacity` bytes must be available.
  /// @param capacity  The maximum number of bytes to copy (including the trailing 0.)
  /// @return  True if the entire slice was copied, false if it was truncated.
  bool FLSlice_ToCString(
    FLSlice s,
    ffi.Pointer<ffi.Int8> buffer,
    int capacity,
  ) {
    return _FLSlice_ToCString(
          s,
          buffer,
          capacity,
        ) !=
        0;
  }

  late final _FLSlice_ToCString_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlice_ToCString>>('FLSlice_ToCString');
  late final _dart_FLSlice_ToCString _FLSlice_ToCString =
      _FLSlice_ToCString_ptr.asFunction<_dart_FLSlice_ToCString>();

  /// Allocates an FLSliceResult of the given size, without initializing the buffer.
  FLSliceResult FLSliceResult_New(
    int arg0,
  ) {
    return _FLSliceResult_New(
      arg0,
    );
  }

  late final _FLSliceResult_New_ptr =
      _lookup<ffi.NativeFunction<_c_FLSliceResult_New>>('FLSliceResult_New');
  late final _dart_FLSliceResult_New _FLSliceResult_New =
      _FLSliceResult_New_ptr.asFunction<_dart_FLSliceResult_New>();

  /// Allocates an FLSliceResult, copying the given slice.
  FLSliceResult FLSlice_Copy(
    FLSlice arg0,
  ) {
    return _FLSlice_Copy(
      arg0,
    );
  }

  late final _FLSlice_Copy_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlice_Copy>>('FLSlice_Copy');
  late final _dart_FLSlice_Copy _FLSlice_Copy =
      _FLSlice_Copy_ptr.asFunction<_dart_FLSlice_Copy>();

  void FLBuf_Retain(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _FLBuf_Retain(
      arg0,
    );
  }

  late final _FLBuf_Retain_ptr =
      _lookup<ffi.NativeFunction<_c_FLBuf_Retain>>('_FLBuf_Retain');
  late final _dart_FLBuf_Retain _FLBuf_Retain =
      _FLBuf_Retain_ptr.asFunction<_dart_FLBuf_Retain>();

  void FLBuf_Release(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _FLBuf_Release(
      arg0,
    );
  }

  late final _FLBuf_Release_ptr =
      _lookup<ffi.NativeFunction<_c_FLBuf_Release>>('_FLBuf_Release');
  late final _dart_FLBuf_Release _FLBuf_Release =
      _FLBuf_Release_ptr.asFunction<_dart_FLBuf_Release>();

  /// Writes zeroes to `size` bytes of memory starting at `dst`.
  /// Unlike a call to `memset`, these writes cannot be optimized away by the compiler.
  /// This is useful for securely removing traces of passwords or encryption keys.
  void FL_WipeMemory(
    ffi.Pointer<ffi.Void> dst,
    int size,
  ) {
    return _FL_WipeMemory(
      dst,
      size,
    );
  }

  late final _FL_WipeMemory_ptr =
      _lookup<ffi.NativeFunction<_c_FL_WipeMemory>>('FL_WipeMemory');
  late final _dart_FL_WipeMemory _FL_WipeMemory =
      _FL_WipeMemory_ptr.asFunction<_dart_FL_WipeMemory>();

  /// Returns a message describing an error.
  /// @note  You are responsible for releasing the result by calling \ref FLSliceResult_Release.
  FLSliceResult CBLError_Message(
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLError_Message(
      outError,
    );
  }

  late final _CBLError_Message_ptr =
      _lookup<ffi.NativeFunction<_c_CBLError_Message>>('CBLError_Message');
  late final _dart_CBLError_Message _CBLError_Message =
      _CBLError_Message_ptr.asFunction<_dart_CBLError_Message>();

  /// Returns the current time, in milliseconds since 1/1/1970.
  int CBL_Now() {
    return _CBL_Now();
  }

  late final _CBL_Now_ptr = _lookup<ffi.NativeFunction<_c_CBL_Now>>('CBL_Now');
  late final _dart_CBL_Now _CBL_Now = _CBL_Now_ptr.asFunction<_dart_CBL_Now>();

  /// Increments an object's reference-count.
  /// Usually you'll call one of the type-safe synonyms specific to the object type,
  /// like \ref CBLDatabase_Retain`
  ffi.Pointer<CBLRefCounted> CBL_Retain(
    ffi.Pointer<CBLRefCounted> arg0,
  ) {
    return _CBL_Retain(
      arg0,
    );
  }

  late final _CBL_Retain_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_Retain>>('CBL_Retain');
  late final _dart_CBL_Retain _CBL_Retain =
      _CBL_Retain_ptr.asFunction<_dart_CBL_Retain>();

  /// Decrements an object's reference-count, freeing the object if the count hits zero.
  /// Usually you'll call one of the type-safe synonyms specific to the object type,
  /// like \ref CBLDatabase_Release.
  void CBL_Release(
    ffi.Pointer<CBLRefCounted> arg0,
  ) {
    return _CBL_Release(
      arg0,
    );
  }

  late final _CBL_Release_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_Release>>('CBL_Release');
  late final _dart_CBL_Release _CBL_Release =
      _CBL_Release_ptr.asFunction<_dart_CBL_Release>();

  /// Returns the total number of Couchbase Lite objects. Useful for leak checking.
  int CBL_InstanceCount() {
    return _CBL_InstanceCount();
  }

  late final _CBL_InstanceCount_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_InstanceCount>>('CBL_InstanceCount');
  late final _dart_CBL_InstanceCount _CBL_InstanceCount =
      _CBL_InstanceCount_ptr.asFunction<_dart_CBL_InstanceCount>();

  /// Logs the class and address of each Couchbase Lite object. Useful for leak checking.
  /// @note  May only be functional in debug builds of Couchbase Lite.
  void CBL_DumpInstances() {
    return _CBL_DumpInstances();
  }

  late final _CBL_DumpInstances_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_DumpInstances>>('CBL_DumpInstances');
  late final _dart_CBL_DumpInstances _CBL_DumpInstances =
      _CBL_DumpInstances_ptr.asFunction<_dart_CBL_DumpInstances>();

  /// Removes a listener callback, given the token that was returned when it was added.
  void CBLListener_Remove(
    ffi.Pointer<CBLListenerToken> arg0,
  ) {
    return _CBLListener_Remove(
      arg0,
    );
  }

  late final _CBLListener_Remove_ptr =
      _lookup<ffi.NativeFunction<_c_CBLListener_Remove>>('CBLListener_Remove');
  late final _dart_CBLListener_Remove _CBLListener_Remove =
      _CBLListener_Remove_ptr.asFunction<_dart_CBLListener_Remove>();

  /// Creates an FLDoc from Fleece-encoded data that's been returned as a result from
  /// FLSlice_Copy or other API. The resulting document retains the data, so you don't need to
  /// worry about it remaining valid.
  ffi.Pointer<FLDoc> FLDoc_FromResultData(
    FLSliceResult data,
    int arg1,
    ffi.Pointer<FLSharedKeys> arg2,
    FLSlice externData,
  ) {
    return _FLDoc_FromResultData(
      data,
      arg1,
      arg2,
      externData,
    );
  }

  late final _FLDoc_FromResultData_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_FromResultData>>(
          'FLDoc_FromResultData');
  late final _dart_FLDoc_FromResultData _FLDoc_FromResultData =
      _FLDoc_FromResultData_ptr.asFunction<_dart_FLDoc_FromResultData>();

  /// Creates an FLDoc from JSON-encoded data. The data is first encoded into Fleece, and the
  /// Fleece data is kept by the doc; the input JSON data is no longer needed after this
  /// function returns.
  ffi.Pointer<FLDoc> FLDoc_FromJSON(
    FLSlice json,
    ffi.Pointer<ffi.Int32> outError,
  ) {
    return _FLDoc_FromJSON(
      json,
      outError,
    );
  }

  late final _FLDoc_FromJSON_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_FromJSON>>('FLDoc_FromJSON');
  late final _dart_FLDoc_FromJSON _FLDoc_FromJSON =
      _FLDoc_FromJSON_ptr.asFunction<_dart_FLDoc_FromJSON>();

  /// Releases a reference to an FLDoc. This must be called once to free an FLDoc you created.
  void FLDoc_Release(
    ffi.Pointer<FLDoc> arg0,
  ) {
    return _FLDoc_Release(
      arg0,
    );
  }

  late final _FLDoc_Release_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_Release>>('FLDoc_Release');
  late final _dart_FLDoc_Release _FLDoc_Release =
      _FLDoc_Release_ptr.asFunction<_dart_FLDoc_Release>();

  /// Adds a reference to an FLDoc. This extends its lifespan until at least such time as you
  /// call FLRelease to remove the reference.
  ffi.Pointer<FLDoc> FLDoc_Retain(
    ffi.Pointer<FLDoc> arg0,
  ) {
    return _FLDoc_Retain(
      arg0,
    );
  }

  late final _FLDoc_Retain_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_Retain>>('FLDoc_Retain');
  late final _dart_FLDoc_Retain _FLDoc_Retain =
      _FLDoc_Retain_ptr.asFunction<_dart_FLDoc_Retain>();

  /// Returns the encoded Fleece data backing the document.
  FLSlice FLDoc_GetData(
    ffi.Pointer<FLDoc> arg0,
  ) {
    return _FLDoc_GetData(
      arg0,
    );
  }

  late final _FLDoc_GetData_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_GetData>>('FLDoc_GetData');
  late final _dart_FLDoc_GetData _FLDoc_GetData =
      _FLDoc_GetData_ptr.asFunction<_dart_FLDoc_GetData>();

  /// Returns the FLSliceResult data owned by the document, if any, else a null slice.
  FLSliceResult FLDoc_GetAllocedData(
    ffi.Pointer<FLDoc> arg0,
  ) {
    return _FLDoc_GetAllocedData(
      arg0,
    );
  }

  late final _FLDoc_GetAllocedData_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_GetAllocedData>>(
          'FLDoc_GetAllocedData');
  late final _dart_FLDoc_GetAllocedData _FLDoc_GetAllocedData =
      _FLDoc_GetAllocedData_ptr.asFunction<_dart_FLDoc_GetAllocedData>();

  /// Returns the root value in the FLDoc, usually an FLDict.
  ffi.Pointer<FLValue> FLDoc_GetRoot(
    ffi.Pointer<FLDoc> arg0,
  ) {
    return _FLDoc_GetRoot(
      arg0,
    );
  }

  late final _FLDoc_GetRoot_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_GetRoot>>('FLDoc_GetRoot');
  late final _dart_FLDoc_GetRoot _FLDoc_GetRoot =
      _FLDoc_GetRoot_ptr.asFunction<_dart_FLDoc_GetRoot>();

  /// Returns the FLSharedKeys used by this FLDoc, as specified when it was created.
  ffi.Pointer<FLSharedKeys> FLDoc_GetSharedKeys(
    ffi.Pointer<FLDoc> arg0,
  ) {
    return _FLDoc_GetSharedKeys(
      arg0,
    );
  }

  late final _FLDoc_GetSharedKeys_ptr =
      _lookup<ffi.NativeFunction<_c_FLDoc_GetSharedKeys>>(
          'FLDoc_GetSharedKeys');
  late final _dart_FLDoc_GetSharedKeys _FLDoc_GetSharedKeys =
      _FLDoc_GetSharedKeys_ptr.asFunction<_dart_FLDoc_GetSharedKeys>();

  /// Looks up the Doc containing the Value, or NULL if the Value was created without a Doc.
  /// Caller must release the FLDoc reference!!
  ffi.Pointer<FLDoc> FLValue_FindDoc(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_FindDoc(
      arg0,
    );
  }

  late final _FLValue_FindDoc_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_FindDoc>>('FLValue_FindDoc');
  late final _dart_FLValue_FindDoc _FLValue_FindDoc =
      _FLValue_FindDoc_ptr.asFunction<_dart_FLValue_FindDoc>();

  /// Returns a pointer to the root value in the encoded data, or NULL if validation failed.
  /// The FLValue, and all values found through it, are only valid as long as the encoded data
  /// remains intact and unchanged.
  ffi.Pointer<FLValue> FLValue_FromData(
    FLSlice data,
    int arg1,
  ) {
    return _FLValue_FromData(
      data,
      arg1,
    );
  }

  late final _FLValue_FromData_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_FromData>>('FLValue_FromData');
  late final _dart_FLValue_FromData _FLValue_FromData =
      _FLValue_FromData_ptr.asFunction<_dart_FLValue_FromData>();

  /// Directly converts JSON data to Fleece-encoded data.
  /// You can then call FLValue_FromData (in kFLTrusted mode) to get the root as a Value.
  FLSliceResult FLData_ConvertJSON(
    FLSlice json,
    ffi.Pointer<ffi.Int32> outError,
  ) {
    return _FLData_ConvertJSON(
      json,
      outError,
    );
  }

  late final _FLData_ConvertJSON_ptr =
      _lookup<ffi.NativeFunction<_c_FLData_ConvertJSON>>('FLData_ConvertJSON');
  late final _dart_FLData_ConvertJSON _FLData_ConvertJSON =
      _FLData_ConvertJSON_ptr.asFunction<_dart_FLData_ConvertJSON>();

  /// Produces a human-readable dump of the Value encoded in the data.
  /// This is only useful if you already know, or want to learn, the encoding format.
  FLSliceResult FLData_Dump(
    FLSlice data,
  ) {
    return _FLData_Dump(
      data,
    );
  }

  late final _FLData_Dump_ptr =
      _lookup<ffi.NativeFunction<_c_FLData_Dump>>('FLData_Dump');
  late final _dart_FLData_Dump _FLData_Dump =
      _FLData_Dump_ptr.asFunction<_dart_FLData_Dump>();

  /// Encodes a Fleece value as JSON (or a JSON fragment.)
  /// Any Data values will become base64-encoded JSON strings.
  FLSliceResult FLValue_ToJSON(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_ToJSON(
      arg0,
    );
  }

  late final _FLValue_ToJSON_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_ToJSON>>('FLValue_ToJSON');
  late final _dart_FLValue_ToJSON _FLValue_ToJSON =
      _FLValue_ToJSON_ptr.asFunction<_dart_FLValue_ToJSON>();

  /// Encodes a Fleece value as JSON5, a more lenient variant of JSON that allows dictionary
  /// keys to be unquoted if they're alphanumeric. This tends to be more readable.
  FLSliceResult FLValue_ToJSON5(
    ffi.Pointer<FLValue> v,
  ) {
    return _FLValue_ToJSON5(
      v,
    );
  }

  late final _FLValue_ToJSON5_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_ToJSON5>>('FLValue_ToJSON5');
  late final _dart_FLValue_ToJSON5 _FLValue_ToJSON5 =
      _FLValue_ToJSON5_ptr.asFunction<_dart_FLValue_ToJSON5>();

  /// Most general Fleece to JSON converter.
  FLSliceResult FLValue_ToJSONX(
    ffi.Pointer<FLValue> v,
    bool json5,
    bool canonicalForm,
  ) {
    return _FLValue_ToJSONX(
      v,
      json5 ? 1 : 0,
      canonicalForm ? 1 : 0,
    );
  }

  late final _FLValue_ToJSONX_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_ToJSONX>>('FLValue_ToJSONX');
  late final _dart_FLValue_ToJSONX _FLValue_ToJSONX =
      _FLValue_ToJSONX_ptr.asFunction<_dart_FLValue_ToJSONX>();

  /// Converts valid JSON5 <https://json5.org> to JSON. Among other things, it converts single
  /// quotes to double, adds missing quotes around dictionary keys, removes trailing commas,
  /// and removes comments.
  /// @note If given invalid JSON5, it will _usually_ return an error, but may just ouput
  /// comparably invalid JSON, in which case the caller's subsequent JSON parsing will
  /// detect the error. The types of errors it overlooks tend to be subtleties of string
  /// or number encoding.
  /// @param json5  The JSON5 to parse
  /// @param outErrorMessage  On failure, the error message will be stored here (if not NULL.)
  /// As this is a \ref FLStringResult, you will be responsible for freeing it.
  /// @param outErrorPos  On a parse error, the byte offset in the input where the error occurred
  /// will be stored here (if it's not NULL.)
  /// @param outError  On failure, the error code will be stored here (if it's not NULL.)
  /// @return  The converted JSON.
  FLSliceResult FLJSON5_ToJSON(
    FLSlice json5,
    ffi.Pointer<FLSliceResult> outErrorMessage,
    ffi.Pointer<ffi.Uint64> outErrorPos,
    ffi.Pointer<ffi.Int32> outError,
  ) {
    return _FLJSON5_ToJSON(
      json5,
      outErrorMessage,
      outErrorPos,
      outError,
    );
  }

  late final _FLJSON5_ToJSON_ptr =
      _lookup<ffi.NativeFunction<_c_FLJSON5_ToJSON>>('FLJSON5_ToJSON');
  late final _dart_FLJSON5_ToJSON _FLJSON5_ToJSON =
      _FLJSON5_ToJSON_ptr.asFunction<_dart_FLJSON5_ToJSON>();

  /// \name Debugging Functions
  /// @{ */
  /// /** Debugging function that returns a C string of JSON. Does not free the string's memory!
  ffi.Pointer<ffi.Int8> FLDump(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLDump(
      arg0,
    );
  }

  late final _FLDump_ptr = _lookup<ffi.NativeFunction<_c_FLDump>>('FLDump');
  late final _dart_FLDump _FLDump = _FLDump_ptr.asFunction<_dart_FLDump>();

  /// Debugging function that returns a C string of JSON. Does not free the string's memory!
  ffi.Pointer<ffi.Int8> FLDumpData(
    FLSlice data,
  ) {
    return _FLDumpData(
      data,
    );
  }

  late final _FLDumpData_ptr =
      _lookup<ffi.NativeFunction<_c_FLDumpData>>('FLDumpData');
  late final _dart_FLDumpData _FLDumpData =
      _FLDumpData_ptr.asFunction<_dart_FLDumpData>();

  /// Returns the data type of an arbitrary Value.
  /// (If the parameter is a NULL pointer, returns `kFLUndefined`.)
  int FLValue_GetType(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_GetType(
      arg0,
    );
  }

  late final _FLValue_GetType_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_GetType>>('FLValue_GetType');
  late final _dart_FLValue_GetType _FLValue_GetType =
      _FLValue_GetType_ptr.asFunction<_dart_FLValue_GetType>();

  /// Returns true if the value is non-NULL and represents an integer.
  bool FLValue_IsInteger(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_IsInteger(
          arg0,
        ) !=
        0;
  }

  late final _FLValue_IsInteger_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_IsInteger>>('FLValue_IsInteger');
  late final _dart_FLValue_IsInteger _FLValue_IsInteger =
      _FLValue_IsInteger_ptr.asFunction<_dart_FLValue_IsInteger>();

  /// Returns true if the value is non-NULL and represents an integer >= 2^63. Such a value can't
  /// be represented in C as an `int64_t`, only a `uint64_t`, so you should access it by calling
  /// `FLValueAsUnsigned`, _not_ FLValueAsInt, which would return  an incorrect (negative)
  /// value.
  bool FLValue_IsUnsigned(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_IsUnsigned(
          arg0,
        ) !=
        0;
  }

  late final _FLValue_IsUnsigned_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_IsUnsigned>>('FLValue_IsUnsigned');
  late final _dart_FLValue_IsUnsigned _FLValue_IsUnsigned =
      _FLValue_IsUnsigned_ptr.asFunction<_dart_FLValue_IsUnsigned>();

  /// Returns true if the value is non-NULL and represents a 64-bit floating-point number.
  bool FLValue_IsDouble(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_IsDouble(
          arg0,
        ) !=
        0;
  }

  late final _FLValue_IsDouble_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_IsDouble>>('FLValue_IsDouble');
  late final _dart_FLValue_IsDouble _FLValue_IsDouble =
      _FLValue_IsDouble_ptr.asFunction<_dart_FLValue_IsDouble>();

  /// Returns a value coerced to boolean. This will be true unless the value is NULL (undefined),
  /// null, false, or zero.
  bool FLValue_AsBool(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsBool(
          arg0,
        ) !=
        0;
  }

  late final _FLValue_AsBool_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsBool>>('FLValue_AsBool');
  late final _dart_FLValue_AsBool _FLValue_AsBool =
      _FLValue_AsBool_ptr.asFunction<_dart_FLValue_AsBool>();

  /// Returns a value coerced to an integer. True and false are returned as 1 and 0, and
  /// floating-point numbers are rounded. All other types are returned as 0.
  /// @warning  Large 64-bit unsigned integers (2^63 and above) will come out wrong. You can
  /// check for these by calling `FLValueIsUnsigned`.
  int FLValue_AsInt(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsInt(
      arg0,
    );
  }

  late final _FLValue_AsInt_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsInt>>('FLValue_AsInt');
  late final _dart_FLValue_AsInt _FLValue_AsInt =
      _FLValue_AsInt_ptr.asFunction<_dart_FLValue_AsInt>();

  /// Returns a value coerced to an unsigned integer.
  /// This is the same as `FLValueAsInt` except that it _can't_ handle negative numbers, but
  /// does correctly return large `uint64_t` values of 2^63 and up.
  int FLValue_AsUnsigned(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsUnsigned(
      arg0,
    );
  }

  late final _FLValue_AsUnsigned_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsUnsigned>>('FLValue_AsUnsigned');
  late final _dart_FLValue_AsUnsigned _FLValue_AsUnsigned =
      _FLValue_AsUnsigned_ptr.asFunction<_dart_FLValue_AsUnsigned>();

  /// Returns a value coerced to a 32-bit floating point number.
  /// True and false are returned as 1.0 and 0.0, and integers are converted to float. All other
  /// types are returned as 0.0.
  /// @warning  Large integers (outside approximately +/- 2^23) will lose precision due to the
  /// limitations of IEEE 32-bit float format.
  double FLValue_AsFloat(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsFloat(
      arg0,
    );
  }

  late final _FLValue_AsFloat_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsFloat>>('FLValue_AsFloat');
  late final _dart_FLValue_AsFloat _FLValue_AsFloat =
      _FLValue_AsFloat_ptr.asFunction<_dart_FLValue_AsFloat>();

  /// Returns a value coerced to a 32-bit floating point number.
  /// True and false are returned as 1.0 and 0.0, and integers are converted to float. All other
  /// types are returned as 0.0.
  /// @warning  Very large integers (outside approximately +/- 2^50) will lose precision due to
  /// the limitations of IEEE 32-bit float format.
  double FLValue_AsDouble(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsDouble(
      arg0,
    );
  }

  late final _FLValue_AsDouble_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsDouble>>('FLValue_AsDouble');
  late final _dart_FLValue_AsDouble _FLValue_AsDouble =
      _FLValue_AsDouble_ptr.asFunction<_dart_FLValue_AsDouble>();

  /// Returns the exact contents of a string value, or null for all other types.
  FLSlice FLValue_AsString(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsString(
      arg0,
    );
  }

  late final _FLValue_AsString_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsString>>('FLValue_AsString');
  late final _dart_FLValue_AsString _FLValue_AsString =
      _FLValue_AsString_ptr.asFunction<_dart_FLValue_AsString>();

  /// Converts a value to a timestamp, in milliseconds since Unix epoch, or INT64_MIN on failure.
  /// - A string is parsed as ISO-8601 (standard JSON date format).
  /// - A number is interpreted as a timestamp and returned as-is.
  int FLValue_AsTimestamp(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsTimestamp(
      arg0,
    );
  }

  late final _FLValue_AsTimestamp_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsTimestamp>>(
          'FLValue_AsTimestamp');
  late final _dart_FLValue_AsTimestamp _FLValue_AsTimestamp =
      _FLValue_AsTimestamp_ptr.asFunction<_dart_FLValue_AsTimestamp>();

  /// Returns the exact contents of a data value, or null for all other types.
  FLSlice FLValue_AsData(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsData(
      arg0,
    );
  }

  late final _FLValue_AsData_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsData>>('FLValue_AsData');
  late final _dart_FLValue_AsData _FLValue_AsData =
      _FLValue_AsData_ptr.asFunction<_dart_FLValue_AsData>();

  /// If a FLValue represents an array, returns it cast to FLArray, else NULL.
  ffi.Pointer<FLArray> FLValue_AsArray(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsArray(
      arg0,
    );
  }

  late final _FLValue_AsArray_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsArray>>('FLValue_AsArray');
  late final _dart_FLValue_AsArray _FLValue_AsArray =
      _FLValue_AsArray_ptr.asFunction<_dart_FLValue_AsArray>();

  /// If a FLValue represents a dictionary, returns it as an FLDict, else NULL.
  ffi.Pointer<FLDict> FLValue_AsDict(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_AsDict(
      arg0,
    );
  }

  late final _FLValue_AsDict_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_AsDict>>('FLValue_AsDict');
  late final _dart_FLValue_AsDict _FLValue_AsDict =
      _FLValue_AsDict_ptr.asFunction<_dart_FLValue_AsDict>();

  /// Returns a string representation of any scalar value. Data values are returned in raw form.
  /// Arrays and dictionaries don't have a representation and will return NULL.
  FLSliceResult FLValue_ToString(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_ToString(
      arg0,
    );
  }

  late final _FLValue_ToString_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_ToString>>('FLValue_ToString');
  late final _dart_FLValue_ToString _FLValue_ToString =
      _FLValue_ToString_ptr.asFunction<_dart_FLValue_ToString>();

  /// Compares two values for equality. This is a deep recursive comparison.
  bool FLValue_IsEqual(
    ffi.Pointer<FLValue> v1,
    ffi.Pointer<FLValue> v2,
  ) {
    return _FLValue_IsEqual(
          v1,
          v2,
        ) !=
        0;
  }

  late final _FLValue_IsEqual_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_IsEqual>>('FLValue_IsEqual');
  late final _dart_FLValue_IsEqual _FLValue_IsEqual =
      _FLValue_IsEqual_ptr.asFunction<_dart_FLValue_IsEqual>();

  /// Returns true if the value is mutable.
  bool FLValue_IsMutable(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_IsMutable(
          arg0,
        ) !=
        0;
  }

  late final _FLValue_IsMutable_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_IsMutable>>('FLValue_IsMutable');
  late final _dart_FLValue_IsMutable _FLValue_IsMutable =
      _FLValue_IsMutable_ptr.asFunction<_dart_FLValue_IsMutable>();

  /// If this value is mutable (and thus heap-based) its ref-count is incremented.
  /// Otherwise, this call does nothing.
  ffi.Pointer<FLValue> FLValue_Retain(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_Retain(
      arg0,
    );
  }

  late final _FLValue_Retain_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_Retain>>('FLValue_Retain');
  late final _dart_FLValue_Retain _FLValue_Retain =
      _FLValue_Retain_ptr.asFunction<_dart_FLValue_Retain>();

  /// If this value is mutable (and thus heap-based) its ref-count is decremented, and if it
  /// reaches zero the value is freed.
  /// If the value is not mutable, this call does nothing.
  void FLValue_Release(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLValue_Release(
      arg0,
    );
  }

  late final _FLValue_Release_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_Release>>('FLValue_Release');
  late final _dart_FLValue_Release _FLValue_Release =
      _FLValue_Release_ptr.asFunction<_dart_FLValue_Release>();

  /// Allocates a string value on the heap. This is rarely needed -- usually you'd just add a string
  /// to a mutable Array or Dict directly using one of their "...SetString" or "...AppendString"
  /// methods.
  ffi.Pointer<FLValue> FLValue_NewString(
    FLSlice arg0,
  ) {
    return _FLValue_NewString(
      arg0,
    );
  }

  late final _FLValue_NewString_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_NewString>>('FLValue_NewString');
  late final _dart_FLValue_NewString _FLValue_NewString =
      _FLValue_NewString_ptr.asFunction<_dart_FLValue_NewString>();

  /// Allocates a data/blob value on the heap. This is rarely needed -- usually you'd just add data
  /// to a mutable Array or Dict directly using one of their "...SetData or "...AppendData"
  /// methods.
  ffi.Pointer<FLValue> FLValue_NewData(
    FLSlice arg0,
  ) {
    return _FLValue_NewData(
      arg0,
    );
  }

  late final _FLValue_NewData_ptr =
      _lookup<ffi.NativeFunction<_c_FLValue_NewData>>('FLValue_NewData');
  late final _dart_FLValue_NewData _FLValue_NewData =
      _FLValue_NewData_ptr.asFunction<_dart_FLValue_NewData>();

  /// Returns the number of items in an array, or 0 if the pointer is NULL.
  int FLArray_Count(
    ffi.Pointer<FLArray> arg0,
  ) {
    return _FLArray_Count(
      arg0,
    );
  }

  late final _FLArray_Count_ptr =
      _lookup<ffi.NativeFunction<_c_FLArray_Count>>('FLArray_Count');
  late final _dart_FLArray_Count _FLArray_Count =
      _FLArray_Count_ptr.asFunction<_dart_FLArray_Count>();

  /// Returns true if an array is empty (or NULL). Depending on the array's representation,
  /// this can be faster than `FLArray_Count(a) == 0`
  bool FLArray_IsEmpty(
    ffi.Pointer<FLArray> arg0,
  ) {
    return _FLArray_IsEmpty(
          arg0,
        ) !=
        0;
  }

  late final _FLArray_IsEmpty_ptr =
      _lookup<ffi.NativeFunction<_c_FLArray_IsEmpty>>('FLArray_IsEmpty');
  late final _dart_FLArray_IsEmpty _FLArray_IsEmpty =
      _FLArray_IsEmpty_ptr.asFunction<_dart_FLArray_IsEmpty>();

  /// If the array is mutable, returns it cast to FLMutableArray, else NULL.
  ffi.Pointer<FLArray> FLArray_AsMutable(
    ffi.Pointer<FLArray> arg0,
  ) {
    return _FLArray_AsMutable(
      arg0,
    );
  }

  late final _FLArray_AsMutable_ptr =
      _lookup<ffi.NativeFunction<_c_FLArray_AsMutable>>('FLArray_AsMutable');
  late final _dart_FLArray_AsMutable _FLArray_AsMutable =
      _FLArray_AsMutable_ptr.asFunction<_dart_FLArray_AsMutable>();

  /// Returns an value at an array index, or NULL if the index is out of range.
  ffi.Pointer<FLValue> FLArray_Get(
    ffi.Pointer<FLArray> arg0,
    int index,
  ) {
    return _FLArray_Get(
      arg0,
      index,
    );
  }

  late final _FLArray_Get_ptr =
      _lookup<ffi.NativeFunction<_c_FLArray_Get>>('FLArray_Get');
  late final _dart_FLArray_Get _FLArray_Get =
      _FLArray_Get_ptr.asFunction<_dart_FLArray_Get>();

  /// Initializes a FLArrayIterator struct to iterate over an array.
  /// Call FLArrayIteratorGetValue to get the first item, then FLArrayIteratorNext.
  void FLArrayIterator_Begin(
    ffi.Pointer<FLArray> arg0,
    ffi.Pointer<FLArrayIterator> arg1,
  ) {
    return _FLArrayIterator_Begin(
      arg0,
      arg1,
    );
  }

  late final _FLArrayIterator_Begin_ptr =
      _lookup<ffi.NativeFunction<_c_FLArrayIterator_Begin>>(
          'FLArrayIterator_Begin');
  late final _dart_FLArrayIterator_Begin _FLArrayIterator_Begin =
      _FLArrayIterator_Begin_ptr.asFunction<_dart_FLArrayIterator_Begin>();

  /// Returns the current value being iterated over.
  ffi.Pointer<FLValue> FLArrayIterator_GetValue(
    ffi.Pointer<FLArrayIterator> arg0,
  ) {
    return _FLArrayIterator_GetValue(
      arg0,
    );
  }

  late final _FLArrayIterator_GetValue_ptr =
      _lookup<ffi.NativeFunction<_c_FLArrayIterator_GetValue>>(
          'FLArrayIterator_GetValue');
  late final _dart_FLArrayIterator_GetValue _FLArrayIterator_GetValue =
      _FLArrayIterator_GetValue_ptr.asFunction<
          _dart_FLArrayIterator_GetValue>();

  /// Returns a value in the array at the given offset from the current value.
  ffi.Pointer<FLValue> FLArrayIterator_GetValueAt(
    ffi.Pointer<FLArrayIterator> arg0,
    int offset,
  ) {
    return _FLArrayIterator_GetValueAt(
      arg0,
      offset,
    );
  }

  late final _FLArrayIterator_GetValueAt_ptr =
      _lookup<ffi.NativeFunction<_c_FLArrayIterator_GetValueAt>>(
          'FLArrayIterator_GetValueAt');
  late final _dart_FLArrayIterator_GetValueAt _FLArrayIterator_GetValueAt =
      _FLArrayIterator_GetValueAt_ptr.asFunction<
          _dart_FLArrayIterator_GetValueAt>();

  /// Returns the number of items remaining to be iterated, including the current one.
  int FLArrayIterator_GetCount(
    ffi.Pointer<FLArrayIterator> arg0,
  ) {
    return _FLArrayIterator_GetCount(
      arg0,
    );
  }

  late final _FLArrayIterator_GetCount_ptr =
      _lookup<ffi.NativeFunction<_c_FLArrayIterator_GetCount>>(
          'FLArrayIterator_GetCount');
  late final _dart_FLArrayIterator_GetCount _FLArrayIterator_GetCount =
      _FLArrayIterator_GetCount_ptr.asFunction<
          _dart_FLArrayIterator_GetCount>();

  /// Advances the iterator to the next value, or returns false if at the end.
  bool FLArrayIterator_Next(
    ffi.Pointer<FLArrayIterator> arg0,
  ) {
    return _FLArrayIterator_Next(
          arg0,
        ) !=
        0;
  }

  late final _FLArrayIterator_Next_ptr =
      _lookup<ffi.NativeFunction<_c_FLArrayIterator_Next>>(
          'FLArrayIterator_Next');
  late final _dart_FLArrayIterator_Next _FLArrayIterator_Next =
      _FLArrayIterator_Next_ptr.asFunction<_dart_FLArrayIterator_Next>();

  /// Creates a new mutable Array that's a copy of the source Array.
  /// Its initial ref-count is 1, so a call to FLMutableArray_Release will free it.
  ///
  /// Copying an immutable Array is very cheap (only one small allocation) unless the flag
  /// kFLCopyImmutables is set.
  ///
  /// Copying a mutable Array is cheap if it's a shallow copy, but if `deepCopy` is true,
  /// nested mutable Arrays and Dicts are also copied, recursively; if kFLCopyImmutables is
  /// also set, immutable values are also copied.
  ///
  /// If the source Array is NULL, then NULL is returned.
  ffi.Pointer<FLArray> FLArray_MutableCopy(
    ffi.Pointer<FLArray> arg0,
    int arg1,
  ) {
    return _FLArray_MutableCopy(
      arg0,
      arg1,
    );
  }

  late final _FLArray_MutableCopy_ptr =
      _lookup<ffi.NativeFunction<_c_FLArray_MutableCopy>>(
          'FLArray_MutableCopy');
  late final _dart_FLArray_MutableCopy _FLArray_MutableCopy =
      _FLArray_MutableCopy_ptr.asFunction<_dart_FLArray_MutableCopy>();

  /// Creates a new empty mutable Array.
  /// Its initial ref-count is 1, so a call to FLMutableArray_Free will free it.
  ffi.Pointer<FLArray> FLMutableArray_New() {
    return _FLMutableArray_New();
  }

  late final _FLMutableArray_New_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_New>>('FLMutableArray_New');
  late final _dart_FLMutableArray_New _FLMutableArray_New =
      _FLMutableArray_New_ptr.asFunction<_dart_FLMutableArray_New>();

  /// If the Array was created by FLArray_MutableCopy, returns the original source Array.
  ffi.Pointer<FLArray> FLMutableArray_GetSource(
    ffi.Pointer<FLArray> arg0,
  ) {
    return _FLMutableArray_GetSource(
      arg0,
    );
  }

  late final _FLMutableArray_GetSource_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_GetSource>>(
          'FLMutableArray_GetSource');
  late final _dart_FLMutableArray_GetSource _FLMutableArray_GetSource =
      _FLMutableArray_GetSource_ptr.asFunction<
          _dart_FLMutableArray_GetSource>();

  /// Returns true if the Array has been changed from the source it was copied from.
  bool FLMutableArray_IsChanged(
    ffi.Pointer<FLArray> arg0,
  ) {
    return _FLMutableArray_IsChanged(
          arg0,
        ) !=
        0;
  }

  late final _FLMutableArray_IsChanged_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_IsChanged>>(
          'FLMutableArray_IsChanged');
  late final _dart_FLMutableArray_IsChanged _FLMutableArray_IsChanged =
      _FLMutableArray_IsChanged_ptr.asFunction<
          _dart_FLMutableArray_IsChanged>();

  /// Sets or clears the mutable Array's "changed" flag.
  void FLMutableArray_SetChanged(
    ffi.Pointer<FLArray> arg0,
    bool arg1,
  ) {
    return _FLMutableArray_SetChanged(
      arg0,
      arg1 ? 1 : 0,
    );
  }

  late final _FLMutableArray_SetChanged_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_SetChanged>>(
          'FLMutableArray_SetChanged');
  late final _dart_FLMutableArray_SetChanged _FLMutableArray_SetChanged =
      _FLMutableArray_SetChanged_ptr.asFunction<
          _dart_FLMutableArray_SetChanged>();

  /// Inserts a contiguous range of JSON `null` values into the array.
  /// @param array  The array to operate on.
  /// @param firstIndex  The zero-based index of the first value to be inserted.
  /// @param count  The number of items to insert.
  void FLMutableArray_Insert(
    ffi.Pointer<FLArray> array,
    int firstIndex,
    int count,
  ) {
    return _FLMutableArray_Insert(
      array,
      firstIndex,
      count,
    );
  }

  late final _FLMutableArray_Insert_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_Insert>>(
          'FLMutableArray_Insert');
  late final _dart_FLMutableArray_Insert _FLMutableArray_Insert =
      _FLMutableArray_Insert_ptr.asFunction<_dart_FLMutableArray_Insert>();

  /// Removes contiguous items from the array.
  /// @param array  The array to operate on.
  /// @param firstIndex  The zero-based index of the first item to remove.
  /// @param count  The number of items to remove.
  void FLMutableArray_Remove(
    ffi.Pointer<FLArray> array,
    int firstIndex,
    int count,
  ) {
    return _FLMutableArray_Remove(
      array,
      firstIndex,
      count,
    );
  }

  late final _FLMutableArray_Remove_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_Remove>>(
          'FLMutableArray_Remove');
  late final _dart_FLMutableArray_Remove _FLMutableArray_Remove =
      _FLMutableArray_Remove_ptr.asFunction<_dart_FLMutableArray_Remove>();

  /// Changes the size of an array.
  /// If the new size is larger, the array is padded with JSON `null` values.
  /// If it's smaller, values are removed from the end.
  void FLMutableArray_Resize(
    ffi.Pointer<FLArray> array,
    int size,
  ) {
    return _FLMutableArray_Resize(
      array,
      size,
    );
  }

  late final _FLMutableArray_Resize_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_Resize>>(
          'FLMutableArray_Resize');
  late final _dart_FLMutableArray_Resize _FLMutableArray_Resize =
      _FLMutableArray_Resize_ptr.asFunction<_dart_FLMutableArray_Resize>();

  /// Convenience function for getting an array-valued property in mutable form.
  /// - If the value for the key is not an array, returns NULL.
  /// - If the value is a mutable array, returns it.
  /// - If the value is an immutable array, this function makes a mutable copy, assigns the
  /// copy as the property value, and returns the copy.
  ffi.Pointer<FLArray> FLMutableArray_GetMutableArray(
    ffi.Pointer<FLArray> arg0,
    int index,
  ) {
    return _FLMutableArray_GetMutableArray(
      arg0,
      index,
    );
  }

  late final _FLMutableArray_GetMutableArray_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_GetMutableArray>>(
          'FLMutableArray_GetMutableArray');
  late final _dart_FLMutableArray_GetMutableArray
      _FLMutableArray_GetMutableArray = _FLMutableArray_GetMutableArray_ptr
          .asFunction<_dart_FLMutableArray_GetMutableArray>();

  /// Convenience function for getting an array-valued property in mutable form.
  /// - If the value for the key is not an array, returns NULL.
  /// - If the value is a mutable array, returns it.
  /// - If the value is an immutable array, this function makes a mutable copy, assigns the
  /// copy as the property value, and returns the copy.
  ffi.Pointer<FLDict> FLMutableArray_GetMutableDict(
    ffi.Pointer<FLArray> arg0,
    int index,
  ) {
    return _FLMutableArray_GetMutableDict(
      arg0,
      index,
    );
  }

  late final _FLMutableArray_GetMutableDict_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_GetMutableDict>>(
          'FLMutableArray_GetMutableDict');
  late final _dart_FLMutableArray_GetMutableDict
      _FLMutableArray_GetMutableDict = _FLMutableArray_GetMutableDict_ptr
          .asFunction<_dart_FLMutableArray_GetMutableDict>();

  /// Returns the number of items in a dictionary, or 0 if the pointer is NULL.
  int FLDict_Count(
    ffi.Pointer<FLDict> arg0,
  ) {
    return _FLDict_Count(
      arg0,
    );
  }

  late final _FLDict_Count_ptr =
      _lookup<ffi.NativeFunction<_c_FLDict_Count>>('FLDict_Count');
  late final _dart_FLDict_Count _FLDict_Count =
      _FLDict_Count_ptr.asFunction<_dart_FLDict_Count>();

  /// Returns true if a dictionary is empty (or NULL). Depending on the dictionary's
  /// representation, this can be faster than `FLDict_Count(a) == 0`
  bool FLDict_IsEmpty(
    ffi.Pointer<FLDict> arg0,
  ) {
    return _FLDict_IsEmpty(
          arg0,
        ) !=
        0;
  }

  late final _FLDict_IsEmpty_ptr =
      _lookup<ffi.NativeFunction<_c_FLDict_IsEmpty>>('FLDict_IsEmpty');
  late final _dart_FLDict_IsEmpty _FLDict_IsEmpty =
      _FLDict_IsEmpty_ptr.asFunction<_dart_FLDict_IsEmpty>();

  /// If the dictionary is mutable, returns it cast to FLMutableDict, else NULL.
  ffi.Pointer<FLDict> FLDict_AsMutable(
    ffi.Pointer<FLDict> arg0,
  ) {
    return _FLDict_AsMutable(
      arg0,
    );
  }

  late final _FLDict_AsMutable_ptr =
      _lookup<ffi.NativeFunction<_c_FLDict_AsMutable>>('FLDict_AsMutable');
  late final _dart_FLDict_AsMutable _FLDict_AsMutable =
      _FLDict_AsMutable_ptr.asFunction<_dart_FLDict_AsMutable>();

  /// Looks up a key in a dictionary, returning its value.
  /// Returns NULL if the value is not found or if the dictionary is NULL.
  ffi.Pointer<FLValue> FLDict_Get(
    ffi.Pointer<FLDict> arg0,
    FLSlice keyString,
  ) {
    return _FLDict_Get(
      arg0,
      keyString,
    );
  }

  late final _FLDict_Get_ptr =
      _lookup<ffi.NativeFunction<_c_FLDict_Get>>('FLDict_Get');
  late final _dart_FLDict_Get _FLDict_Get =
      _FLDict_Get_ptr.asFunction<_dart_FLDict_Get>();

  /// Initializes a FLDictIterator struct to iterate over a dictionary.
  /// Call FLDictIterator_GetKey and FLDictIterator_GetValue to get the first item,
  /// then FLDictIterator_Next.
  void FLDictIterator_Begin(
    ffi.Pointer<FLDict> arg0,
    ffi.Pointer<FLDictIterator> arg1,
  ) {
    return _FLDictIterator_Begin(
      arg0,
      arg1,
    );
  }

  late final _FLDictIterator_Begin_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictIterator_Begin>>(
          'FLDictIterator_Begin');
  late final _dart_FLDictIterator_Begin _FLDictIterator_Begin =
      _FLDictIterator_Begin_ptr.asFunction<_dart_FLDictIterator_Begin>();

  /// Returns the current key being iterated over. This Value will be a string or an integer.
  ffi.Pointer<FLValue> FLDictIterator_GetKey(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_GetKey(
      arg0,
    );
  }

  late final _FLDictIterator_GetKey_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictIterator_GetKey>>(
          'FLDictIterator_GetKey');
  late final _dart_FLDictIterator_GetKey _FLDictIterator_GetKey =
      _FLDictIterator_GetKey_ptr.asFunction<_dart_FLDictIterator_GetKey>();

  /// Returns the current key's string value.
  FLSlice FLDictIterator_GetKeyString(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_GetKeyString(
      arg0,
    );
  }

  late final _FLDictIterator_GetKeyString_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictIterator_GetKeyString>>(
          'FLDictIterator_GetKeyString');
  late final _dart_FLDictIterator_GetKeyString _FLDictIterator_GetKeyString =
      _FLDictIterator_GetKeyString_ptr.asFunction<
          _dart_FLDictIterator_GetKeyString>();

  /// Returns the current value being iterated over.
  ffi.Pointer<FLValue> FLDictIterator_GetValue(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_GetValue(
      arg0,
    );
  }

  late final _FLDictIterator_GetValue_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictIterator_GetValue>>(
          'FLDictIterator_GetValue');
  late final _dart_FLDictIterator_GetValue _FLDictIterator_GetValue =
      _FLDictIterator_GetValue_ptr.asFunction<_dart_FLDictIterator_GetValue>();

  /// Returns the number of items remaining to be iterated, including the current one.
  int FLDictIterator_GetCount(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_GetCount(
      arg0,
    );
  }

  late final _FLDictIterator_GetCount_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictIterator_GetCount>>(
          'FLDictIterator_GetCount');
  late final _dart_FLDictIterator_GetCount _FLDictIterator_GetCount =
      _FLDictIterator_GetCount_ptr.asFunction<_dart_FLDictIterator_GetCount>();

  /// Advances the iterator to the next value, or returns false if at the end.
  bool FLDictIterator_Next(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_Next(
          arg0,
        ) !=
        0;
  }

  late final _FLDictIterator_Next_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictIterator_Next>>(
          'FLDictIterator_Next');
  late final _dart_FLDictIterator_Next _FLDictIterator_Next =
      _FLDictIterator_Next_ptr.asFunction<_dart_FLDictIterator_Next>();

  /// Cleans up after an iterator. Only needed if (a) the dictionary is a delta, and
  /// (b) you stop iterating before the end (i.e. before FLDictIterator_Next returns false.)
  void FLDictIterator_End(
    ffi.Pointer<FLDictIterator> arg0,
  ) {
    return _FLDictIterator_End(
      arg0,
    );
  }

  late final _FLDictIterator_End_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictIterator_End>>('FLDictIterator_End');
  late final _dart_FLDictIterator_End _FLDictIterator_End =
      _FLDictIterator_End_ptr.asFunction<_dart_FLDictIterator_End>();

  /// Initializes an FLDictKey struct with a key string.
  /// @warning  The input string's memory MUST remain valid for as long as the FLDictKey is in
  /// use! (The FLDictKey stores a pointer to the string, but does not copy it.)
  /// @param string  The key string (UTF-8).
  /// @return  An initialized FLDictKey struct.
  FLDictKey FLDictKey_Init(
    FLSlice string,
  ) {
    return _FLDictKey_Init(
      string,
    );
  }

  late final _FLDictKey_Init_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictKey_Init>>('FLDictKey_Init');
  late final _dart_FLDictKey_Init _FLDictKey_Init =
      _FLDictKey_Init_ptr.asFunction<_dart_FLDictKey_Init>();

  /// Returns the string value of the key (which it was initialized with.)
  FLSlice FLDictKey_GetString(
    ffi.Pointer<FLDictKey> arg0,
  ) {
    return _FLDictKey_GetString(
      arg0,
    );
  }

  late final _FLDictKey_GetString_ptr =
      _lookup<ffi.NativeFunction<_c_FLDictKey_GetString>>(
          'FLDictKey_GetString');
  late final _dart_FLDictKey_GetString _FLDictKey_GetString =
      _FLDictKey_GetString_ptr.asFunction<_dart_FLDictKey_GetString>();

  /// Looks up a key in a dictionary using an FLDictKey. If the key is found, "hint" data will
  /// be stored inside the FLDictKey that will speed up subsequent lookups.
  ffi.Pointer<FLValue> FLDict_GetWithKey(
    ffi.Pointer<FLDict> arg0,
    ffi.Pointer<FLDictKey> arg1,
  ) {
    return _FLDict_GetWithKey(
      arg0,
      arg1,
    );
  }

  late final _FLDict_GetWithKey_ptr =
      _lookup<ffi.NativeFunction<_c_FLDict_GetWithKey>>('FLDict_GetWithKey');
  late final _dart_FLDict_GetWithKey _FLDict_GetWithKey =
      _FLDict_GetWithKey_ptr.asFunction<_dart_FLDict_GetWithKey>();

  /// Creates a new mutable Dict that's a copy of the source Dict.
  /// Its initial ref-count is 1, so a call to FLMutableDict_Release will free it.
  ///
  /// Copying an immutable Dict is very cheap (only one small allocation.) The `deepCopy` flag
  /// is ignored.
  ///
  /// Copying a mutable Dict is cheap if it's a shallow copy, but if `deepCopy` is true,
  /// nested mutable Dicts and Arrays are also copied, recursively.
  ///
  /// If the source dict is NULL, then NULL is returned.
  ffi.Pointer<FLDict> FLDict_MutableCopy(
    ffi.Pointer<FLDict> source,
    int arg1,
  ) {
    return _FLDict_MutableCopy(
      source,
      arg1,
    );
  }

  late final _FLDict_MutableCopy_ptr =
      _lookup<ffi.NativeFunction<_c_FLDict_MutableCopy>>('FLDict_MutableCopy');
  late final _dart_FLDict_MutableCopy _FLDict_MutableCopy =
      _FLDict_MutableCopy_ptr.asFunction<_dart_FLDict_MutableCopy>();

  /// Creates a new empty mutable Dict.
  /// Its initial ref-count is 1, so a call to FLMutableDict_Free will free it.
  ffi.Pointer<FLDict> FLMutableDict_New() {
    return _FLMutableDict_New();
  }

  late final _FLMutableDict_New_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_New>>('FLMutableDict_New');
  late final _dart_FLMutableDict_New _FLMutableDict_New =
      _FLMutableDict_New_ptr.asFunction<_dart_FLMutableDict_New>();

  /// If the Dict was created by FLDict_MutableCopy, returns the original source Dict.
  ffi.Pointer<FLDict> FLMutableDict_GetSource(
    ffi.Pointer<FLDict> arg0,
  ) {
    return _FLMutableDict_GetSource(
      arg0,
    );
  }

  late final _FLMutableDict_GetSource_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_GetSource>>(
          'FLMutableDict_GetSource');
  late final _dart_FLMutableDict_GetSource _FLMutableDict_GetSource =
      _FLMutableDict_GetSource_ptr.asFunction<_dart_FLMutableDict_GetSource>();

  /// Returns true if the Dict has been changed from the source it was copied from.
  bool FLMutableDict_IsChanged(
    ffi.Pointer<FLDict> arg0,
  ) {
    return _FLMutableDict_IsChanged(
          arg0,
        ) !=
        0;
  }

  late final _FLMutableDict_IsChanged_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_IsChanged>>(
          'FLMutableDict_IsChanged');
  late final _dart_FLMutableDict_IsChanged _FLMutableDict_IsChanged =
      _FLMutableDict_IsChanged_ptr.asFunction<_dart_FLMutableDict_IsChanged>();

  /// Sets or clears the mutable Dict's "changed" flag.
  void FLMutableDict_SetChanged(
    ffi.Pointer<FLDict> arg0,
    bool arg1,
  ) {
    return _FLMutableDict_SetChanged(
      arg0,
      arg1 ? 1 : 0,
    );
  }

  late final _FLMutableDict_SetChanged_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_SetChanged>>(
          'FLMutableDict_SetChanged');
  late final _dart_FLMutableDict_SetChanged _FLMutableDict_SetChanged =
      _FLMutableDict_SetChanged_ptr.asFunction<
          _dart_FLMutableDict_SetChanged>();

  /// Removes the value for a key.
  void FLMutableDict_Remove(
    ffi.Pointer<FLDict> arg0,
    FLSlice key,
  ) {
    return _FLMutableDict_Remove(
      arg0,
      key,
    );
  }

  late final _FLMutableDict_Remove_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_Remove>>(
          'FLMutableDict_Remove');
  late final _dart_FLMutableDict_Remove _FLMutableDict_Remove =
      _FLMutableDict_Remove_ptr.asFunction<_dart_FLMutableDict_Remove>();

  /// Removes all keys and values.
  void FLMutableDict_RemoveAll(
    ffi.Pointer<FLDict> arg0,
  ) {
    return _FLMutableDict_RemoveAll(
      arg0,
    );
  }

  late final _FLMutableDict_RemoveAll_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_RemoveAll>>(
          'FLMutableDict_RemoveAll');
  late final _dart_FLMutableDict_RemoveAll _FLMutableDict_RemoveAll =
      _FLMutableDict_RemoveAll_ptr.asFunction<_dart_FLMutableDict_RemoveAll>();

  /// Convenience function for getting an array-valued property in mutable form.
  /// - If the value for the key is not an array, returns NULL.
  /// - If the value is a mutable array, returns it.
  /// - If the value is an immutable array, this function makes a mutable copy, assigns the
  /// copy as the property value, and returns the copy.
  ffi.Pointer<FLArray> FLMutableDict_GetMutableArray(
    ffi.Pointer<FLDict> arg0,
    FLSlice key,
  ) {
    return _FLMutableDict_GetMutableArray(
      arg0,
      key,
    );
  }

  late final _FLMutableDict_GetMutableArray_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_GetMutableArray>>(
          'FLMutableDict_GetMutableArray');
  late final _dart_FLMutableDict_GetMutableArray
      _FLMutableDict_GetMutableArray = _FLMutableDict_GetMutableArray_ptr
          .asFunction<_dart_FLMutableDict_GetMutableArray>();

  /// Convenience function for getting a dict-valued property in mutable form.
  /// - If the value for the key is not a dict, returns NULL.
  /// - If the value is a mutable dict, returns it.
  /// - If the value is an immutable dict, this function makes a mutable copy, assigns the
  /// copy as the property value, and returns the copy.
  ffi.Pointer<FLDict> FLMutableDict_GetMutableDict(
    ffi.Pointer<FLDict> arg0,
    FLSlice key,
  ) {
    return _FLMutableDict_GetMutableDict(
      arg0,
      key,
    );
  }

  late final _FLMutableDict_GetMutableDict_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_GetMutableDict>>(
          'FLMutableDict_GetMutableDict');
  late final _dart_FLMutableDict_GetMutableDict _FLMutableDict_GetMutableDict =
      _FLMutableDict_GetMutableDict_ptr.asFunction<
          _dart_FLMutableDict_GetMutableDict>();

  /// Creates a FLDeepIterator to iterate over a dictionary.
  /// Call FLDeepIterator_GetKey and FLDeepIterator_GetValue to get the first item,
  /// then FLDeepIterator_Next.
  ffi.Pointer<FLDeepIterator> FLDeepIterator_New(
    ffi.Pointer<FLValue> arg0,
  ) {
    return _FLDeepIterator_New(
      arg0,
    );
  }

  late final _FLDeepIterator_New_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_New>>('FLDeepIterator_New');
  late final _dart_FLDeepIterator_New _FLDeepIterator_New =
      _FLDeepIterator_New_ptr.asFunction<_dart_FLDeepIterator_New>();

  void FLDeepIterator_Free(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_Free(
      arg0,
    );
  }

  late final _FLDeepIterator_Free_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_Free>>(
          'FLDeepIterator_Free');
  late final _dart_FLDeepIterator_Free _FLDeepIterator_Free =
      _FLDeepIterator_Free_ptr.asFunction<_dart_FLDeepIterator_Free>();

  /// Returns the current value being iterated over. or NULL at the end of iteration.
  ffi.Pointer<FLValue> FLDeepIterator_GetValue(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_GetValue(
      arg0,
    );
  }

  late final _FLDeepIterator_GetValue_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetValue>>(
          'FLDeepIterator_GetValue');
  late final _dart_FLDeepIterator_GetValue _FLDeepIterator_GetValue =
      _FLDeepIterator_GetValue_ptr.asFunction<_dart_FLDeepIterator_GetValue>();

  /// Returns the parent/container of the current value, or NULL at the end of iteration.
  ffi.Pointer<FLValue> FLDeepIterator_GetParent(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_GetParent(
      arg0,
    );
  }

  late final _FLDeepIterator_GetParent_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetParent>>(
          'FLDeepIterator_GetParent');
  late final _dart_FLDeepIterator_GetParent _FLDeepIterator_GetParent =
      _FLDeepIterator_GetParent_ptr.asFunction<
          _dart_FLDeepIterator_GetParent>();

  /// Returns the key of the current value in its parent, or an empty slice if not in a dictionary.
  FLSlice FLDeepIterator_GetKey(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_GetKey(
      arg0,
    );
  }

  late final _FLDeepIterator_GetKey_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetKey>>(
          'FLDeepIterator_GetKey');
  late final _dart_FLDeepIterator_GetKey _FLDeepIterator_GetKey =
      _FLDeepIterator_GetKey_ptr.asFunction<_dart_FLDeepIterator_GetKey>();

  /// Returns the array index of the current value in its parent, or 0 if not in an array.
  int FLDeepIterator_GetIndex(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_GetIndex(
      arg0,
    );
  }

  late final _FLDeepIterator_GetIndex_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetIndex>>(
          'FLDeepIterator_GetIndex');
  late final _dart_FLDeepIterator_GetIndex _FLDeepIterator_GetIndex =
      _FLDeepIterator_GetIndex_ptr.asFunction<_dart_FLDeepIterator_GetIndex>();

  /// Returns the current depth in the hierarchy, starting at 1 for the top-level children.
  int FLDeepIterator_GetDepth(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_GetDepth(
      arg0,
    );
  }

  late final _FLDeepIterator_GetDepth_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetDepth>>(
          'FLDeepIterator_GetDepth');
  late final _dart_FLDeepIterator_GetDepth _FLDeepIterator_GetDepth =
      _FLDeepIterator_GetDepth_ptr.asFunction<_dart_FLDeepIterator_GetDepth>();

  /// Tells the iterator to skip the children of the current value.
  void FLDeepIterator_SkipChildren(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_SkipChildren(
      arg0,
    );
  }

  late final _FLDeepIterator_SkipChildren_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_SkipChildren>>(
          'FLDeepIterator_SkipChildren');
  late final _dart_FLDeepIterator_SkipChildren _FLDeepIterator_SkipChildren =
      _FLDeepIterator_SkipChildren_ptr.asFunction<
          _dart_FLDeepIterator_SkipChildren>();

  /// Advances the iterator to the next value, or returns false if at the end.
  bool FLDeepIterator_Next(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_Next(
          arg0,
        ) !=
        0;
  }

  late final _FLDeepIterator_Next_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_Next>>(
          'FLDeepIterator_Next');
  late final _dart_FLDeepIterator_Next _FLDeepIterator_Next =
      _FLDeepIterator_Next_ptr.asFunction<_dart_FLDeepIterator_Next>();

  /// Returns the path as an array of FLPathComponents.
  void FLDeepIterator_GetPath(
    ffi.Pointer<FLDeepIterator> arg0,
    ffi.Pointer<ffi.Pointer<FLPathComponent>> outPath,
    ffi.Pointer<ffi.Uint64> outDepth,
  ) {
    return _FLDeepIterator_GetPath(
      arg0,
      outPath,
      outDepth,
    );
  }

  late final _FLDeepIterator_GetPath_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetPath>>(
          'FLDeepIterator_GetPath');
  late final _dart_FLDeepIterator_GetPath _FLDeepIterator_GetPath =
      _FLDeepIterator_GetPath_ptr.asFunction<_dart_FLDeepIterator_GetPath>();

  /// Returns the current path in JavaScript format.
  FLSliceResult FLDeepIterator_GetPathString(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_GetPathString(
      arg0,
    );
  }

  late final _FLDeepIterator_GetPathString_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetPathString>>(
          'FLDeepIterator_GetPathString');
  late final _dart_FLDeepIterator_GetPathString _FLDeepIterator_GetPathString =
      _FLDeepIterator_GetPathString_ptr.asFunction<
          _dart_FLDeepIterator_GetPathString>();

  /// Returns the current path in JSONPointer format (RFC 6901).
  FLSliceResult FLDeepIterator_GetJSONPointer(
    ffi.Pointer<FLDeepIterator> arg0,
  ) {
    return _FLDeepIterator_GetJSONPointer(
      arg0,
    );
  }

  late final _FLDeepIterator_GetJSONPointer_ptr =
      _lookup<ffi.NativeFunction<_c_FLDeepIterator_GetJSONPointer>>(
          'FLDeepIterator_GetJSONPointer');
  late final _dart_FLDeepIterator_GetJSONPointer
      _FLDeepIterator_GetJSONPointer = _FLDeepIterator_GetJSONPointer_ptr
          .asFunction<_dart_FLDeepIterator_GetJSONPointer>();

  /// Creates a new FLKeyPath object by compiling a path specifier string.
  ffi.Pointer<FLKeyPath> FLKeyPath_New(
    FLSlice specifier,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _FLKeyPath_New(
      specifier,
      error,
    );
  }

  late final _FLKeyPath_New_ptr =
      _lookup<ffi.NativeFunction<_c_FLKeyPath_New>>('FLKeyPath_New');
  late final _dart_FLKeyPath_New _FLKeyPath_New =
      _FLKeyPath_New_ptr.asFunction<_dart_FLKeyPath_New>();

  /// Frees a compiled FLKeyPath object. (It's ok to pass NULL.)
  void FLKeyPath_Free(
    ffi.Pointer<FLKeyPath> arg0,
  ) {
    return _FLKeyPath_Free(
      arg0,
    );
  }

  late final _FLKeyPath_Free_ptr =
      _lookup<ffi.NativeFunction<_c_FLKeyPath_Free>>('FLKeyPath_Free');
  late final _dart_FLKeyPath_Free _FLKeyPath_Free =
      _FLKeyPath_Free_ptr.asFunction<_dart_FLKeyPath_Free>();

  /// Evaluates a compiled key-path for a given Fleece root object.
  ffi.Pointer<FLValue> FLKeyPath_Eval(
    ffi.Pointer<FLKeyPath> arg0,
    ffi.Pointer<FLValue> root,
  ) {
    return _FLKeyPath_Eval(
      arg0,
      root,
    );
  }

  late final _FLKeyPath_Eval_ptr =
      _lookup<ffi.NativeFunction<_c_FLKeyPath_Eval>>('FLKeyPath_Eval');
  late final _dart_FLKeyPath_Eval _FLKeyPath_Eval =
      _FLKeyPath_Eval_ptr.asFunction<_dart_FLKeyPath_Eval>();

  /// Evaluates a key-path from a specifier string, for a given Fleece root object.
  /// If you only need to evaluate the path once, this is a bit faster than creating an
  /// FLKeyPath object, evaluating, then freeing it.
  ffi.Pointer<FLValue> FLKeyPath_EvalOnce(
    FLSlice specifier,
    ffi.Pointer<FLValue> root,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _FLKeyPath_EvalOnce(
      specifier,
      root,
      error,
    );
  }

  late final _FLKeyPath_EvalOnce_ptr =
      _lookup<ffi.NativeFunction<_c_FLKeyPath_EvalOnce>>('FLKeyPath_EvalOnce');
  late final _dart_FLKeyPath_EvalOnce _FLKeyPath_EvalOnce =
      _FLKeyPath_EvalOnce_ptr.asFunction<_dart_FLKeyPath_EvalOnce>();

  /// Returns a path in string form.
  FLSliceResult FLKeyPath_ToString(
    ffi.Pointer<FLKeyPath> path,
  ) {
    return _FLKeyPath_ToString(
      path,
    );
  }

  late final _FLKeyPath_ToString_ptr =
      _lookup<ffi.NativeFunction<_c_FLKeyPath_ToString>>('FLKeyPath_ToString');
  late final _dart_FLKeyPath_ToString _FLKeyPath_ToString =
      _FLKeyPath_ToString_ptr.asFunction<_dart_FLKeyPath_ToString>();

  /// Equality test.
  bool FLKeyPath_Equals(
    ffi.Pointer<FLKeyPath> path1,
    ffi.Pointer<FLKeyPath> path2,
  ) {
    return _FLKeyPath_Equals(
          path1,
          path2,
        ) !=
        0;
  }

  late final _FLKeyPath_Equals_ptr =
      _lookup<ffi.NativeFunction<_c_FLKeyPath_Equals>>('FLKeyPath_Equals');
  late final _dart_FLKeyPath_Equals _FLKeyPath_Equals =
      _FLKeyPath_Equals_ptr.asFunction<_dart_FLKeyPath_Equals>();

  /// Returns an element of a path, either a key or an array index.
  bool FLKeyPath_GetElement(
    ffi.Pointer<FLKeyPath> arg0,
    int i,
    ffi.Pointer<FLSlice> outDictKey,
    ffi.Pointer<ffi.Int32> outArrayIndex,
  ) {
    return _FLKeyPath_GetElement(
          arg0,
          i,
          outDictKey,
          outArrayIndex,
        ) !=
        0;
  }

  late final _FLKeyPath_GetElement_ptr =
      _lookup<ffi.NativeFunction<_c_FLKeyPath_GetElement>>(
          'FLKeyPath_GetElement');
  late final _dart_FLKeyPath_GetElement _FLKeyPath_GetElement =
      _FLKeyPath_GetElement_ptr.asFunction<_dart_FLKeyPath_GetElement>();

  /// Creates a new empty FLSharedKeys object, which must eventually be released.
  ffi.Pointer<FLSharedKeys> FLSharedKeys_New() {
    return _FLSharedKeys_New();
  }

  late final _FLSharedKeys_New_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_New>>('FLSharedKeys_New');
  late final _dart_FLSharedKeys_New _FLSharedKeys_New =
      _FLSharedKeys_New_ptr.asFunction<_dart_FLSharedKeys_New>();

  ffi.Pointer<FLSharedKeys> FLSharedKeys_NewWithRead(
    ffi.Pointer<ffi.NativeFunction<FLSharedKeysReadCallback>> arg0,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _FLSharedKeys_NewWithRead(
      arg0,
      context,
    );
  }

  late final _FLSharedKeys_NewWithRead_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_NewWithRead>>(
          'FLSharedKeys_NewWithRead');
  late final _dart_FLSharedKeys_NewWithRead _FLSharedKeys_NewWithRead =
      _FLSharedKeys_NewWithRead_ptr.asFunction<
          _dart_FLSharedKeys_NewWithRead>();

  /// Returns a data blob containing the current state (all the keys and their integers.)
  FLSliceResult FLSharedKeys_GetStateData(
    ffi.Pointer<FLSharedKeys> arg0,
  ) {
    return _FLSharedKeys_GetStateData(
      arg0,
    );
  }

  late final _FLSharedKeys_GetStateData_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_GetStateData>>(
          'FLSharedKeys_GetStateData');
  late final _dart_FLSharedKeys_GetStateData _FLSharedKeys_GetStateData =
      _FLSharedKeys_GetStateData_ptr.asFunction<
          _dart_FLSharedKeys_GetStateData>();

  /// Updates an FLSharedKeys with saved state data created by \ref FLSharedKeys_GetStateData.
  bool FLSharedKeys_LoadStateData(
    ffi.Pointer<FLSharedKeys> arg0,
    FLSlice arg1,
  ) {
    return _FLSharedKeys_LoadStateData(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLSharedKeys_LoadStateData_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_LoadStateData>>(
          'FLSharedKeys_LoadStateData');
  late final _dart_FLSharedKeys_LoadStateData _FLSharedKeys_LoadStateData =
      _FLSharedKeys_LoadStateData_ptr.asFunction<
          _dart_FLSharedKeys_LoadStateData>();

  /// Writes the current state to a Fleece encoder as a single value,
  /// which can later be decoded and passed to \ref FLSharedKeys_LoadState.
  void FLSharedKeys_WriteState(
    ffi.Pointer<FLSharedKeys> arg0,
    ffi.Pointer<FLEncoder> arg1,
  ) {
    return _FLSharedKeys_WriteState(
      arg0,
      arg1,
    );
  }

  late final _FLSharedKeys_WriteState_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_WriteState>>(
          'FLSharedKeys_WriteState');
  late final _dart_FLSharedKeys_WriteState _FLSharedKeys_WriteState =
      _FLSharedKeys_WriteState_ptr.asFunction<_dart_FLSharedKeys_WriteState>();

  /// Updates an FLSharedKeys object with saved state, a Fleece value previously written by
  /// \ref FLSharedKeys_WriteState.
  bool FLSharedKeys_LoadState(
    ffi.Pointer<FLSharedKeys> arg0,
    ffi.Pointer<FLValue> arg1,
  ) {
    return _FLSharedKeys_LoadState(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLSharedKeys_LoadState_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_LoadState>>(
          'FLSharedKeys_LoadState');
  late final _dart_FLSharedKeys_LoadState _FLSharedKeys_LoadState =
      _FLSharedKeys_LoadState_ptr.asFunction<_dart_FLSharedKeys_LoadState>();

  /// Maps a key string to a number in the range [0...2047], or returns -1 if it isn't mapped.
  /// If the key doesn't already have a mapping, and the `add` flag is true,
  /// a new mapping is assigned and returned.
  /// However, the `add` flag has no effect if the key is unmappable (is longer than 16 bytes
  /// or contains non-identifier characters), or if all available integers have been assigned.
  int FLSharedKeys_Encode(
    ffi.Pointer<FLSharedKeys> arg0,
    FLSlice arg1,
    bool add,
  ) {
    return _FLSharedKeys_Encode(
      arg0,
      arg1,
      add ? 1 : 0,
    );
  }

  late final _FLSharedKeys_Encode_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_Encode>>(
          'FLSharedKeys_Encode');
  late final _dart_FLSharedKeys_Encode _FLSharedKeys_Encode =
      _FLSharedKeys_Encode_ptr.asFunction<_dart_FLSharedKeys_Encode>();

  /// Returns the key string that maps to the given integer `key`, else NULL.
  FLSlice FLSharedKeys_Decode(
    ffi.Pointer<FLSharedKeys> arg0,
    int key,
  ) {
    return _FLSharedKeys_Decode(
      arg0,
      key,
    );
  }

  late final _FLSharedKeys_Decode_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_Decode>>(
          'FLSharedKeys_Decode');
  late final _dart_FLSharedKeys_Decode _FLSharedKeys_Decode =
      _FLSharedKeys_Decode_ptr.asFunction<_dart_FLSharedKeys_Decode>();

  /// Returns the number of keys in the mapping. This number increases whenever the mapping
  /// is changed, and never decreases.
  int FLSharedKeys_Count(
    ffi.Pointer<FLSharedKeys> arg0,
  ) {
    return _FLSharedKeys_Count(
      arg0,
    );
  }

  late final _FLSharedKeys_Count_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_Count>>('FLSharedKeys_Count');
  late final _dart_FLSharedKeys_Count _FLSharedKeys_Count =
      _FLSharedKeys_Count_ptr.asFunction<_dart_FLSharedKeys_Count>();

  /// Reverts an FLSharedKeys by "forgetting" any keys added since it had the count `oldCount`.
  void FLSharedKeys_RevertToCount(
    ffi.Pointer<FLSharedKeys> arg0,
    int oldCount,
  ) {
    return _FLSharedKeys_RevertToCount(
      arg0,
      oldCount,
    );
  }

  late final _FLSharedKeys_RevertToCount_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_RevertToCount>>(
          'FLSharedKeys_RevertToCount');
  late final _dart_FLSharedKeys_RevertToCount _FLSharedKeys_RevertToCount =
      _FLSharedKeys_RevertToCount_ptr.asFunction<
          _dart_FLSharedKeys_RevertToCount>();

  /// Increments the reference count of an FLSharedKeys.
  ffi.Pointer<FLSharedKeys> FLSharedKeys_Retain(
    ffi.Pointer<FLSharedKeys> arg0,
  ) {
    return _FLSharedKeys_Retain(
      arg0,
    );
  }

  late final _FLSharedKeys_Retain_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_Retain>>(
          'FLSharedKeys_Retain');
  late final _dart_FLSharedKeys_Retain _FLSharedKeys_Retain =
      _FLSharedKeys_Retain_ptr.asFunction<_dart_FLSharedKeys_Retain>();

  /// Decrements the reference count of an FLSharedKeys, freeing it when it reaches zero.
  void FLSharedKeys_Release(
    ffi.Pointer<FLSharedKeys> arg0,
  ) {
    return _FLSharedKeys_Release(
      arg0,
    );
  }

  late final _FLSharedKeys_Release_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeys_Release>>(
          'FLSharedKeys_Release');
  late final _dart_FLSharedKeys_Release _FLSharedKeys_Release =
      _FLSharedKeys_Release_ptr.asFunction<_dart_FLSharedKeys_Release>();

  ffi.Pointer<FLSharedKeyScope> FLSharedKeyScope_WithRange(
    FLSlice range,
    ffi.Pointer<FLSharedKeys> arg1,
  ) {
    return _FLSharedKeyScope_WithRange(
      range,
      arg1,
    );
  }

  late final _FLSharedKeyScope_WithRange_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeyScope_WithRange>>(
          'FLSharedKeyScope_WithRange');
  late final _dart_FLSharedKeyScope_WithRange _FLSharedKeyScope_WithRange =
      _FLSharedKeyScope_WithRange_ptr.asFunction<
          _dart_FLSharedKeyScope_WithRange>();

  void FLSharedKeyScope_Free(
    ffi.Pointer<FLSharedKeyScope> arg0,
  ) {
    return _FLSharedKeyScope_Free(
      arg0,
    );
  }

  late final _FLSharedKeyScope_Free_ptr =
      _lookup<ffi.NativeFunction<_c_FLSharedKeyScope_Free>>(
          'FLSharedKeyScope_Free');
  late final _dart_FLSharedKeyScope_Free _FLSharedKeyScope_Free =
      _FLSharedKeyScope_Free_ptr.asFunction<_dart_FLSharedKeyScope_Free>();

  /// Creates a new encoder, for generating Fleece data. Call FLEncoder_Free when done.
  ffi.Pointer<FLEncoder> FLEncoder_New() {
    return _FLEncoder_New();
  }

  late final _FLEncoder_New_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_New>>('FLEncoder_New');
  late final _dart_FLEncoder_New _FLEncoder_New =
      _FLEncoder_New_ptr.asFunction<_dart_FLEncoder_New>();

  /// Creates a new encoder, allowing some options to be customized.
  /// @param format  The output format to generate (Fleece, JSON, or JSON5.)
  /// @param reserveSize  The number of bytes to preallocate for the output. (Default is 256)
  /// @param uniqueStrings  (Fleece only) If true, string values that appear multiple times will be written
  /// as a single shared value. This saves space but makes encoding slightly slower.
  /// You should only turn this off if you know you're going to be writing large numbers
  /// of non-repeated strings. (Default is true)
  ffi.Pointer<FLEncoder> FLEncoder_NewWithOptions(
    int format,
    int reserveSize,
    bool uniqueStrings,
  ) {
    return _FLEncoder_NewWithOptions(
      format,
      reserveSize,
      uniqueStrings ? 1 : 0,
    );
  }

  late final _FLEncoder_NewWithOptions_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_NewWithOptions>>(
          'FLEncoder_NewWithOptions');
  late final _dart_FLEncoder_NewWithOptions _FLEncoder_NewWithOptions =
      _FLEncoder_NewWithOptions_ptr.asFunction<
          _dart_FLEncoder_NewWithOptions>();

  /// Creates a new Fleece encoder that writes to a file, not to memory.
  ffi.Pointer<FLEncoder> FLEncoder_NewWritingToFile(
    ffi.Pointer<FILE> arg0,
    bool uniqueStrings,
  ) {
    return _FLEncoder_NewWritingToFile(
      arg0,
      uniqueStrings ? 1 : 0,
    );
  }

  late final _FLEncoder_NewWritingToFile_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_NewWritingToFile>>(
          'FLEncoder_NewWritingToFile');
  late final _dart_FLEncoder_NewWritingToFile _FLEncoder_NewWritingToFile =
      _FLEncoder_NewWritingToFile_ptr.asFunction<
          _dart_FLEncoder_NewWritingToFile>();

  /// Frees the space used by an encoder.
  void FLEncoder_Free(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_Free(
      arg0,
    );
  }

  late final _FLEncoder_Free_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_Free>>('FLEncoder_Free');
  late final _dart_FLEncoder_Free _FLEncoder_Free =
      _FLEncoder_Free_ptr.asFunction<_dart_FLEncoder_Free>();

  /// Tells the encoder to use a shared-keys mapping when encoding dictionary keys.
  void FLEncoder_SetSharedKeys(
    ffi.Pointer<FLEncoder> arg0,
    ffi.Pointer<FLSharedKeys> arg1,
  ) {
    return _FLEncoder_SetSharedKeys(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_SetSharedKeys_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_SetSharedKeys>>(
          'FLEncoder_SetSharedKeys');
  late final _dart_FLEncoder_SetSharedKeys _FLEncoder_SetSharedKeys =
      _FLEncoder_SetSharedKeys_ptr.asFunction<_dart_FLEncoder_SetSharedKeys>();

  /// Associates an arbitrary user-defined value with the encoder.
  void FLEncoder_SetExtraInfo(
    ffi.Pointer<FLEncoder> arg0,
    ffi.Pointer<ffi.Void> info,
  ) {
    return _FLEncoder_SetExtraInfo(
      arg0,
      info,
    );
  }

  late final _FLEncoder_SetExtraInfo_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_SetExtraInfo>>(
          'FLEncoder_SetExtraInfo');
  late final _dart_FLEncoder_SetExtraInfo _FLEncoder_SetExtraInfo =
      _FLEncoder_SetExtraInfo_ptr.asFunction<_dart_FLEncoder_SetExtraInfo>();

  /// Returns the user-defined value associated with the encoder; NULL by default.
  ffi.Pointer<ffi.Void> FLEncoder_GetExtraInfo(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_GetExtraInfo(
      arg0,
    );
  }

  late final _FLEncoder_GetExtraInfo_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_GetExtraInfo>>(
          'FLEncoder_GetExtraInfo');
  late final _dart_FLEncoder_GetExtraInfo _FLEncoder_GetExtraInfo =
      _FLEncoder_GetExtraInfo_ptr.asFunction<_dart_FLEncoder_GetExtraInfo>();

  /// Tells the encoder to logically append to the given Fleece document, rather than making a
  /// standalone document. Any calls to FLEncoder_WriteValue() where the value points inside the
  /// base data will write a pointer back to the original value.
  /// The resulting data returned by FLEncoder_FinishDoc() will *NOT* be standalone; it can only
  /// be used by first appending it to the base data.
  /// @param e  The FLEncoder affected.
  /// @param base  The base document to create an amendment of.
  /// @param reuseStrings  If true, then writing a string that already exists in the base will
  /// just create a pointer back to the original. But the encoder has to scan the
  /// base for strings first.
  /// @param externPointers  If true, pointers into the base will be marked with the `extern`
  /// flag. This allows them to be resolved using the `FLResolver_Begin` function,
  /// so that when the delta is used the base document can be anywhere in memory,
  /// not just immediately preceding the delta document.
  void FLEncoder_Amend(
    ffi.Pointer<FLEncoder> e,
    FLSlice base,
    bool reuseStrings,
    bool externPointers,
  ) {
    return _FLEncoder_Amend(
      e,
      base,
      reuseStrings ? 1 : 0,
      externPointers ? 1 : 0,
    );
  }

  late final _FLEncoder_Amend_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_Amend>>('FLEncoder_Amend');
  late final _dart_FLEncoder_Amend _FLEncoder_Amend =
      _FLEncoder_Amend_ptr.asFunction<_dart_FLEncoder_Amend>();

  /// Returns the `base` value passed to FLEncoder_Amend.
  FLSlice FLEncoder_GetBase(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_GetBase(
      arg0,
    );
  }

  late final _FLEncoder_GetBase_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_GetBase>>('FLEncoder_GetBase');
  late final _dart_FLEncoder_GetBase _FLEncoder_GetBase =
      _FLEncoder_GetBase_ptr.asFunction<_dart_FLEncoder_GetBase>();

  /// Tells the encoder not to write the two-byte Fleece trailer at the end of the data.
  /// This is only useful for certain special purposes.
  void FLEncoder_SuppressTrailer(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_SuppressTrailer(
      arg0,
    );
  }

  late final _FLEncoder_SuppressTrailer_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_SuppressTrailer>>(
          'FLEncoder_SuppressTrailer');
  late final _dart_FLEncoder_SuppressTrailer _FLEncoder_SuppressTrailer =
      _FLEncoder_SuppressTrailer_ptr.asFunction<
          _dart_FLEncoder_SuppressTrailer>();

  /// Resets the state of an encoder without freeing it. It can then be reused to encode
  /// another value.
  void FLEncoder_Reset(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_Reset(
      arg0,
    );
  }

  late final _FLEncoder_Reset_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_Reset>>('FLEncoder_Reset');
  late final _dart_FLEncoder_Reset _FLEncoder_Reset =
      _FLEncoder_Reset_ptr.asFunction<_dart_FLEncoder_Reset>();

  /// Returns the number of bytes encoded so far.
  int FLEncoder_BytesWritten(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_BytesWritten(
      arg0,
    );
  }

  late final _FLEncoder_BytesWritten_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_BytesWritten>>(
          'FLEncoder_BytesWritten');
  late final _dart_FLEncoder_BytesWritten _FLEncoder_BytesWritten =
      _FLEncoder_BytesWritten_ptr.asFunction<_dart_FLEncoder_BytesWritten>();

  /// Returns the byte offset in the encoded data where the next value will be written.
  /// (Due to internal buffering, this is not the same as FLEncoder_BytesWritten.)
  int FLEncoder_GetNextWritePos(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_GetNextWritePos(
      arg0,
    );
  }

  late final _FLEncoder_GetNextWritePos_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_GetNextWritePos>>(
          'FLEncoder_GetNextWritePos');
  late final _dart_FLEncoder_GetNextWritePos _FLEncoder_GetNextWritePos =
      _FLEncoder_GetNextWritePos_ptr.asFunction<
          _dart_FLEncoder_GetNextWritePos>();

  /// Writes a `null` value to an encoder. (This is an explicitly-stored null, like the JSON
  /// `null`, not the "undefined" value represented by a NULL FLValue pointer.)
  bool FLEncoder_WriteNull(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_WriteNull(
          arg0,
        ) !=
        0;
  }

  late final _FLEncoder_WriteNull_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteNull>>(
          'FLEncoder_WriteNull');
  late final _dart_FLEncoder_WriteNull _FLEncoder_WriteNull =
      _FLEncoder_WriteNull_ptr.asFunction<_dart_FLEncoder_WriteNull>();

  /// Writes an `undefined` value to an encoder. (Its value when read will not be a `NULL`
  /// pointer, but it can be recognized by `FLValue_GetType` returning `kFLUndefined`.)
  /// @note The only real use for writing undefined values is to represent "holes" in an array.
  /// An undefined dictionary value should be written simply by skipping the key and value.
  bool FLEncoder_WriteUndefined(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_WriteUndefined(
          arg0,
        ) !=
        0;
  }

  late final _FLEncoder_WriteUndefined_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteUndefined>>(
          'FLEncoder_WriteUndefined');
  late final _dart_FLEncoder_WriteUndefined _FLEncoder_WriteUndefined =
      _FLEncoder_WriteUndefined_ptr.asFunction<
          _dart_FLEncoder_WriteUndefined>();

  /// Writes a boolean value (true or false) to an encoder.
  bool FLEncoder_WriteBool(
    ffi.Pointer<FLEncoder> arg0,
    bool arg1,
  ) {
    return _FLEncoder_WriteBool(
          arg0,
          arg1 ? 1 : 0,
        ) !=
        0;
  }

  late final _FLEncoder_WriteBool_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteBool>>(
          'FLEncoder_WriteBool');
  late final _dart_FLEncoder_WriteBool _FLEncoder_WriteBool =
      _FLEncoder_WriteBool_ptr.asFunction<_dart_FLEncoder_WriteBool>();

  /// Writes an integer to an encoder. The parameter is typed as `int64_t` but you can pass any
  /// integral type (signed or unsigned) except for huge `uint64_t`s.
  /// The number will be written in a compact form that uses only as many bytes as necessary.
  bool FLEncoder_WriteInt(
    ffi.Pointer<FLEncoder> arg0,
    int arg1,
  ) {
    return _FLEncoder_WriteInt(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteInt_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteInt>>('FLEncoder_WriteInt');
  late final _dart_FLEncoder_WriteInt _FLEncoder_WriteInt =
      _FLEncoder_WriteInt_ptr.asFunction<_dart_FLEncoder_WriteInt>();

  /// Writes an unsigned integer to an encoder.
  /// @note This function is only really necessary for huge
  /// 64-bit integers greater than or equal to 2^63, which can't be represented as int64_t.
  bool FLEncoder_WriteUInt(
    ffi.Pointer<FLEncoder> arg0,
    int arg1,
  ) {
    return _FLEncoder_WriteUInt(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteUInt_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteUInt>>(
          'FLEncoder_WriteUInt');
  late final _dart_FLEncoder_WriteUInt _FLEncoder_WriteUInt =
      _FLEncoder_WriteUInt_ptr.asFunction<_dart_FLEncoder_WriteUInt>();

  /// Writes a 32-bit floating point number to an encoder.
  /// @note As an implementation detail, if the number has no fractional part and can be
  /// represented exactly as an integer, it'll be encoded as an integer to save space. This is
  /// transparent to the reader, since if it requests the value as a float it'll be returned
  /// as floating-point.
  bool FLEncoder_WriteFloat(
    ffi.Pointer<FLEncoder> arg0,
    double arg1,
  ) {
    return _FLEncoder_WriteFloat(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteFloat_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteFloat>>(
          'FLEncoder_WriteFloat');
  late final _dart_FLEncoder_WriteFloat _FLEncoder_WriteFloat =
      _FLEncoder_WriteFloat_ptr.asFunction<_dart_FLEncoder_WriteFloat>();

  /// Writes a 64-bit floating point number to an encoder.
  /// @note As an implementation detail, the number may be encoded as a 32-bit float or even
  /// as an integer, if this can be done without losing precision. For example, 123.0 will be
  /// written as an integer, and 123.75 as a float.)
  bool FLEncoder_WriteDouble(
    ffi.Pointer<FLEncoder> arg0,
    double arg1,
  ) {
    return _FLEncoder_WriteDouble(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteDouble_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteDouble>>(
          'FLEncoder_WriteDouble');
  late final _dart_FLEncoder_WriteDouble _FLEncoder_WriteDouble =
      _FLEncoder_WriteDouble_ptr.asFunction<_dart_FLEncoder_WriteDouble>();

  /// Writes a string to an encoder. The string must be UTF-8-encoded and must not contain any
  /// zero bytes.
  /// @warning Do _not_ use this to write a dictionary key; use FLEncoder_WriteKey instead.
  bool FLEncoder_WriteString(
    ffi.Pointer<FLEncoder> arg0,
    FLSlice arg1,
  ) {
    return _FLEncoder_WriteString(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteString_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteString>>(
          'FLEncoder_WriteString');
  late final _dart_FLEncoder_WriteString _FLEncoder_WriteString =
      _FLEncoder_WriteString_ptr.asFunction<_dart_FLEncoder_WriteString>();

  /// Writes a timestamp to an encoder, as an ISO-8601 date string.
  /// @note Since neither Fleece nor JSON have a 'Date' type, the encoded string has no
  /// metadata that distinguishes it as a date. It's just a string.)
  /// @param encoder  The encoder to write to.
  /// @param ts  The timestamp (milliseconds since Unix epoch 1-1-1970).
  /// @param asUTC  If true, date is written in UTC (GMT); if false, with the local timezone.
  /// @return  True on success, false on error.
  bool FLEncoder_WriteDateString(
    ffi.Pointer<FLEncoder> encoder,
    int ts,
    bool asUTC,
  ) {
    return _FLEncoder_WriteDateString(
          encoder,
          ts,
          asUTC ? 1 : 0,
        ) !=
        0;
  }

  late final _FLEncoder_WriteDateString_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteDateString>>(
          'FLEncoder_WriteDateString');
  late final _dart_FLEncoder_WriteDateString _FLEncoder_WriteDateString =
      _FLEncoder_WriteDateString_ptr.asFunction<
          _dart_FLEncoder_WriteDateString>();

  /// Writes a binary data value (a blob) to an encoder. This can contain absolutely anything
  /// including null bytes.
  /// If the encoder is generating JSON, the blob will be written as a base64-encoded string.
  bool FLEncoder_WriteData(
    ffi.Pointer<FLEncoder> arg0,
    FLSlice arg1,
  ) {
    return _FLEncoder_WriteData(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteData_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteData>>(
          'FLEncoder_WriteData');
  late final _dart_FLEncoder_WriteData _FLEncoder_WriteData =
      _FLEncoder_WriteData_ptr.asFunction<_dart_FLEncoder_WriteData>();

  /// Writes raw data directly to the encoded output.
  /// (This is not the same as FLEncoder_WriteData, which safely encodes a blob.)
  /// @warning **Do not call this** unless you really know what you're doing ...
  /// it's quite unsafe, and only used for certain advanced purposes.
  bool FLEncoder_WriteRaw(
    ffi.Pointer<FLEncoder> arg0,
    FLSlice arg1,
  ) {
    return _FLEncoder_WriteRaw(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteRaw_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteRaw>>('FLEncoder_WriteRaw');
  late final _dart_FLEncoder_WriteRaw _FLEncoder_WriteRaw =
      _FLEncoder_WriteRaw_ptr.asFunction<_dart_FLEncoder_WriteRaw>();

  /// Begins writing an array value to an encoder. This pushes a new state where each
  /// subsequent value written becomes an array item, until FLEncoder_EndArray is called.
  /// @param reserveCount  Number of array elements to reserve space for. If you know the size
  /// of the array, providing it here speeds up encoding slightly. If you don't know,
  /// just use zero.
  bool FLEncoder_BeginArray(
    ffi.Pointer<FLEncoder> arg0,
    int reserveCount,
  ) {
    return _FLEncoder_BeginArray(
          arg0,
          reserveCount,
        ) !=
        0;
  }

  late final _FLEncoder_BeginArray_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_BeginArray>>(
          'FLEncoder_BeginArray');
  late final _dart_FLEncoder_BeginArray _FLEncoder_BeginArray =
      _FLEncoder_BeginArray_ptr.asFunction<_dart_FLEncoder_BeginArray>();

  /// Ends writing an array value; pops back the previous encoding state.
  bool FLEncoder_EndArray(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_EndArray(
          arg0,
        ) !=
        0;
  }

  late final _FLEncoder_EndArray_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_EndArray>>('FLEncoder_EndArray');
  late final _dart_FLEncoder_EndArray _FLEncoder_EndArray =
      _FLEncoder_EndArray_ptr.asFunction<_dart_FLEncoder_EndArray>();

  /// Begins writing a dictionary value to an encoder. This pushes a new state where each
  /// subsequent key and value written are added to the dictionary, until FLEncoder_EndDict is
  /// called.
  /// Before adding each value, you must call FLEncoder_WriteKey (_not_ FLEncoder_WriteString!),
  /// to write the dictionary key.
  /// @param reserveCount  Number of dictionary items to reserve space for. If you know the size
  /// of the dictionary, providing it here speeds up encoding slightly. If you don't know,
  /// just use zero.
  bool FLEncoder_BeginDict(
    ffi.Pointer<FLEncoder> arg0,
    int reserveCount,
  ) {
    return _FLEncoder_BeginDict(
          arg0,
          reserveCount,
        ) !=
        0;
  }

  late final _FLEncoder_BeginDict_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_BeginDict>>(
          'FLEncoder_BeginDict');
  late final _dart_FLEncoder_BeginDict _FLEncoder_BeginDict =
      _FLEncoder_BeginDict_ptr.asFunction<_dart_FLEncoder_BeginDict>();

  /// Specifies the key for the next value to be written to the current dictionary.
  bool FLEncoder_WriteKey(
    ffi.Pointer<FLEncoder> arg0,
    FLSlice arg1,
  ) {
    return _FLEncoder_WriteKey(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteKey_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteKey>>('FLEncoder_WriteKey');
  late final _dart_FLEncoder_WriteKey _FLEncoder_WriteKey =
      _FLEncoder_WriteKey_ptr.asFunction<_dart_FLEncoder_WriteKey>();

  /// Specifies the key for the next value to be written to the current dictionary.
  /// The key is given as a Value, which must be a string or integer.
  bool FLEncoder_WriteKeyValue(
    ffi.Pointer<FLEncoder> arg0,
    ffi.Pointer<FLValue> arg1,
  ) {
    return _FLEncoder_WriteKeyValue(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteKeyValue_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteKeyValue>>(
          'FLEncoder_WriteKeyValue');
  late final _dart_FLEncoder_WriteKeyValue _FLEncoder_WriteKeyValue =
      _FLEncoder_WriteKeyValue_ptr.asFunction<_dart_FLEncoder_WriteKeyValue>();

  /// Ends writing a dictionary value; pops back the previous encoding state.
  bool FLEncoder_EndDict(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_EndDict(
          arg0,
        ) !=
        0;
  }

  late final _FLEncoder_EndDict_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_EndDict>>('FLEncoder_EndDict');
  late final _dart_FLEncoder_EndDict _FLEncoder_EndDict =
      _FLEncoder_EndDict_ptr.asFunction<_dart_FLEncoder_EndDict>();

  /// Writes a Fleece Value to an Encoder.
  bool FLEncoder_WriteValue(
    ffi.Pointer<FLEncoder> arg0,
    ffi.Pointer<FLValue> arg1,
  ) {
    return _FLEncoder_WriteValue(
          arg0,
          arg1,
        ) !=
        0;
  }

  late final _FLEncoder_WriteValue_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteValue>>(
          'FLEncoder_WriteValue');
  late final _dart_FLEncoder_WriteValue _FLEncoder_WriteValue =
      _FLEncoder_WriteValue_ptr.asFunction<_dart_FLEncoder_WriteValue>();

  /// Returns an opaque reference to the last complete value written to the encoder, if possible.
  /// Fails (returning 0) if nothing has been written, or if the value is inline and can't be
  /// referenced this way -- that only happens with small scalars or empty collections.
  int FLEncoder_LastValueWritten(
    ffi.Pointer<FLEncoder> e,
  ) {
    return _FLEncoder_LastValueWritten(
      e,
    );
  }

  late final _FLEncoder_LastValueWritten_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_LastValueWritten>>(
          'FLEncoder_LastValueWritten');
  late final _dart_FLEncoder_LastValueWritten _FLEncoder_LastValueWritten =
      _FLEncoder_LastValueWritten_ptr.asFunction<
          _dart_FLEncoder_LastValueWritten>();

  /// Writes another reference (a "pointer") to an already-written value, given a reference previously
  /// returned from \ref FLEncoder_LastValueWritten. The effect is exactly the same as if you wrote the
  /// entire value again, except that the size of the encoded data only grows by 4 bytes.
  void FLEncoder_WriteValueAgain(
    ffi.Pointer<FLEncoder> e,
    int preWrittenValue,
  ) {
    return _FLEncoder_WriteValueAgain(
      e,
      preWrittenValue,
    );
  }

  late final _FLEncoder_WriteValueAgain_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_WriteValueAgain>>(
          'FLEncoder_WriteValueAgain');
  late final _dart_FLEncoder_WriteValueAgain _FLEncoder_WriteValueAgain =
      _FLEncoder_WriteValueAgain_ptr.asFunction<
          _dart_FLEncoder_WriteValueAgain>();

  /// Returns the data written so far as a standalone Fleece document, whose root is the last
  /// value written. You can continue writing, and the final output returned by \ref FLEncoder_Finish will
  /// consist of everything after this point. That second part can be used in the future by loading it
  /// as an `FLDoc` with the first part as its `extern` reference.
  FLSliceResult FLEncoder_Snip(
    ffi.Pointer<FLEncoder> e,
  ) {
    return _FLEncoder_Snip(
      e,
    );
  }

  late final _FLEncoder_Snip_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_Snip>>('FLEncoder_Snip');
  late final _dart_FLEncoder_Snip _FLEncoder_Snip =
      _FLEncoder_Snip_ptr.asFunction<_dart_FLEncoder_Snip>();

  /// Parses JSON data and writes the object(s) to the encoder. (This acts as a single write,
  /// like WriteInt; it's just that the value written is likely to be an entire dictionary of
  /// array.)
  bool FLEncoder_ConvertJSON(
    ffi.Pointer<FLEncoder> arg0,
    FLSlice json,
  ) {
    return _FLEncoder_ConvertJSON(
          arg0,
          json,
        ) !=
        0;
  }

  late final _FLEncoder_ConvertJSON_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_ConvertJSON>>(
          'FLEncoder_ConvertJSON');
  late final _dart_FLEncoder_ConvertJSON _FLEncoder_ConvertJSON =
      _FLEncoder_ConvertJSON_ptr.asFunction<_dart_FLEncoder_ConvertJSON>();

  /// Finishes encoding the current item, and returns its offset in the output data.
  int FLEncoder_FinishItem(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_FinishItem(
      arg0,
    );
  }

  late final _FLEncoder_FinishItem_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_FinishItem>>(
          'FLEncoder_FinishItem');
  late final _dart_FLEncoder_FinishItem _FLEncoder_FinishItem =
      _FLEncoder_FinishItem_ptr.asFunction<_dart_FLEncoder_FinishItem>();

  /// Ends encoding; if there has been no error, it returns the encoded Fleece data packaged in
  /// an FLDoc. (This function does not support JSON encoding.)
  /// This does not free the FLEncoder; call FLEncoder_Free (or FLEncoder_Reset) next.
  ffi.Pointer<FLDoc> FLEncoder_FinishDoc(
    ffi.Pointer<FLEncoder> arg0,
    ffi.Pointer<ffi.Int32> arg1,
  ) {
    return _FLEncoder_FinishDoc(
      arg0,
      arg1,
    );
  }

  late final _FLEncoder_FinishDoc_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_FinishDoc>>(
          'FLEncoder_FinishDoc');
  late final _dart_FLEncoder_FinishDoc _FLEncoder_FinishDoc =
      _FLEncoder_FinishDoc_ptr.asFunction<_dart_FLEncoder_FinishDoc>();

  /// Ends encoding; if there has been no error, it returns the encoded data, else null.
  /// This does not free the FLEncoder; call FLEncoder_Free (or FLEncoder_Reset) next.
  FLSliceResult FLEncoder_Finish(
    ffi.Pointer<FLEncoder> e,
    ffi.Pointer<ffi.Int32> outError,
  ) {
    return _FLEncoder_Finish(
      e,
      outError,
    );
  }

  late final _FLEncoder_Finish_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_Finish>>('FLEncoder_Finish');
  late final _dart_FLEncoder_Finish _FLEncoder_Finish =
      _FLEncoder_Finish_ptr.asFunction<_dart_FLEncoder_Finish>();

  /// Returns the error code of an encoder, or NoError (0) if there's no error.
  int FLEncoder_GetError(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_GetError(
      arg0,
    );
  }

  late final _FLEncoder_GetError_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_GetError>>('FLEncoder_GetError');
  late final _dart_FLEncoder_GetError _FLEncoder_GetError =
      _FLEncoder_GetError_ptr.asFunction<_dart_FLEncoder_GetError>();

  /// Returns the error message of an encoder, or NULL if there's no error.
  ffi.Pointer<ffi.Int8> FLEncoder_GetErrorMessage(
    ffi.Pointer<FLEncoder> arg0,
  ) {
    return _FLEncoder_GetErrorMessage(
      arg0,
    );
  }

  late final _FLEncoder_GetErrorMessage_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncoder_GetErrorMessage>>(
          'FLEncoder_GetErrorMessage');
  late final _dart_FLEncoder_GetErrorMessage _FLEncoder_GetErrorMessage =
      _FLEncoder_GetErrorMessage_ptr.asFunction<
          _dart_FLEncoder_GetErrorMessage>();

  /// Returns JSON that encodes the changes to turn the value `old` into `nuu`.
  /// (The format is documented in Fleece.md, but you should treat it as a black box.)
  /// @param old  A value that's typically the old/original state of some data.
  /// @param nuu  A value that's typically the new/changed state of the `old` data.
  /// @return  JSON data representing the changes from `old` to `nuu`, or NULL on
  /// (extremely unlikely) failure.
  FLSliceResult FLCreateJSONDelta(
    ffi.Pointer<FLValue> old,
    ffi.Pointer<FLValue> nuu,
  ) {
    return _FLCreateJSONDelta(
      old,
      nuu,
    );
  }

  late final _FLCreateJSONDelta_ptr =
      _lookup<ffi.NativeFunction<_c_FLCreateJSONDelta>>('FLCreateJSONDelta');
  late final _dart_FLCreateJSONDelta _FLCreateJSONDelta =
      _FLCreateJSONDelta_ptr.asFunction<_dart_FLCreateJSONDelta>();

  /// Writes JSON that describes the changes to turn the value `old` into `nuu`.
  /// (The format is documented in Fleece.md, but you should treat it as a black box.)
  /// @param old  A value that's typically the old/original state of some data.
  /// @param nuu  A value that's typically the new/changed state of the `old` data.
  /// @param jsonEncoder  An encoder to write the JSON to. Must have been created using
  /// `FLEncoder_NewWithOptions`, with JSON or JSON5 format.
  /// @return  True on success, false on (extremely unlikely) failure.
  bool FLEncodeJSONDelta(
    ffi.Pointer<FLValue> old,
    ffi.Pointer<FLValue> nuu,
    ffi.Pointer<FLEncoder> jsonEncoder,
  ) {
    return _FLEncodeJSONDelta(
          old,
          nuu,
          jsonEncoder,
        ) !=
        0;
  }

  late final _FLEncodeJSONDelta_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncodeJSONDelta>>('FLEncodeJSONDelta');
  late final _dart_FLEncodeJSONDelta _FLEncodeJSONDelta =
      _FLEncodeJSONDelta_ptr.asFunction<_dart_FLEncodeJSONDelta>();

  /// Applies the JSON data created by `CreateJSONDelta` to the value `old`, which must be equal
  /// to the `old` value originally passed to `FLCreateJSONDelta`, and returns a Fleece document
  /// equal to the original `nuu` value.
  /// @param old  A value that's typically the old/original state of some data. This must be
  /// equal to the `old` value used when creating the `jsonDelta`.
  /// @param jsonDelta  A JSON-encoded delta created by `FLCreateJSONDelta` or `FLEncodeJSONDelta`.
  /// @param error  On failure, error information will be stored where this points, if non-null.
  /// @return  The corresponding `nuu` value, encoded as Fleece, or null if an error occurred.
  FLSliceResult FLApplyJSONDelta(
    ffi.Pointer<FLValue> old,
    FLSlice jsonDelta,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _FLApplyJSONDelta(
      old,
      jsonDelta,
      error,
    );
  }

  late final _FLApplyJSONDelta_ptr =
      _lookup<ffi.NativeFunction<_c_FLApplyJSONDelta>>('FLApplyJSONDelta');
  late final _dart_FLApplyJSONDelta _FLApplyJSONDelta =
      _FLApplyJSONDelta_ptr.asFunction<_dart_FLApplyJSONDelta>();

  /// Applies the (parsed) JSON data created by `CreateJSONDelta` to the value `old`, which must be
  /// equal to the `old` value originally passed to `FLCreateJSONDelta`, and writes the corresponding
  /// `nuu` value to the encoder.
  /// @param old  A value that's typically the old/original state of some data. This must be
  /// equal to the `old` value used when creating the `jsonDelta`.
  /// @param jsonDelta  A JSON-encoded delta created by `FLCreateJSONDelta` or `FLEncodeJSONDelta`.
  /// @param encoder  A Fleece encoder to write the decoded `nuu` value to. (JSON encoding is not
  /// supported.)
  /// @return  True on success, false on error; call `FLEncoder_GetError` for details.
  bool FLEncodeApplyingJSONDelta(
    ffi.Pointer<FLValue> old,
    FLSlice jsonDelta,
    ffi.Pointer<FLEncoder> encoder,
  ) {
    return _FLEncodeApplyingJSONDelta(
          old,
          jsonDelta,
          encoder,
        ) !=
        0;
  }

  late final _FLEncodeApplyingJSONDelta_ptr =
      _lookup<ffi.NativeFunction<_c_FLEncodeApplyingJSONDelta>>(
          'FLEncodeApplyingJSONDelta');
  late final _dart_FLEncodeApplyingJSONDelta _FLEncodeApplyingJSONDelta =
      _FLEncodeApplyingJSONDelta_ptr.asFunction<
          _dart_FLEncodeApplyingJSONDelta>();

  /// Returns an FLSlot that refers to the given index of the given array.
  /// You store a value to it by calling one of the nine `FLSlot_Set...` functions.
  /// \warning You should immediately store a value into the `FLSlot`. Do not keep it around;
  /// any changes to the array invalidate it.
  ffi.Pointer<FLSlot> FLMutableArray_Set(
    ffi.Pointer<FLArray> arg0,
    int index,
  ) {
    return _FLMutableArray_Set(
      arg0,
      index,
    );
  }

  late final _FLMutableArray_Set_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_Set>>('FLMutableArray_Set');
  late final _dart_FLMutableArray_Set _FLMutableArray_Set =
      _FLMutableArray_Set_ptr.asFunction<_dart_FLMutableArray_Set>();

  /// Appends a null value to the array and returns an `FLSLot` that refers to that position.
  /// You store a value to it by calling one of the nine `FLSlot_Set...` functions.
  /// \warning You should immediately store a value into the `FLSlot`. Do not keep it around;
  /// any changes to the array invalidate it.
  ffi.Pointer<FLSlot> FLMutableArray_Append(
    ffi.Pointer<FLArray> arg0,
  ) {
    return _FLMutableArray_Append(
      arg0,
    );
  }

  late final _FLMutableArray_Append_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableArray_Append>>(
          'FLMutableArray_Append');
  late final _dart_FLMutableArray_Append _FLMutableArray_Append =
      _FLMutableArray_Append_ptr.asFunction<_dart_FLMutableArray_Append>();

  /// Returns an FLSlot that refers to the given key/value pair of the given dictionary.
  /// You store a value to it by calling one of the nine `FLSlot_Set...` functions.
  /// \warning You should immediately store a value into the `FLSlot`. Do not keep it around;
  /// any changes to the dictionary invalidate it.
  ffi.Pointer<FLSlot> FLMutableDict_Set(
    ffi.Pointer<FLDict> FL_NONNULL,
    FLSlice key,
  ) {
    return _FLMutableDict_Set(
      FL_NONNULL,
      key,
    );
  }

  late final _FLMutableDict_Set_ptr =
      _lookup<ffi.NativeFunction<_c_FLMutableDict_Set>>('FLMutableDict_Set');
  late final _dart_FLMutableDict_Set _FLMutableDict_Set =
      _FLMutableDict_Set_ptr.asFunction<_dart_FLMutableDict_Set>();

  void FLSlot_SetNull(
    ffi.Pointer<FLSlot> arg0,
  ) {
    return _FLSlot_SetNull(
      arg0,
    );
  }

  late final _FLSlot_SetNull_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetNull>>('FLSlot_SetNull');
  late final _dart_FLSlot_SetNull _FLSlot_SetNull =
      _FLSlot_SetNull_ptr.asFunction<_dart_FLSlot_SetNull>();

  void FLSlot_SetBool(
    ffi.Pointer<FLSlot> arg0,
    bool arg1,
  ) {
    return _FLSlot_SetBool(
      arg0,
      arg1 ? 1 : 0,
    );
  }

  late final _FLSlot_SetBool_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetBool>>('FLSlot_SetBool');
  late final _dart_FLSlot_SetBool _FLSlot_SetBool =
      _FLSlot_SetBool_ptr.asFunction<_dart_FLSlot_SetBool>();

  void FLSlot_SetInt(
    ffi.Pointer<FLSlot> arg0,
    int arg1,
  ) {
    return _FLSlot_SetInt(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetInt_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetInt>>('FLSlot_SetInt');
  late final _dart_FLSlot_SetInt _FLSlot_SetInt =
      _FLSlot_SetInt_ptr.asFunction<_dart_FLSlot_SetInt>();

  void FLSlot_SetUInt(
    ffi.Pointer<FLSlot> arg0,
    int arg1,
  ) {
    return _FLSlot_SetUInt(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetUInt_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetUInt>>('FLSlot_SetUInt');
  late final _dart_FLSlot_SetUInt _FLSlot_SetUInt =
      _FLSlot_SetUInt_ptr.asFunction<_dart_FLSlot_SetUInt>();

  void FLSlot_SetFloat(
    ffi.Pointer<FLSlot> arg0,
    double arg1,
  ) {
    return _FLSlot_SetFloat(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetFloat_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetFloat>>('FLSlot_SetFloat');
  late final _dart_FLSlot_SetFloat _FLSlot_SetFloat =
      _FLSlot_SetFloat_ptr.asFunction<_dart_FLSlot_SetFloat>();

  void FLSlot_SetDouble(
    ffi.Pointer<FLSlot> arg0,
    double arg1,
  ) {
    return _FLSlot_SetDouble(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetDouble_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetDouble>>('FLSlot_SetDouble');
  late final _dart_FLSlot_SetDouble _FLSlot_SetDouble =
      _FLSlot_SetDouble_ptr.asFunction<_dart_FLSlot_SetDouble>();

  void FLSlot_SetString(
    ffi.Pointer<FLSlot> arg0,
    FLSlice arg1,
  ) {
    return _FLSlot_SetString(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetString_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetString>>('FLSlot_SetString');
  late final _dart_FLSlot_SetString _FLSlot_SetString =
      _FLSlot_SetString_ptr.asFunction<_dart_FLSlot_SetString>();

  void FLSlot_SetData(
    ffi.Pointer<FLSlot> arg0,
    FLSlice arg1,
  ) {
    return _FLSlot_SetData(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetData_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetData>>('FLSlot_SetData');
  late final _dart_FLSlot_SetData _FLSlot_SetData =
      _FLSlot_SetData_ptr.asFunction<_dart_FLSlot_SetData>();

  void FLSlot_SetValue(
    ffi.Pointer<FLSlot> arg0,
    ffi.Pointer<FLValue> arg1,
  ) {
    return _FLSlot_SetValue(
      arg0,
      arg1,
    );
  }

  late final _FLSlot_SetValue_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetValue>>('FLSlot_SetValue');
  late final _dart_FLSlot_SetValue _FLSlot_SetValue =
      _FLSlot_SetValue_ptr.asFunction<_dart_FLSlot_SetValue>();

  /// < `"@type"`
  late final ffi.Pointer<FLSlice> _kCBLTypeProperty =
      _lookup<FLSlice>('kCBLTypeProperty');

  FLSlice get kCBLTypeProperty => _kCBLTypeProperty.ref;

  /// < `"blob"`
  late final ffi.Pointer<FLSlice> _kCBLBlobType =
      _lookup<FLSlice>('kCBLBlobType');

  FLSlice get kCBLBlobType => _kCBLBlobType.ref;

  /// < `"digest"`
  late final ffi.Pointer<FLSlice> _kCBLBlobDigestProperty =
      _lookup<FLSlice>('kCBLBlobDigestProperty');

  FLSlice get kCBLBlobDigestProperty => _kCBLBlobDigestProperty.ref;

  /// < `"length"`
  late final ffi.Pointer<FLSlice> _kCBLBlobLengthProperty =
      _lookup<FLSlice>('kCBLBlobLengthProperty');

  FLSlice get kCBLBlobLengthProperty => _kCBLBlobLengthProperty.ref;

  /// < `"content_type"`
  late final ffi.Pointer<FLSlice> _kCBLBlobContentTypeProperty =
      _lookup<FLSlice>('kCBLBlobContentTypeProperty');

  FLSlice get kCBLBlobContentTypeProperty => _kCBLBlobContentTypeProperty.ref;

  /// Returns true if a dictionary in a document is a blob reference.
  /// If so, you can call \ref FLDict_GetBlob to access it.
  /// @note This function tests whether the dictionary has a `@type` property,
  /// whose value is `"blob"`.
  bool FLDict_IsBlob(
    ffi.Pointer<FLDict> arg0,
  ) {
    return _FLDict_IsBlob(
          arg0,
        ) !=
        0;
  }

  late final _FLDict_IsBlob_ptr =
      _lookup<ffi.NativeFunction<_c_FLDict_IsBlob>>('FLDict_IsBlob');
  late final _dart_FLDict_IsBlob _FLDict_IsBlob =
      _FLDict_IsBlob_ptr.asFunction<_dart_FLDict_IsBlob>();

  /// Returns a CBLBlob object corresponding to a blob dictionary in a document.
  /// @param blobDict  A dictionary in a document.
  /// @return  A CBLBlob instance for this blob, or NULL if the dictionary is not a blob.
  ffi.Pointer<CBLBlob> FLDict_GetBlob(
    ffi.Pointer<FLDict> blobDict,
  ) {
    return _FLDict_GetBlob(
      blobDict,
    );
  }

  late final _FLDict_GetBlob_ptr =
      _lookup<ffi.NativeFunction<_c_FLDict_GetBlob>>('FLDict_GetBlob');
  late final _dart_FLDict_GetBlob _FLDict_GetBlob =
      _FLDict_GetBlob_ptr.asFunction<_dart_FLDict_GetBlob>();

  /// Returns the length in bytes of a blob's content (from its `length` property).
  int CBLBlob_Length(
    ffi.Pointer<CBLBlob> arg0,
  ) {
    return _CBLBlob_Length(
      arg0,
    );
  }

  late final _CBLBlob_Length_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_Length>>('CBLBlob_Length');
  late final _dart_CBLBlob_Length _CBLBlob_Length =
      _CBLBlob_Length_ptr.asFunction<_dart_CBLBlob_Length>();

  /// Returns the cryptographic digest of a blob's content (from its `digest` property).
  FLSlice CBLBlob_Digest(
    ffi.Pointer<CBLBlob> arg0,
  ) {
    return _CBLBlob_Digest(
      arg0,
    );
  }

  late final _CBLBlob_Digest_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_Digest>>('CBLBlob_Digest');
  late final _dart_CBLBlob_Digest _CBLBlob_Digest =
      _CBLBlob_Digest_ptr.asFunction<_dart_CBLBlob_Digest>();

  /// Returns a blob's MIME type, if its metadata has a `content_type` property.
  FLSlice CBLBlob_ContentType(
    ffi.Pointer<CBLBlob> arg0,
  ) {
    return _CBLBlob_ContentType(
      arg0,
    );
  }

  late final _CBLBlob_ContentType_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_ContentType>>(
          'CBLBlob_ContentType');
  late final _dart_CBLBlob_ContentType _CBLBlob_ContentType =
      _CBLBlob_ContentType_ptr.asFunction<_dart_CBLBlob_ContentType>();

  /// Returns a blob's metadata. This includes the `digest`, `length`, `content_type`,
  /// and `@type` properties, as well as any custom ones that may have been added.
  ffi.Pointer<FLDict> CBLBlob_Properties(
    ffi.Pointer<CBLBlob> arg0,
  ) {
    return _CBLBlob_Properties(
      arg0,
    );
  }

  late final _CBLBlob_Properties_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_Properties>>('CBLBlob_Properties');
  late final _dart_CBLBlob_Properties _CBLBlob_Properties =
      _CBLBlob_Properties_ptr.asFunction<_dart_CBLBlob_Properties>();

  /// Returns a blob's metadata as JSON.
  FLSliceResult CBLBlob_ToJSON(
    ffi.Pointer<CBLBlob> blob,
  ) {
    return _CBLBlob_ToJSON(
      blob,
    );
  }

  late final _CBLBlob_ToJSON_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_ToJSON>>('CBLBlob_ToJSON');
  late final _dart_CBLBlob_ToJSON _CBLBlob_ToJSON =
      _CBLBlob_ToJSON_ptr.asFunction<_dart_CBLBlob_ToJSON>();

  /// Reads the blob's contents into memory and returns them.
  /// @note  You are responsible for releasing the result by calling \ref FLSliceResult_Release.
  FLSliceResult CBLBlob_Content(
    ffi.Pointer<CBLBlob> blob,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLBlob_Content(
      blob,
      outError,
    );
  }

  late final _CBLBlob_Content_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_Content>>('CBLBlob_Content');
  late final _dart_CBLBlob_Content _CBLBlob_Content =
      _CBLBlob_Content_ptr.asFunction<_dart_CBLBlob_Content>();

  /// Opens a stream for reading a blob's content.
  ffi.Pointer<CBLBlobReadStream> CBLBlob_OpenContentStream(
    ffi.Pointer<CBLBlob> blob,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLBlob_OpenContentStream(
      blob,
      outError,
    );
  }

  late final _CBLBlob_OpenContentStream_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_OpenContentStream>>(
          'CBLBlob_OpenContentStream');
  late final _dart_CBLBlob_OpenContentStream _CBLBlob_OpenContentStream =
      _CBLBlob_OpenContentStream_ptr.asFunction<
          _dart_CBLBlob_OpenContentStream>();

  /// Reads data from a blob.
  /// @param stream  The stream to read from.
  /// @param dst  The address to copy the read data to.
  /// @param maxLength  The maximum number of bytes to read.
  /// @param outError  On failure, an error will be stored here if non-NULL.
  /// @return  The actual number of bytes read; 0 if at EOF, -1 on error.
  int CBLBlobReader_Read(
    ffi.Pointer<CBLBlobReadStream> stream,
    ffi.Pointer<ffi.Void> dst,
    int maxLength,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLBlobReader_Read(
      stream,
      dst,
      maxLength,
      outError,
    );
  }

  late final _CBLBlobReader_Read_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlobReader_Read>>('CBLBlobReader_Read');
  late final _dart_CBLBlobReader_Read _CBLBlobReader_Read =
      _CBLBlobReader_Read_ptr.asFunction<_dart_CBLBlobReader_Read>();

  /// Closes a CBLBlobReadStream.
  void CBLBlobReader_Close(
    ffi.Pointer<CBLBlobReadStream> arg0,
  ) {
    return _CBLBlobReader_Close(
      arg0,
    );
  }

  late final _CBLBlobReader_Close_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlobReader_Close>>(
          'CBLBlobReader_Close');
  late final _dart_CBLBlobReader_Close _CBLBlobReader_Close =
      _CBLBlobReader_Close_ptr.asFunction<_dart_CBLBlobReader_Close>();

  /// Creates a new blob given its contents as a single block of data.
  /// @note  You are responsible for releasing the \ref CBLBlob, but not until after its document
  /// has been saved.
  /// @param contentType  The MIME type (optional).
  /// @param contents  The data's address and length.
  /// @return  A new CBLBlob instance.
  ffi.Pointer<CBLBlob> CBLBlob_CreateWithData(
    FLSlice contentType,
    FLSlice contents,
  ) {
    return _CBLBlob_CreateWithData(
      contentType,
      contents,
    );
  }

  late final _CBLBlob_CreateWithData_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_CreateWithData>>(
          'CBLBlob_CreateWithData');
  late final _dart_CBLBlob_CreateWithData _CBLBlob_CreateWithData =
      _CBLBlob_CreateWithData_ptr.asFunction<_dart_CBLBlob_CreateWithData>();

  /// Opens a stream for writing a new blob.
  /// You should next call \ref CBLBlobWriter_Write one or more times to write the data,
  /// then \ref CBLBlob_CreateWithStream to create the blob.
  ///
  /// If for some reason you need to abort, just call \ref CBLBlobWriter_Close.
  ffi.Pointer<CBLBlobWriteStream> CBLBlobWriter_Create(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLBlobWriter_Create(
      db,
      outError,
    );
  }

  late final _CBLBlobWriter_Create_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlobWriter_Create>>(
          'CBLBlobWriter_Create');
  late final _dart_CBLBlobWriter_Create _CBLBlobWriter_Create =
      _CBLBlobWriter_Create_ptr.asFunction<_dart_CBLBlobWriter_Create>();

  /// Closes a blob-writing stream, if you need to give up without creating a \ref CBLBlob.
  void CBLBlobWriter_Close(
    ffi.Pointer<CBLBlobWriteStream> arg0,
  ) {
    return _CBLBlobWriter_Close(
      arg0,
    );
  }

  late final _CBLBlobWriter_Close_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlobWriter_Close>>(
          'CBLBlobWriter_Close');
  late final _dart_CBLBlobWriter_Close _CBLBlobWriter_Close =
      _CBLBlobWriter_Close_ptr.asFunction<_dart_CBLBlobWriter_Close>();

  /// Writes data to a new blob.
  /// @param writer  The stream to write to.
  /// @param data  The address of the data to write.
  /// @param length  The length of the data to write.
  /// @param outError  On failure, error info will be written here.
  /// @return  True on success, false on failure.
  bool CBLBlobWriter_Write(
    ffi.Pointer<CBLBlobWriteStream> writer,
    ffi.Pointer<ffi.Void> data,
    int length,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLBlobWriter_Write(
          writer,
          data,
          length,
          outError,
        ) !=
        0;
  }

  late final _CBLBlobWriter_Write_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlobWriter_Write>>(
          'CBLBlobWriter_Write');
  late final _dart_CBLBlobWriter_Write _CBLBlobWriter_Write =
      _CBLBlobWriter_Write_ptr.asFunction<_dart_CBLBlobWriter_Write>();

  /// Creates a new blob after its data has been written to a \ref CBLBlobWriteStream.
  /// You should then add the blob to a mutable document as a property -- see
  /// \ref FLSlot_SetBlob.
  /// @note  You are responsible for releasing the CBLBlob reference.
  /// @note  Do not free the stream; the blob will do that.
  /// @param contentType  The MIME type (optional).
  /// @param writer  The blob-writing stream the data was written to.
  /// @return  A new CBLBlob instance.
  ffi.Pointer<CBLBlob> CBLBlob_CreateWithStream(
    FLSlice contentType,
    ffi.Pointer<CBLBlobWriteStream> writer,
  ) {
    return _CBLBlob_CreateWithStream(
      contentType,
      writer,
    );
  }

  late final _CBLBlob_CreateWithStream_ptr =
      _lookup<ffi.NativeFunction<_c_CBLBlob_CreateWithStream>>(
          'CBLBlob_CreateWithStream');
  late final _dart_CBLBlob_CreateWithStream _CBLBlob_CreateWithStream =
      _CBLBlob_CreateWithStream_ptr.asFunction<
          _dart_CBLBlob_CreateWithStream>();

  /// Stores a blob reference in a Fleece mutable Array or Dict.
  /// @param slot  The position in the collection, as returned by functions like
  /// \ref FLMutableArray_Set or \ref FLMutableDict_Set.
  /// @param blob  The CBLBlob to store (as a Dict) in the collection.
  void FLSlot_SetBlob(
    ffi.Pointer<FLSlot> slot,
    ffi.Pointer<CBLBlob> blob,
  ) {
    return _FLSlot_SetBlob(
      slot,
      blob,
    );
  }

  late final _FLSlot_SetBlob_ptr =
      _lookup<ffi.NativeFunction<_c_FLSlot_SetBlob>>('FLSlot_SetBlob');
  late final _dart_FLSlot_SetBlob _FLSlot_SetBlob =
      _FLSlot_SetBlob_ptr.asFunction<_dart_FLSlot_SetBlob>();

  /// Get a \ref CBLBlob object from the database using the \ref CBLBlob properties.
  ///
  /// The \ref CBLBlob properties is a blob's metadata containing two required fields
  /// which are a special marker property `"@type":"blob"`, and property `digest` whose value
  /// is a hex SHA-1 digest of the blob's data. The other optional properties are `length` and
  /// `content_type`. To obtain the \ref CBLBlob properties from a \ref CBLBlob,
  /// call \ref CBLBlob_Properties function.
  ///
  /// @note   You must release the \ref CBLBlob when you're finished with it.
  /// @param db   The database.
  /// @param properties   The properties for getting the \ref CBLBlob object.
  /// @param outError On failure, error info will be written here if specified. A nonexistent blob
  /// is not considered a failure; in that event the error code will be zero.
  /// @return A \ref CBLBlob instance, or NULL if the doc doesn't exist or an error occurred.
  ffi.Pointer<CBLBlob> CBLDatabase_GetBlob(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<FLDict> properties,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_GetBlob(
      db,
      properties,
      outError,
    );
  }

  late final _CBLDatabase_GetBlob_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_GetBlob>>(
          'CBLDatabase_GetBlob');
  late final _dart_CBLDatabase_GetBlob _CBLDatabase_GetBlob =
      _CBLDatabase_GetBlob_ptr.asFunction<_dart_CBLDatabase_GetBlob>();

  /// Save a new \ref CBLBlob object into the database without associating it with
  /// any documents. The properties of the saved \ref CBLBlob object will include
  /// information necessary for referencing the \ref CBLBlob object in the properties
  /// of the document to be saved into the database.
  ///
  /// Normally you do not need to use this function unless you are in the situation
  /// (e.g. developing javascript binding) that you cannot retain the \ref CBLBlob
  /// object until the document containing the \ref CBLBlob object is successfully
  /// saved into the database.
  /// @Note The saved \ref CBLBlob objects that are not associated with any documents
  /// will be removed from the database when compacting the database.
  /// @param db   The database.
  /// @param blob The The CBLBlob to save.
  /// @param outError On failure, error info will be written here.
  bool CBLDatabase_SaveBlob(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLBlob> blob,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_SaveBlob(
          db,
          blob,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_SaveBlob_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_SaveBlob>>(
          'CBLDatabase_SaveBlob');
  late final _dart_CBLDatabase_SaveBlob _CBLDatabase_SaveBlob =
      _CBLDatabase_SaveBlob_ptr.asFunction<_dart_CBLDatabase_SaveBlob>();

  /// Returns the default database configuration.
  CBLDatabaseConfiguration CBLDatabaseConfiguration_Default() {
    return _CBLDatabaseConfiguration_Default();
  }

  late final _CBLDatabaseConfiguration_Default_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabaseConfiguration_Default>>(
          'CBLDatabaseConfiguration_Default');
  late final _dart_CBLDatabaseConfiguration_Default
      _CBLDatabaseConfiguration_Default = _CBLDatabaseConfiguration_Default_ptr
          .asFunction<_dart_CBLDatabaseConfiguration_Default>();

  /// Returns true if a database with the given name exists in the given directory.
  /// @param name  The database name (without the ".cblite2" extension.)
  /// @param inDirectory  The directory containing the database. If NULL, `name` must be an
  /// absolute or relative path to the database.
  bool CBL_DatabaseExists(
    FLSlice name,
    FLSlice inDirectory,
  ) {
    return _CBL_DatabaseExists(
          name,
          inDirectory,
        ) !=
        0;
  }

  late final _CBL_DatabaseExists_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_DatabaseExists>>('CBL_DatabaseExists');
  late final _dart_CBL_DatabaseExists _CBL_DatabaseExists =
      _CBL_DatabaseExists_ptr.asFunction<_dart_CBL_DatabaseExists>();

  /// Copies a database file to a new location, and assigns it a new internal UUID to distinguish
  /// it from the original database when replicating.
  /// @param fromPath  The full filesystem path to the original database (including extension).
  /// @param toName  The new database name (without the ".cblite2" extension.)
  /// @param config  The database configuration (directory and encryption option.)
  bool CBL_CopyDatabase(
    FLSlice fromPath,
    FLSlice toName,
    ffi.Pointer<CBLDatabaseConfiguration> config,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBL_CopyDatabase(
          fromPath,
          toName,
          config,
          outError,
        ) !=
        0;
  }

  late final _CBL_CopyDatabase_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_CopyDatabase>>('CBL_CopyDatabase');
  late final _dart_CBL_CopyDatabase _CBL_CopyDatabase =
      _CBL_CopyDatabase_ptr.asFunction<_dart_CBL_CopyDatabase>();

  /// Deletes a database file. If the database file is open, an error is returned.
  /// @param name  The database name (without the ".cblite2" extension.)
  /// @param inDirectory  The directory containing the database. If NULL, `name` must be an
  /// absolute or relative path to the database.
  /// @param outError  On return, will be set to the error that occurred, or a 0 code if no error.
  /// @return  True if the database was deleted, false if it doesn't exist or deletion failed.
  /// (You can tell the last two cases apart by looking at \p outError.)
  bool CBL_DeleteDatabase(
    FLSlice name,
    FLSlice inDirectory,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBL_DeleteDatabase(
          name,
          inDirectory,
          outError,
        ) !=
        0;
  }

  late final _CBL_DeleteDatabase_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_DeleteDatabase>>('CBL_DeleteDatabase');
  late final _dart_CBL_DeleteDatabase _CBL_DeleteDatabase =
      _CBL_DeleteDatabase_ptr.asFunction<_dart_CBL_DeleteDatabase>();

  /// Opens a database, or creates it if it doesn't exist yet, returning a new \ref CBLDatabase
  /// instance.
  /// It's OK to open the same database file multiple times. Each \ref CBLDatabase instance is
  /// independent of the others (and must be separately closed and released.)
  /// @param name  The database name (without the ".cblite2" extension.)
  /// @param config  The database configuration (directory and encryption option.)
  /// @param outError  On failure, the error will be written here.
  /// @return  The new database object, or NULL on failure.
  ffi.Pointer<CBLDatabase> CBLDatabase_Open(
    FLSlice name,
    ffi.Pointer<CBLDatabaseConfiguration> config,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_Open(
      name,
      config,
      outError,
    );
  }

  late final _CBLDatabase_Open_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Open>>('CBLDatabase_Open');
  late final _dart_CBLDatabase_Open _CBLDatabase_Open =
      _CBLDatabase_Open_ptr.asFunction<_dart_CBLDatabase_Open>();

  /// Closes an open database.
  bool CBLDatabase_Close(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_Close(
          arg0,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_Close_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Close>>('CBLDatabase_Close');
  late final _dart_CBLDatabase_Close _CBLDatabase_Close =
      _CBLDatabase_Close_ptr.asFunction<_dart_CBLDatabase_Close>();

  /// Closes and deletes a database. If there are any other connections to the database,
  /// an error is returned.
  bool CBLDatabase_Delete(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_Delete(
          arg0,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_Delete_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Delete>>('CBLDatabase_Delete');
  late final _dart_CBLDatabase_Delete _CBLDatabase_Delete =
      _CBLDatabase_Delete_ptr.asFunction<_dart_CBLDatabase_Delete>();

  /// Begins a transaction. You **must** later call \ref
  /// CBLDatabase_EndTransaction to commit or abort the transaction.
  /// @note  Multiple writes are much faster when grouped in a transaction.
  /// @note  Changes will not be visible to other CBLDatabase instances on the same database until
  /// the transaction ends.
  /// @note  Transactions can nest. Changes are not committed until the outer transaction ends.
  bool CBLDatabase_BeginTransaction(
    ffi.Pointer<CBLDatabase> arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_BeginTransaction(
          arg0,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_BeginTransaction_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_BeginTransaction>>(
          'CBLDatabase_BeginTransaction');
  late final _dart_CBLDatabase_BeginTransaction _CBLDatabase_BeginTransaction =
      _CBLDatabase_BeginTransaction_ptr.asFunction<
          _dart_CBLDatabase_BeginTransaction>();

  /// Ends a transaction, either committing or aborting.
  bool CBLDatabase_EndTransaction(
    ffi.Pointer<CBLDatabase> arg0,
    bool commit,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_EndTransaction(
          arg0,
          commit ? 1 : 0,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_EndTransaction_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_EndTransaction>>(
          'CBLDatabase_EndTransaction');
  late final _dart_CBLDatabase_EndTransaction _CBLDatabase_EndTransaction =
      _CBLDatabase_EndTransaction_ptr.asFunction<
          _dart_CBLDatabase_EndTransaction>();

  /// Performs database maintenance.
  bool CBLDatabase_PerformMaintenance(
    ffi.Pointer<CBLDatabase> db,
    int type,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_PerformMaintenance(
          db,
          type,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_PerformMaintenance_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_PerformMaintenance>>(
          'CBLDatabase_PerformMaintenance');
  late final _dart_CBLDatabase_PerformMaintenance
      _CBLDatabase_PerformMaintenance = _CBLDatabase_PerformMaintenance_ptr
          .asFunction<_dart_CBLDatabase_PerformMaintenance>();

  /// Returns the database's name.
  FLSlice CBLDatabase_Name(
    ffi.Pointer<CBLDatabase> arg0,
  ) {
    return _CBLDatabase_Name(
      arg0,
    );
  }

  late final _CBLDatabase_Name_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Name>>('CBLDatabase_Name');
  late final _dart_CBLDatabase_Name _CBLDatabase_Name =
      _CBLDatabase_Name_ptr.asFunction<_dart_CBLDatabase_Name>();

  /// Returns the database's full filesystem path.
  FLSliceResult CBLDatabase_Path(
    ffi.Pointer<CBLDatabase> arg0,
  ) {
    return _CBLDatabase_Path(
      arg0,
    );
  }

  late final _CBLDatabase_Path_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Path>>('CBLDatabase_Path');
  late final _dart_CBLDatabase_Path _CBLDatabase_Path =
      _CBLDatabase_Path_ptr.asFunction<_dart_CBLDatabase_Path>();

  /// Returns the number of documents in the database.
  int CBLDatabase_Count(
    ffi.Pointer<CBLDatabase> arg0,
  ) {
    return _CBLDatabase_Count(
      arg0,
    );
  }

  late final _CBLDatabase_Count_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Count>>('CBLDatabase_Count');
  late final _dart_CBLDatabase_Count _CBLDatabase_Count =
      _CBLDatabase_Count_ptr.asFunction<_dart_CBLDatabase_Count>();

  /// Returns the database's configuration, as given when it was opened.
  /// @note  The encryption key is not filled in, for security reasons.
  CBLDatabaseConfiguration CBLDatabase_Config(
    ffi.Pointer<CBLDatabase> arg0,
  ) {
    return _CBLDatabase_Config(
      arg0,
    );
  }

  late final _CBLDatabase_Config_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_Config>>('CBLDatabase_Config');
  late final _dart_CBLDatabase_Config _CBLDatabase_Config =
      _CBLDatabase_Config_ptr.asFunction<_dart_CBLDatabase_Config>();

  /// Registers a database change listener callback. It will be called after one or more
  /// documents are changed on disk.
  /// @param db  The database to observe.
  /// @param listener  The callback to be invoked.
  /// @param context  An opaque value that will be passed to the callback.
  /// @return  A token to be passed to \ref CBLListener_Remove when it's time to remove the
  /// listener.
  ffi.Pointer<CBLListenerToken> CBLDatabase_AddChangeListener(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<ffi.NativeFunction<CBLDatabaseChangeListener>> listener,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLDatabase_AddChangeListener(
      db,
      listener,
      context,
    );
  }

  late final _CBLDatabase_AddChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_AddChangeListener>>(
          'CBLDatabase_AddChangeListener');
  late final _dart_CBLDatabase_AddChangeListener
      _CBLDatabase_AddChangeListener = _CBLDatabase_AddChangeListener_ptr
          .asFunction<_dart_CBLDatabase_AddChangeListener>();

  /// Switches the database to buffered-notification mode. Notifications for objects belonging
  /// to this database (documents, queries, replicators, and of course the database) will not be
  /// called immediately; your \ref CBLNotificationsReadyCallback will be called instead.
  /// @param db  The database whose notifications are to be buffered.
  /// @param callback  The function to be called when a notification is available.
  /// @param context  An arbitrary value that will be passed to the callback.
  void CBLDatabase_BufferNotifications(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<ffi.NativeFunction<CBLNotificationsReadyCallback>> callback,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLDatabase_BufferNotifications(
      db,
      callback,
      context,
    );
  }

  late final _CBLDatabase_BufferNotifications_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_BufferNotifications>>(
          'CBLDatabase_BufferNotifications');
  late final _dart_CBLDatabase_BufferNotifications
      _CBLDatabase_BufferNotifications = _CBLDatabase_BufferNotifications_ptr
          .asFunction<_dart_CBLDatabase_BufferNotifications>();

  /// Immediately issues all pending notifications for this database, by calling their listener
  /// callbacks.
  void CBLDatabase_SendNotifications(
    ffi.Pointer<CBLDatabase> db,
  ) {
    return _CBLDatabase_SendNotifications(
      db,
    );
  }

  late final _CBLDatabase_SendNotifications_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_SendNotifications>>(
          'CBLDatabase_SendNotifications');
  late final _dart_CBLDatabase_SendNotifications
      _CBLDatabase_SendNotifications = _CBLDatabase_SendNotifications_ptr
          .asFunction<_dart_CBLDatabase_SendNotifications>();

  /// Reads a document from the database, creating a new (immutable) \ref CBLDocument object.
  /// Each call to this function creates a new object (which must later be released.)
  /// @note  If you are reading the document in order to make changes to it, call
  /// \ref CBLDatabase_GetMutableDocument instead.
  /// @param database  The database.
  /// @param docID  The ID of the document.
  /// @param outError  On failure, the error will be written here. (A nonexistent document is not
  /// considered a failure; in that event the error code will be zero.)
  /// @return  A new \ref CBLDocument instance, or NULL if the doc doesn't exist or an error occurred.
  ffi.Pointer<CBLDocument> CBLDatabase_GetDocument(
    ffi.Pointer<CBLDatabase> database,
    FLSlice docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_GetDocument(
      database,
      docID,
      outError,
    );
  }

  late final _CBLDatabase_GetDocument_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_GetDocument>>(
          'CBLDatabase_GetDocument');
  late final _dart_CBLDatabase_GetDocument _CBLDatabase_GetDocument =
      _CBLDatabase_GetDocument_ptr.asFunction<_dart_CBLDatabase_GetDocument>();

  /// Saves a (mutable) document to the database.
  /// \warning If a newer revision has been saved since \p doc was loaded, it will be overwritten by
  /// this one. This can lead to data loss! To avoid this, call
  /// \ref CBLDatabase_SaveDocumentWithConcurrencyControl or
  /// \ref CBLDatabase_SaveDocumentWithConflictHandler instead.
  /// @param db  The database to save to.
  /// @param doc  The mutable document to save.
  /// @param outError  On failure, the error will be written here.
  /// @return  True on success, false on failure.
  bool CBLDatabase_SaveDocument(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_SaveDocument(
          db,
          doc,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_SaveDocument_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_SaveDocument>>(
          'CBLDatabase_SaveDocument');
  late final _dart_CBLDatabase_SaveDocument _CBLDatabase_SaveDocument =
      _CBLDatabase_SaveDocument_ptr.asFunction<
          _dart_CBLDatabase_SaveDocument>();

  /// Saves a (mutable) document to the database.
  /// If a conflicting revision has been saved since \p doc was loaded, the \p concurrency
  /// parameter specifies whether the save should fail, or the conflicting revision should
  /// be overwritten with the revision being saved.
  /// If you need finer-grained control, call \ref CBLDatabase_SaveDocumentWithConflictHandler instead.
  /// @param db  The database to save to.
  /// @param doc  The mutable document to save.
  /// @param concurrency  Conflict-handling strategy (fail or overwrite).
  /// @param outError  On failure, the error will be written here.
  /// @return  True on success, false on failure.
  bool CBLDatabase_SaveDocumentWithConcurrencyControl(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    int concurrency,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_SaveDocumentWithConcurrencyControl(
          db,
          doc,
          concurrency,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_SaveDocumentWithConcurrencyControl_ptr = _lookup<
          ffi.NativeFunction<
              _c_CBLDatabase_SaveDocumentWithConcurrencyControl>>(
      'CBLDatabase_SaveDocumentWithConcurrencyControl');
  late final _dart_CBLDatabase_SaveDocumentWithConcurrencyControl
      _CBLDatabase_SaveDocumentWithConcurrencyControl =
      _CBLDatabase_SaveDocumentWithConcurrencyControl_ptr.asFunction<
          _dart_CBLDatabase_SaveDocumentWithConcurrencyControl>();

  /// Saves a (mutable) document to the database, allowing for custom conflict handling in the event
  /// that the document has been updated since \p doc was loaded.
  /// @param db  The database to save to.
  /// @param doc  The mutable document to save.
  /// @param conflictHandler  The callback to be invoked if there is a conflict.
  /// @param context  An arbitrary value to be passed to the \p conflictHandler.
  /// @param outError  On failure, the error will be written here.
  /// @return  True on success, false on failure.
  bool CBLDatabase_SaveDocumentWithConflictHandler(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> doc,
    ffi.Pointer<ffi.NativeFunction<CBLConflictHandler>> conflictHandler,
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_SaveDocumentWithConflictHandler(
          db,
          doc,
          conflictHandler,
          context,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_SaveDocumentWithConflictHandler_ptr = _lookup<
          ffi.NativeFunction<_c_CBLDatabase_SaveDocumentWithConflictHandler>>(
      'CBLDatabase_SaveDocumentWithConflictHandler');
  late final _dart_CBLDatabase_SaveDocumentWithConflictHandler
      _CBLDatabase_SaveDocumentWithConflictHandler =
      _CBLDatabase_SaveDocumentWithConflictHandler_ptr.asFunction<
          _dart_CBLDatabase_SaveDocumentWithConflictHandler>();

  /// Deletes a document from the database. Deletions are replicated.
  /// @warning  You are still responsible for releasing the CBLDocument.
  /// @param db  The database containing the document.
  /// @param document  The document to delete.
  /// @param outError  On failure, the error will be written here.
  /// @return  True if the document was deleted, false if an error occurred.
  bool CBLDatabase_DeleteDocument(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_DeleteDocument(
          db,
          document,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_DeleteDocument_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_DeleteDocument>>(
          'CBLDatabase_DeleteDocument');
  late final _dart_CBLDatabase_DeleteDocument _CBLDatabase_DeleteDocument =
      _CBLDatabase_DeleteDocument_ptr.asFunction<
          _dart_CBLDatabase_DeleteDocument>();

  /// Deletes a document from the database. Deletions are replicated.
  /// @warning  You are still responsible for releasing the CBLDocument.
  /// @param db  The database containing the document.
  /// @param document  The document to delete.
  /// @param concurrency  Conflict-handling strategy.
  /// @param outError  On failure, the error will be written here.
  /// @return  True if the document was deleted, false if an error occurred.
  bool CBLDatabase_DeleteDocumentWithConcurrencyControl(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    int concurrency,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_DeleteDocumentWithConcurrencyControl(
          db,
          document,
          concurrency,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_DeleteDocumentWithConcurrencyControl_ptr = _lookup<
          ffi.NativeFunction<
              _c_CBLDatabase_DeleteDocumentWithConcurrencyControl>>(
      'CBLDatabase_DeleteDocumentWithConcurrencyControl');
  late final _dart_CBLDatabase_DeleteDocumentWithConcurrencyControl
      _CBLDatabase_DeleteDocumentWithConcurrencyControl =
      _CBLDatabase_DeleteDocumentWithConcurrencyControl_ptr.asFunction<
          _dart_CBLDatabase_DeleteDocumentWithConcurrencyControl>();

  /// Purges a document. This removes all traces of the document from the database.
  /// Purges are _not_ replicated. If the document is changed on a server, it will be re-created
  /// when pulled.
  /// @warning  You are still responsible for releasing the \ref CBLDocument reference.
  /// @note If you don't have the document in memory already, \ref CBLDatabase_PurgeDocumentByID is a
  /// simpler shortcut.
  /// @param db  The database containing the document.
  /// @param document  The document to delete.
  /// @param outError  On failure, the error will be written here.
  /// @return  True if the document was purged, false if it doesn't exist or the purge failed.
  bool CBLDatabase_PurgeDocument(
    ffi.Pointer<CBLDatabase> db,
    ffi.Pointer<CBLDocument> document,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_PurgeDocument(
          db,
          document,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_PurgeDocument_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_PurgeDocument>>(
          'CBLDatabase_PurgeDocument');
  late final _dart_CBLDatabase_PurgeDocument _CBLDatabase_PurgeDocument =
      _CBLDatabase_PurgeDocument_ptr.asFunction<
          _dart_CBLDatabase_PurgeDocument>();

  /// Purges a document, given only its ID.
  /// @note  If no document with that ID exists, this function will return false but the error
  /// code will be zero.
  /// @param database  The database.
  /// @param docID  The document ID to purge.
  /// @param outError  On failure, the error will be written here.
  /// @return  True if the document was purged, false if it doesn't exist or the purge failed.
  bool CBLDatabase_PurgeDocumentByID(
    ffi.Pointer<CBLDatabase> database,
    FLSlice docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_PurgeDocumentByID(
          database,
          docID,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_PurgeDocumentByID_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_PurgeDocumentByID>>(
          'CBLDatabase_PurgeDocumentByID');
  late final _dart_CBLDatabase_PurgeDocumentByID
      _CBLDatabase_PurgeDocumentByID = _CBLDatabase_PurgeDocumentByID_ptr
          .asFunction<_dart_CBLDatabase_PurgeDocumentByID>();

  /// Reads a document from the database, in mutable form that can be updated and saved.
  /// (This function is otherwise identical to \ref CBLDatabase_GetDocument.)
  /// @note  You must release the document when you're done with it.
  /// @param database  The database.
  /// @param docID  The ID of the document.
  /// @param outError  On failure, the error will be written here. (A nonexistent document is not
  /// considered a failure; in that event the error code will be zero.)
  /// @return  A new \ref CBLDocument instance, or NULL if the doc doesn't exist or an error occurred.
  ffi.Pointer<CBLDocument> CBLDatabase_GetMutableDocument(
    ffi.Pointer<CBLDatabase> database,
    FLSlice docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_GetMutableDocument(
      database,
      docID,
      outError,
    );
  }

  late final _CBLDatabase_GetMutableDocument_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_GetMutableDocument>>(
          'CBLDatabase_GetMutableDocument');
  late final _dart_CBLDatabase_GetMutableDocument
      _CBLDatabase_GetMutableDocument = _CBLDatabase_GetMutableDocument_ptr
          .asFunction<_dart_CBLDatabase_GetMutableDocument>();

  /// Creates a new, empty document in memory, with a randomly-generated unique ID.
  /// It will not be added to a database until saved.
  /// @return  The new mutable document instance.
  ffi.Pointer<CBLDocument> CBLDocument_Create() {
    return _CBLDocument_Create();
  }

  late final _CBLDocument_Create_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_Create>>('CBLDocument_Create');
  late final _dart_CBLDocument_Create _CBLDocument_Create =
      _CBLDocument_Create_ptr.asFunction<_dart_CBLDocument_Create>();

  /// Creates a new, empty document in memory, with the given ID.
  /// It will not be added to a database until saved.
  /// @note  If the given ID conflicts with a document already in the database, that will not
  /// be apparent until this document is saved. At that time, the result depends on the
  /// conflict handling mode used when saving; see the save functions for details.
  /// @param docID  The ID of the new document, or NULL to assign a new unique ID.
  /// @return  The new mutable document instance.
  ffi.Pointer<CBLDocument> CBLDocument_CreateWithID(
    FLSlice docID,
  ) {
    return _CBLDocument_CreateWithID(
      docID,
    );
  }

  late final _CBLDocument_CreateWithID_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_CreateWithID>>(
          'CBLDocument_CreateWithID');
  late final _dart_CBLDocument_CreateWithID _CBLDocument_CreateWithID =
      _CBLDocument_CreateWithID_ptr.asFunction<
          _dart_CBLDocument_CreateWithID>();

  /// Creates a new mutable CBLDocument instance that refers to the same document as the original.
  /// If the original document has unsaved changes, the new one will also start out with the same
  /// changes; but mutating one document thereafter will not affect the other.
  /// @note  You must release the new reference when you're done with it. Similarly, the original
  /// document still exists and must also be released when you're done with it.
  ffi.Pointer<CBLDocument> CBLDocument_MutableCopy(
    ffi.Pointer<CBLDocument> original,
  ) {
    return _CBLDocument_MutableCopy(
      original,
    );
  }

  late final _CBLDocument_MutableCopy_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_MutableCopy>>(
          'CBLDocument_MutableCopy');
  late final _dart_CBLDocument_MutableCopy _CBLDocument_MutableCopy =
      _CBLDocument_MutableCopy_ptr.asFunction<_dart_CBLDocument_MutableCopy>();

  /// Returns a document's ID.
  FLSlice CBLDocument_ID(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_ID(
      arg0,
    );
  }

  late final _CBLDocument_ID_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_ID>>('CBLDocument_ID');
  late final _dart_CBLDocument_ID _CBLDocument_ID =
      _CBLDocument_ID_ptr.asFunction<_dart_CBLDocument_ID>();

  /// Returns a document's revision ID, which is a short opaque string that's guaranteed to be
  /// unique to every change made to the document.
  /// If the document doesn't exist yet, this function returns NULL.
  FLSlice CBLDocument_RevisionID(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_RevisionID(
      arg0,
    );
  }

  late final _CBLDocument_RevisionID_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_RevisionID>>(
          'CBLDocument_RevisionID');
  late final _dart_CBLDocument_RevisionID _CBLDocument_RevisionID =
      _CBLDocument_RevisionID_ptr.asFunction<_dart_CBLDocument_RevisionID>();

  /// Returns a document's current sequence in the local database.
  /// This number increases every time the document is saved, and a more recently saved document
  /// will have a greater sequence number than one saved earlier, so sequences may be used as an
  /// abstract 'clock' to tell relative modification times.
  int CBLDocument_Sequence(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_Sequence(
      arg0,
    );
  }

  late final _CBLDocument_Sequence_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_Sequence>>(
          'CBLDocument_Sequence');
  late final _dart_CBLDocument_Sequence _CBLDocument_Sequence =
      _CBLDocument_Sequence_ptr.asFunction<_dart_CBLDocument_Sequence>();

  /// Returns a document's properties as a dictionary.
  /// @note  The dictionary object is owned by the document; you do not need to release it.
  /// @warning  When the document is released, this reference to the properties becomes invalid.
  /// If you need to use any properties after releasing the document, you must retain them
  /// by calling \ref FLValue_Retain (and of course later release them.)
  /// @warning  This dictionary _reference_ is immutable, but if the document is mutable the
  /// underlying dictionary itself is mutable and could be modified through a mutable
  /// reference obtained via \ref CBLDocument_MutableProperties. If you need to preserve the
  /// properties, call \ref FLDict_MutableCopy to make a deep copy.
  ffi.Pointer<FLDict> CBLDocument_Properties(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_Properties(
      arg0,
    );
  }

  late final _CBLDocument_Properties_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_Properties>>(
          'CBLDocument_Properties');
  late final _dart_CBLDocument_Properties _CBLDocument_Properties =
      _CBLDocument_Properties_ptr.asFunction<_dart_CBLDocument_Properties>();

  /// Returns a mutable document's properties as a mutable dictionary.
  /// You may modify this dictionary and then call \ref CBLDatabase_SaveDocument to persist the changes.
  /// @note  The dictionary object is owned by the document; you do not need to release it.
  /// @note  Every call to this function returns the same mutable collection. This is the
  /// same collection returned by \ref CBLDocument_Properties.
  /// @warning  When the document is released, this reference to the properties becomes invalid.
  /// If you need to use any properties after releasing the document, you must retain them
  /// by calling \ref FLValue_Retain (and of course later release them.)
  ffi.Pointer<FLDict> CBLDocument_MutableProperties(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_MutableProperties(
      arg0,
    );
  }

  late final _CBLDocument_MutableProperties_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_MutableProperties>>(
          'CBLDocument_MutableProperties');
  late final _dart_CBLDocument_MutableProperties
      _CBLDocument_MutableProperties = _CBLDocument_MutableProperties_ptr
          .asFunction<_dart_CBLDocument_MutableProperties>();

  /// Sets a mutable document's properties.
  /// Call \ref CBLDatabase_SaveDocument to persist the changes.
  /// @note  The dictionary object will be retained by the document. You are responsible for
  /// releasing any retained reference(s) you have to it.
  void CBLDocument_SetProperties(
    ffi.Pointer<CBLDocument> arg0,
    ffi.Pointer<FLDict> properties,
  ) {
    return _CBLDocument_SetProperties(
      arg0,
      properties,
    );
  }

  late final _CBLDocument_SetProperties_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_SetProperties>>(
          'CBLDocument_SetProperties');
  late final _dart_CBLDocument_SetProperties _CBLDocument_SetProperties =
      _CBLDocument_SetProperties_ptr.asFunction<
          _dart_CBLDocument_SetProperties>();

  /// Returns a document's properties as JSON.
  /// @note  You are responsible for releasing the result by calling \ref FLSliceResult_Release.
  FLSliceResult CBLDocument_CreateJSON(
    ffi.Pointer<CBLDocument> arg0,
  ) {
    return _CBLDocument_CreateJSON(
      arg0,
    );
  }

  late final _CBLDocument_CreateJSON_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_CreateJSON>>(
          'CBLDocument_CreateJSON');
  late final _dart_CBLDocument_CreateJSON _CBLDocument_CreateJSON =
      _CBLDocument_CreateJSON_ptr.asFunction<_dart_CBLDocument_CreateJSON>();

  /// Sets a mutable document's properties from a JSON string.
  bool CBLDocument_SetJSON(
    ffi.Pointer<CBLDocument> arg0,
    FLSlice json,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDocument_SetJSON(
          arg0,
          json,
          outError,
        ) !=
        0;
  }

  late final _CBLDocument_SetJSON_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDocument_SetJSON>>(
          'CBLDocument_SetJSON');
  late final _dart_CBLDocument_SetJSON _CBLDocument_SetJSON =
      _CBLDocument_SetJSON_ptr.asFunction<_dart_CBLDocument_SetJSON>();

  /// Returns the time, if any, at which a given document will expire and be purged.
  /// Documents don't normally expire; you have to call \ref CBLDatabase_SetDocumentExpiration
  /// to set a document's expiration time.
  /// @param db  The database.
  /// @param docID  The ID of the document.
  /// @param outError  On failure, an error is written here.
  /// @return  The expiration time as a CBLTimestamp (milliseconds since Unix epoch),
  /// or 0 if the document does not have an expiration,
  /// or -1 if the call failed.
  int CBLDatabase_GetDocumentExpiration(
    ffi.Pointer<CBLDatabase> db,
    FLSlice docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_GetDocumentExpiration(
      db,
      docID,
      outError,
    );
  }

  late final _CBLDatabase_GetDocumentExpiration_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_GetDocumentExpiration>>(
          'CBLDatabase_GetDocumentExpiration');
  late final _dart_CBLDatabase_GetDocumentExpiration
      _CBLDatabase_GetDocumentExpiration =
      _CBLDatabase_GetDocumentExpiration_ptr.asFunction<
          _dart_CBLDatabase_GetDocumentExpiration>();

  /// Sets or clears the expiration time of a document.
  /// @param db  The database.
  /// @param docID  The ID of the document.
  /// @param expiration  The expiration time as a CBLTimestamp (milliseconds since Unix epoch),
  /// or 0 if the document should never expire.
  /// @param outError  On failure, an error is written here.
  /// @return  True on success, false on failure.
  bool CBLDatabase_SetDocumentExpiration(
    ffi.Pointer<CBLDatabase> db,
    FLSlice docID,
    int expiration,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_SetDocumentExpiration(
          db,
          docID,
          expiration,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_SetDocumentExpiration_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_SetDocumentExpiration>>(
          'CBLDatabase_SetDocumentExpiration');
  late final _dart_CBLDatabase_SetDocumentExpiration
      _CBLDatabase_SetDocumentExpiration =
      _CBLDatabase_SetDocumentExpiration_ptr.asFunction<
          _dart_CBLDatabase_SetDocumentExpiration>();

  /// Registers a document change listener callback. It will be called after a specific document
  /// is changed on disk.
  /// @param db  The database to observe.
  /// @param docID  The ID of the document to observe.
  /// @param listener  The callback to be invoked.
  /// @param context  An opaque value that will be passed to the callback.
  /// @return  A token to be passed to \ref CBLListener_Remove when it's time to remove the
  /// listener.
  ffi.Pointer<CBLListenerToken> CBLDatabase_AddDocumentChangeListener(
    ffi.Pointer<CBLDatabase> db,
    FLSlice docID,
    ffi.Pointer<ffi.NativeFunction<CBLDocumentChangeListener>> listener,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLDatabase_AddDocumentChangeListener(
      db,
      docID,
      listener,
      context,
    );
  }

  late final _CBLDatabase_AddDocumentChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_AddDocumentChangeListener>>(
          'CBLDatabase_AddDocumentChangeListener');
  late final _dart_CBLDatabase_AddDocumentChangeListener
      _CBLDatabase_AddDocumentChangeListener =
      _CBLDatabase_AddDocumentChangeListener_ptr.asFunction<
          _dart_CBLDatabase_AddDocumentChangeListener>();

  /// Formats and writes a message to the log, in the given domain at the given level.
  /// \warning This function takes a `printf`-style format string, with extra parameters to match the format placeholders, and has the same security vulnerabilities as other `printf`-style functions.
  ///
  /// If you are logging a fixed string, call \ref CBL_LogMessage instead, otherwise any `%`
  /// characters in the `format` string will be misinterpreted as placeholders and the dreaded
  /// Undefined Behavior will result, possibly including crashes or overwriting the stack.
  /// @param domain  The log domain to associate this message with.
  /// @param level  The severity of the message. If this is lower than the current minimum level for the domain
  /// (as set by \ref CBLLog_SetConsoleLevel), nothing is logged.
  /// @param format  A `printf`-style format string. `%` characters in this string introduce parameters,
  /// and corresponding arguments must follow.
  void CBL_Log(
    int domain,
    int level,
    ffi.Pointer<ffi.Int8> format,
  ) {
    return _CBL_Log(
      domain,
      level,
      format,
    );
  }

  late final _CBL_Log_ptr = _lookup<ffi.NativeFunction<_c_CBL_Log>>('CBL_Log');
  late final _dart_CBL_Log _CBL_Log = _CBL_Log_ptr.asFunction<_dart_CBL_Log>();

  /// Writes a pre-formatted message to the log, exactly as given.
  /// @param domain  The log domain to associate this message with.
  /// @param level  The severity of the message. If this is lower than the current minimum level for the domain
  /// (as set by \ref CBLLog_SetConsoleLevel), nothing is logged.
  /// @param message  The exact message to write to the log.
  void CBL_LogMessage(
    int domain,
    int level,
    FLSlice message,
  ) {
    return _CBL_LogMessage(
      domain,
      level,
      message,
    );
  }

  late final _CBL_LogMessage_ptr =
      _lookup<ffi.NativeFunction<_c_CBL_LogMessage>>('CBL_LogMessage');
  late final _dart_CBL_LogMessage _CBL_LogMessage =
      _CBL_LogMessage_ptr.asFunction<_dart_CBL_LogMessage>();

  /// Gets the current log level for debug console logging.
  /// Only messages at this level or higher will be logged to the console.
  int CBLLog_ConsoleLevel() {
    return _CBLLog_ConsoleLevel();
  }

  late final _CBLLog_ConsoleLevel_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_ConsoleLevel>>(
          'CBLLog_ConsoleLevel');
  late final _dart_CBLLog_ConsoleLevel _CBLLog_ConsoleLevel =
      _CBLLog_ConsoleLevel_ptr.asFunction<_dart_CBLLog_ConsoleLevel>();

  /// Sets the detail level of logging.
  /// Only messages whose level is  the given level will be logged to the console.
  void CBLLog_SetConsoleLevel(
    int arg0,
  ) {
    return _CBLLog_SetConsoleLevel(
      arg0,
    );
  }

  late final _CBLLog_SetConsoleLevel_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_SetConsoleLevel>>(
          'CBLLog_SetConsoleLevel');
  late final _dart_CBLLog_SetConsoleLevel _CBLLog_SetConsoleLevel =
      _CBLLog_SetConsoleLevel_ptr.asFunction<_dart_CBLLog_SetConsoleLevel>();

  /// Gets the current log level for debug console logging.
  /// Only messages at this level or higher will be logged to the callback.
  int CBLLog_CallbackLevel() {
    return _CBLLog_CallbackLevel();
  }

  late final _CBLLog_CallbackLevel_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_CallbackLevel>>(
          'CBLLog_CallbackLevel');
  late final _dart_CBLLog_CallbackLevel _CBLLog_CallbackLevel =
      _CBLLog_CallbackLevel_ptr.asFunction<_dart_CBLLog_CallbackLevel>();

  /// Sets the detail level of logging.
  /// Only messages whose level is  the given level will be logged to the callback.
  void CBLLog_SetCallbackLevel(
    int arg0,
  ) {
    return _CBLLog_SetCallbackLevel(
      arg0,
    );
  }

  late final _CBLLog_SetCallbackLevel_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_SetCallbackLevel>>(
          'CBLLog_SetCallbackLevel');
  late final _dart_CBLLog_SetCallbackLevel _CBLLog_SetCallbackLevel =
      _CBLLog_SetCallbackLevel_ptr.asFunction<_dart_CBLLog_SetCallbackLevel>();

  /// Gets the current log callback.
  ffi.Pointer<ffi.NativeFunction<CBLLogCallback>> CBLLog_Callback() {
    return _CBLLog_Callback();
  }

  late final _CBLLog_Callback_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_Callback>>('CBLLog_Callback');
  late final _dart_CBLLog_Callback _CBLLog_Callback =
      _CBLLog_Callback_ptr.asFunction<_dart_CBLLog_Callback>();

  /// Sets the callback for receiving log messages. If set to NULL, no messages are logged to the console.
  void CBLLog_SetCallback(
    ffi.Pointer<ffi.NativeFunction<CBLLogCallback>> callback,
  ) {
    return _CBLLog_SetCallback(
      callback,
    );
  }

  late final _CBLLog_SetCallback_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_SetCallback>>('CBLLog_SetCallback');
  late final _dart_CBLLog_SetCallback _CBLLog_SetCallback =
      _CBLLog_SetCallback_ptr.asFunction<_dart_CBLLog_SetCallback>();

  /// Gets the current file logging configuration, or NULL if none is configured.
  ffi.Pointer<CBLLogFileConfiguration> CBLLog_FileConfig() {
    return _CBLLog_FileConfig();
  }

  late final _CBLLog_FileConfig_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_FileConfig>>('CBLLog_FileConfig');
  late final _dart_CBLLog_FileConfig _CBLLog_FileConfig =
      _CBLLog_FileConfig_ptr.asFunction<_dart_CBLLog_FileConfig>();

  /// Sets the file logging configuration, and begins logging to files.
  bool CBLLog_SetFileConfig(
    CBLLogFileConfiguration arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLLog_SetFileConfig(
          arg0,
          outError,
        ) !=
        0;
  }

  late final _CBLLog_SetFileConfig_ptr =
      _lookup<ffi.NativeFunction<_c_CBLLog_SetFileConfig>>(
          'CBLLog_SetFileConfig');
  late final _dart_CBLLog_SetFileConfig _CBLLog_SetFileConfig =
      _CBLLog_SetFileConfig_ptr.asFunction<_dart_CBLLog_SetFileConfig>();

  /// Creates a new query by compiling the input string.
  /// This is fast, but not instantaneous. If you need to run the same query many times, keep the
  /// \ref CBLQuery around instead of compiling it each time. If you need to run related queries
  /// with only some values different, create one query with placeholder parameter(s), and substitute
  /// the desired value(s) with \ref CBLQuery_SetParameters each time you run the query.
  /// @note  You must release the \ref CBLQuery when you're finished with it.
  /// @param db  The database to query.
  /// @param language  The query language,
  /// [JSON](https://github.com/couchbase/couchbase-lite-core/wiki/JSON-Query-Schema) or
  /// [N1QL](https://docs.couchbase.com/server/4.0/n1ql/n1ql-language-reference/index.html).
  /// @param queryString  The query string.
  /// @param outErrorPos  If non-NULL, then on a parse error the approximate byte offset in the
  /// input expression will be stored here (or -1 if not known/applicable.)
  /// @param outError  On failure, the error will be written here.
  /// @return  The new query object.
  ffi.Pointer<CBLQuery> CBLDatabase_CreateQuery(
    ffi.Pointer<CBLDatabase> db,
    int language,
    FLSlice queryString,
    ffi.Pointer<ffi.Int32> outErrorPos,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_CreateQuery(
      db,
      language,
      queryString,
      outErrorPos,
      outError,
    );
  }

  late final _CBLDatabase_CreateQuery_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_CreateQuery>>(
          'CBLDatabase_CreateQuery');
  late final _dart_CBLDatabase_CreateQuery _CBLDatabase_CreateQuery =
      _CBLDatabase_CreateQuery_ptr.asFunction<_dart_CBLDatabase_CreateQuery>();

  /// Assigns values to the query's parameters.
  /// These values will be substited for those parameters whenever the query is executed,
  /// until they are next assigned.
  ///
  /// Parameters are specified in the query source as
  /// e.g. `$PARAM` (N1QL) or `["$PARAM"]` (JSON). In this example, the `parameters` dictionary
  /// to this call should have a key `PARAM` that maps to the value of the parameter.
  /// @param query  The query.
  /// @param parameters  The parameters in the form of a Fleece \ref FLDict "dictionary" whose
  /// keys are the parameter names. (It's easiest to construct this by using the mutable
  /// API, i.e. calling \ref FLMutableDict_New and adding keys/values.)
  void CBLQuery_SetParameters(
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<FLDict> parameters,
  ) {
    return _CBLQuery_SetParameters(
      query,
      parameters,
    );
  }

  late final _CBLQuery_SetParameters_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_SetParameters>>(
          'CBLQuery_SetParameters');
  late final _dart_CBLQuery_SetParameters _CBLQuery_SetParameters =
      _CBLQuery_SetParameters_ptr.asFunction<_dart_CBLQuery_SetParameters>();

  /// Returns the query's current parameter bindings, if any.
  ffi.Pointer<FLDict> CBLQuery_Parameters(
    ffi.Pointer<CBLQuery> query,
  ) {
    return _CBLQuery_Parameters(
      query,
    );
  }

  late final _CBLQuery_Parameters_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_Parameters>>(
          'CBLQuery_Parameters');
  late final _dart_CBLQuery_Parameters _CBLQuery_Parameters =
      _CBLQuery_Parameters_ptr.asFunction<_dart_CBLQuery_Parameters>();

  /// Runs the query, returning the results.
  /// To obtain the results you'll typically call \ref CBLResultSet_Next in a `while` loop,
  /// examining the values in the \ref CBLResultSet each time around.
  /// @note  You must release the result set when you're finished with it.
  ffi.Pointer<CBLResultSet> CBLQuery_Execute(
    ffi.Pointer<CBLQuery> arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLQuery_Execute(
      arg0,
      outError,
    );
  }

  late final _CBLQuery_Execute_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_Execute>>('CBLQuery_Execute');
  late final _dart_CBLQuery_Execute _CBLQuery_Execute =
      _CBLQuery_Execute_ptr.asFunction<_dart_CBLQuery_Execute>();

  /// Returns information about the query, including the translated SQLite form, and the search
  /// strategy. You can use this to help optimize the query: the word `SCAN` in the strategy
  /// indicates a linear scan of the entire database, which should be avoided by adding an index.
  /// The strategy will also show which index(es), if any, are used.
  /// @note  You are responsible for releasing the result by calling \ref FLSliceResult_Release.
  FLSliceResult CBLQuery_Explain(
    ffi.Pointer<CBLQuery> arg0,
  ) {
    return _CBLQuery_Explain(
      arg0,
    );
  }

  late final _CBLQuery_Explain_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_Explain>>('CBLQuery_Explain');
  late final _dart_CBLQuery_Explain _CBLQuery_Explain =
      _CBLQuery_Explain_ptr.asFunction<_dart_CBLQuery_Explain>();

  /// Returns the number of columns in each result.
  int CBLQuery_ColumnCount(
    ffi.Pointer<CBLQuery> arg0,
  ) {
    return _CBLQuery_ColumnCount(
      arg0,
    );
  }

  late final _CBLQuery_ColumnCount_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_ColumnCount>>(
          'CBLQuery_ColumnCount');
  late final _dart_CBLQuery_ColumnCount _CBLQuery_ColumnCount =
      _CBLQuery_ColumnCount_ptr.asFunction<_dart_CBLQuery_ColumnCount>();

  /// Returns the name of a column in the result.
  /// The column name is based on its expression in the `SELECT...` or `WHAT:` section of the
  /// query. A column that returns a property or property path will be named after that property.
  /// A column that returns an expression will have an automatically-generated name like `$1`.
  /// To give a column a custom name, use the `AS` syntax in the query.
  /// Every column is guaranteed to have a unique name.
  FLSlice CBLQuery_ColumnName(
    ffi.Pointer<CBLQuery> arg0,
    int columnIndex,
  ) {
    return _CBLQuery_ColumnName(
      arg0,
      columnIndex,
    );
  }

  late final _CBLQuery_ColumnName_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_ColumnName>>(
          'CBLQuery_ColumnName');
  late final _dart_CBLQuery_ColumnName _CBLQuery_ColumnName =
      _CBLQuery_ColumnName_ptr.asFunction<_dart_CBLQuery_ColumnName>();

  /// Moves the result-set iterator to the next result.
  /// Returns false if there are no more results.
  /// @warning This must be called _before_ examining the first result.
  bool CBLResultSet_Next(
    ffi.Pointer<CBLResultSet> arg0,
  ) {
    return _CBLResultSet_Next(
          arg0,
        ) !=
        0;
  }

  late final _CBLResultSet_Next_ptr =
      _lookup<ffi.NativeFunction<_c_CBLResultSet_Next>>('CBLResultSet_Next');
  late final _dart_CBLResultSet_Next _CBLResultSet_Next =
      _CBLResultSet_Next_ptr.asFunction<_dart_CBLResultSet_Next>();

  /// Returns the value of a column of the current result, given its (zero-based) numeric index.
  /// This may return a NULL pointer, indicating `MISSING`, if the value doesn't exist, e.g. if
  /// the column is a property that doesn't exist in the document.
  ffi.Pointer<FLValue> CBLResultSet_ValueAtIndex(
    ffi.Pointer<CBLResultSet> arg0,
    int index,
  ) {
    return _CBLResultSet_ValueAtIndex(
      arg0,
      index,
    );
  }

  late final _CBLResultSet_ValueAtIndex_ptr =
      _lookup<ffi.NativeFunction<_c_CBLResultSet_ValueAtIndex>>(
          'CBLResultSet_ValueAtIndex');
  late final _dart_CBLResultSet_ValueAtIndex _CBLResultSet_ValueAtIndex =
      _CBLResultSet_ValueAtIndex_ptr.asFunction<
          _dart_CBLResultSet_ValueAtIndex>();

  /// Returns the value of a column of the current result, given its name.
  /// This may return a NULL pointer, indicating `MISSING`, if the value doesn't exist, e.g. if
  /// the column is a property that doesn't exist in the document. (Or, of course, if the key
  /// is not a column name in this query.)
  /// @note  See \ref CBLQuery_ColumnName for a discussion of column names.
  ffi.Pointer<FLValue> CBLResultSet_ValueForKey(
    ffi.Pointer<CBLResultSet> arg0,
    FLSlice key,
  ) {
    return _CBLResultSet_ValueForKey(
      arg0,
      key,
    );
  }

  late final _CBLResultSet_ValueForKey_ptr =
      _lookup<ffi.NativeFunction<_c_CBLResultSet_ValueForKey>>(
          'CBLResultSet_ValueForKey');
  late final _dart_CBLResultSet_ValueForKey _CBLResultSet_ValueForKey =
      _CBLResultSet_ValueForKey_ptr.asFunction<
          _dart_CBLResultSet_ValueForKey>();

  /// Returns the current result as an array of column values.
  /// @warning The array reference is only valid until the result-set is advanced or released.
  /// If you want to keep it for longer, call \ref FLArray_Retain (and release it when done.)
  ffi.Pointer<FLArray> CBLResultSet_ResultArray(
    ffi.Pointer<CBLResultSet> arg0,
  ) {
    return _CBLResultSet_ResultArray(
      arg0,
    );
  }

  late final _CBLResultSet_ResultArray_ptr =
      _lookup<ffi.NativeFunction<_c_CBLResultSet_ResultArray>>(
          'CBLResultSet_ResultArray');
  late final _dart_CBLResultSet_ResultArray _CBLResultSet_ResultArray =
      _CBLResultSet_ResultArray_ptr.asFunction<
          _dart_CBLResultSet_ResultArray>();

  /// Returns the current result as a dictionary mapping column names to values.
  /// @warning The dict reference is only valid until the result-set is advanced or released.
  /// If you want to keep it for longer, call \ref FLDict_Retain (and release it when done.)
  ffi.Pointer<FLDict> CBLResultSet_ResultDict(
    ffi.Pointer<CBLResultSet> arg0,
  ) {
    return _CBLResultSet_ResultDict(
      arg0,
    );
  }

  late final _CBLResultSet_ResultDict_ptr =
      _lookup<ffi.NativeFunction<_c_CBLResultSet_ResultDict>>(
          'CBLResultSet_ResultDict');
  late final _dart_CBLResultSet_ResultDict _CBLResultSet_ResultDict =
      _CBLResultSet_ResultDict_ptr.asFunction<_dart_CBLResultSet_ResultDict>();

  /// Returns the Query that created this ResultSet.
  ffi.Pointer<CBLQuery> CBLResultSet_GetQuery(
    ffi.Pointer<CBLResultSet> rs,
  ) {
    return _CBLResultSet_GetQuery(
      rs,
    );
  }

  late final _CBLResultSet_GetQuery_ptr =
      _lookup<ffi.NativeFunction<_c_CBLResultSet_GetQuery>>(
          'CBLResultSet_GetQuery');
  late final _dart_CBLResultSet_GetQuery _CBLResultSet_GetQuery =
      _CBLResultSet_GetQuery_ptr.asFunction<_dart_CBLResultSet_GetQuery>();

  /// Registers a change listener callback with a query, turning it into a "live query" until
  /// the listener is removed (via \ref CBLListener_Remove).
  ///
  /// When the first change listener is added, the query will run (in the background) and notify
  /// the listener(s) of the results when ready. After that, it will run in the background after
  /// the database changes, and only notify the listeners when the result set changes.
  /// @param query  The query to observe.
  /// @param listener  The callback to be invoked.
  /// @param context  An opaque value that will be passed to the callback.
  /// @return  A token to be passed to \ref CBLListener_Remove when it's time to remove the
  /// listener.
  ffi.Pointer<CBLListenerToken> CBLQuery_AddChangeListener(
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<ffi.NativeFunction<CBLQueryChangeListener>> listener,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLQuery_AddChangeListener(
      query,
      listener,
      context,
    );
  }

  late final _CBLQuery_AddChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_AddChangeListener>>(
          'CBLQuery_AddChangeListener');
  late final _dart_CBLQuery_AddChangeListener _CBLQuery_AddChangeListener =
      _CBLQuery_AddChangeListener_ptr.asFunction<
          _dart_CBLQuery_AddChangeListener>();

  /// Returns the query's _entire_ current result set, after it's been announced via a call to the
  /// listener's callback.
  /// @note  You must release the result set when you're finished with it.
  /// @param query  The query being listened to.
  /// @param listener  The query listener that was notified.
  /// @param outError  If the query failed to run, the error will be stored here.
  /// @return  A new object containing the query's current results, or NULL if the query failed to run.
  ffi.Pointer<CBLResultSet> CBLQuery_CopyCurrentResults(
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<CBLListenerToken> listener,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLQuery_CopyCurrentResults(
      query,
      listener,
      outError,
    );
  }

  late final _CBLQuery_CopyCurrentResults_ptr =
      _lookup<ffi.NativeFunction<_c_CBLQuery_CopyCurrentResults>>(
          'CBLQuery_CopyCurrentResults');
  late final _dart_CBLQuery_CopyCurrentResults _CBLQuery_CopyCurrentResults =
      _CBLQuery_CopyCurrentResults_ptr.asFunction<
          _dart_CBLQuery_CopyCurrentResults>();

  /// Creates a value index.
  /// Indexes are persistent.
  /// If an identical index with that name already exists, nothing happens (and no error is returned.)
  /// If a non-identical index with that name already exists, it is deleted and re-created.
  bool CBLDatabase_CreateValueIndex(
    ffi.Pointer<CBLDatabase> db,
    FLSlice name,
    CBLValueIndexConfiguration config,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_CreateValueIndex(
          db,
          name,
          config,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_CreateValueIndex_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_CreateValueIndex>>(
          'CBLDatabase_CreateValueIndex');
  late final _dart_CBLDatabase_CreateValueIndex _CBLDatabase_CreateValueIndex =
      _CBLDatabase_CreateValueIndex_ptr.asFunction<
          _dart_CBLDatabase_CreateValueIndex>();

  /// Creates a full-text index.
  /// Indexes are persistent.
  /// If an identical index with that name already exists, nothing happens (and no error is returned.)
  /// If a non-identical index with that name already exists, it is deleted and re-created.
  bool CBLDatabase_CreateFullTextIndex(
    ffi.Pointer<CBLDatabase> db,
    FLSlice name,
    CBLFullTextIndexConfiguration config,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_CreateFullTextIndex(
          db,
          name,
          config,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_CreateFullTextIndex_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_CreateFullTextIndex>>(
          'CBLDatabase_CreateFullTextIndex');
  late final _dart_CBLDatabase_CreateFullTextIndex
      _CBLDatabase_CreateFullTextIndex = _CBLDatabase_CreateFullTextIndex_ptr
          .asFunction<_dart_CBLDatabase_CreateFullTextIndex>();

  /// Deletes an index given its name.
  bool CBLDatabase_DeleteIndex(
    ffi.Pointer<CBLDatabase> db,
    FLSlice name,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLDatabase_DeleteIndex(
          db,
          name,
          outError,
        ) !=
        0;
  }

  late final _CBLDatabase_DeleteIndex_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_DeleteIndex>>(
          'CBLDatabase_DeleteIndex');
  late final _dart_CBLDatabase_DeleteIndex _CBLDatabase_DeleteIndex =
      _CBLDatabase_DeleteIndex_ptr.asFunction<_dart_CBLDatabase_DeleteIndex>();

  /// Returns the names of the indexes on this database, as a Fleece array of strings.
  /// @note  You are responsible for releasing the returned Fleece array.
  ffi.Pointer<FLArray> CBLDatabase_GetIndexNames(
    ffi.Pointer<CBLDatabase> db,
  ) {
    return _CBLDatabase_GetIndexNames(
      db,
    );
  }

  late final _CBLDatabase_GetIndexNames_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDatabase_GetIndexNames>>(
          'CBLDatabase_GetIndexNames');
  late final _dart_CBLDatabase_GetIndexNames _CBLDatabase_GetIndexNames =
      _CBLDatabase_GetIndexNames_ptr.asFunction<
          _dart_CBLDatabase_GetIndexNames>();

  /// The name of the HTTP cookie used by Sync Gateway to store session keys.
  late final ffi.Pointer<FLSlice> _kCBLAuthDefaultCookieName =
      _lookup<FLSlice>('kCBLAuthDefaultCookieName');

  FLSlice get kCBLAuthDefaultCookieName => _kCBLAuthDefaultCookieName.ref;

  /// Creates a new endpoint representing a server-based database at the given URL.
  /// The URL's scheme must be `ws` or `wss`, it must of course have a valid hostname,
  /// and its path must be the name of the database on that server.
  ///
  /// The port can be omitted; it defaults to 80 for `ws` and 443 for `wss`.
  /// For example: `wss://example.org/dbname`.
  ///
  /// If an invalid endpoint URL is specified, an error will be returned.
  ffi.Pointer<CBLEndpoint> CBLEndpoint_CreateWithURL(
    FLSlice url,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLEndpoint_CreateWithURL(
      url,
      outError,
    );
  }

  late final _CBLEndpoint_CreateWithURL_ptr =
      _lookup<ffi.NativeFunction<_c_CBLEndpoint_CreateWithURL>>(
          'CBLEndpoint_CreateWithURL');
  late final _dart_CBLEndpoint_CreateWithURL _CBLEndpoint_CreateWithURL =
      _CBLEndpoint_CreateWithURL_ptr.asFunction<
          _dart_CBLEndpoint_CreateWithURL>();

  /// Frees a CBLEndpoint object.
  void CBLEndpoint_Free(
    ffi.Pointer<CBLEndpoint> arg0,
  ) {
    return _CBLEndpoint_Free(
      arg0,
    );
  }

  late final _CBLEndpoint_Free_ptr =
      _lookup<ffi.NativeFunction<_c_CBLEndpoint_Free>>('CBLEndpoint_Free');
  late final _dart_CBLEndpoint_Free _CBLEndpoint_Free =
      _CBLEndpoint_Free_ptr.asFunction<_dart_CBLEndpoint_Free>();

  /// Creates an authenticator for HTTP Basic (username/password) auth.
  ffi.Pointer<CBLAuthenticator> CBLAuth_CreatePassword(
    FLSlice username,
    FLSlice password,
  ) {
    return _CBLAuth_CreatePassword(
      username,
      password,
    );
  }

  late final _CBLAuth_CreatePassword_ptr =
      _lookup<ffi.NativeFunction<_c_CBLAuth_CreatePassword>>(
          'CBLAuth_CreatePassword');
  late final _dart_CBLAuth_CreatePassword _CBLAuth_CreatePassword =
      _CBLAuth_CreatePassword_ptr.asFunction<_dart_CBLAuth_CreatePassword>();

  /// Creates an authenticator using a Couchbase Sync Gateway login session identifier,
  /// and optionally a cookie name (pass NULL for the default.)
  ffi.Pointer<CBLAuthenticator> CBLAuth_CreateSession(
    FLSlice sessionID,
    FLSlice cookieName,
  ) {
    return _CBLAuth_CreateSession(
      sessionID,
      cookieName,
    );
  }

  late final _CBLAuth_CreateSession_ptr =
      _lookup<ffi.NativeFunction<_c_CBLAuth_CreateSession>>(
          'CBLAuth_CreateSession');
  late final _dart_CBLAuth_CreateSession _CBLAuth_CreateSession =
      _CBLAuth_CreateSession_ptr.asFunction<_dart_CBLAuth_CreateSession>();

  /// Frees a CBLAuthenticator object.
  void CBLAuth_Free(
    ffi.Pointer<CBLAuthenticator> arg0,
  ) {
    return _CBLAuth_Free(
      arg0,
    );
  }

  late final _CBLAuth_Free_ptr =
      _lookup<ffi.NativeFunction<_c_CBLAuth_Free>>('CBLAuth_Free');
  late final _dart_CBLAuth_Free _CBLAuth_Free =
      _CBLAuth_Free_ptr.asFunction<_dart_CBLAuth_Free>();

  /// Default conflict resolver. This always returns `localDocument`.
  late final ffi.Pointer<ffi.Pointer<ffi.NativeFunction<CBLConflictResolver>>>
      _CBLDefaultConflictResolver =
      _lookup<ffi.Pointer<ffi.NativeFunction<CBLConflictResolver>>>(
          'CBLDefaultConflictResolver');

  ffi.Pointer<ffi.NativeFunction<CBLConflictResolver>>
      get CBLDefaultConflictResolver => _CBLDefaultConflictResolver.value;

  set CBLDefaultConflictResolver(
          ffi.Pointer<ffi.NativeFunction<CBLConflictResolver>> value) =>
      _CBLDefaultConflictResolver.value = value;

  /// Creates a replicator with the given configuration.
  ffi.Pointer<CBLReplicator> CBLReplicator_Create(
    ffi.Pointer<CBLReplicatorConfiguration> arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLReplicator_Create(
      arg0,
      outError,
    );
  }

  late final _CBLReplicator_Create_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_Create>>(
          'CBLReplicator_Create');
  late final _dart_CBLReplicator_Create _CBLReplicator_Create =
      _CBLReplicator_Create_ptr.asFunction<_dart_CBLReplicator_Create>();

  /// Returns the configuration of an existing replicator.
  ffi.Pointer<CBLReplicatorConfiguration> CBLReplicator_Config(
    ffi.Pointer<CBLReplicator> arg0,
  ) {
    return _CBLReplicator_Config(
      arg0,
    );
  }

  late final _CBLReplicator_Config_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_Config>>(
          'CBLReplicator_Config');
  late final _dart_CBLReplicator_Config _CBLReplicator_Config =
      _CBLReplicator_Config_ptr.asFunction<_dart_CBLReplicator_Config>();

  /// Starts a replicator, asynchronously. Does nothing if it's already started.
  /// @param replicator  The replicator instance.
  /// @param resetCheckpoint  If true, the persistent saved state ("checkpoint") for this replication
  /// will be discarded, causing it to re-scan all documents. This significantly
  /// increases time and bandwidth (redundant docs are not transferred, but their
  /// IDs are) but can resolve unexpected problems with missing documents if one
  /// side or the other has gotten out of sync.
  void CBLReplicator_Start(
    ffi.Pointer<CBLReplicator> replicator,
    bool resetCheckpoint,
  ) {
    return _CBLReplicator_Start(
      replicator,
      resetCheckpoint ? 1 : 0,
    );
  }

  late final _CBLReplicator_Start_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_Start>>(
          'CBLReplicator_Start');
  late final _dart_CBLReplicator_Start _CBLReplicator_Start =
      _CBLReplicator_Start_ptr.asFunction<_dart_CBLReplicator_Start>();

  /// Stops a running replicator, asynchronously. Does nothing if it's not already started.
  /// The replicator will call your \ref CBLReplicatorChangeListener with an activity level of
  /// \ref kCBLReplicatorStopped after it stops. Until then, consider it still active.
  void CBLReplicator_Stop(
    ffi.Pointer<CBLReplicator> arg0,
  ) {
    return _CBLReplicator_Stop(
      arg0,
    );
  }

  late final _CBLReplicator_Stop_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_Stop>>('CBLReplicator_Stop');
  late final _dart_CBLReplicator_Stop _CBLReplicator_Stop =
      _CBLReplicator_Stop_ptr.asFunction<_dart_CBLReplicator_Stop>();

  /// Informs the replicator whether it's considered possible to reach the remote host with
  /// the current network configuration. The default value is true. This only affects the
  /// replicator's behavior while it's in the Offline state:
  /// Setting it to false will cancel any pending retry and prevent future automatic retries.
  /// Setting it back to true will initiate an immediate retry.
  void CBLReplicator_SetHostReachable(
    ffi.Pointer<CBLReplicator> arg0,
    bool reachable,
  ) {
    return _CBLReplicator_SetHostReachable(
      arg0,
      reachable ? 1 : 0,
    );
  }

  late final _CBLReplicator_SetHostReachable_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_SetHostReachable>>(
          'CBLReplicator_SetHostReachable');
  late final _dart_CBLReplicator_SetHostReachable
      _CBLReplicator_SetHostReachable = _CBLReplicator_SetHostReachable_ptr
          .asFunction<_dart_CBLReplicator_SetHostReachable>();

  /// Puts the replicator in or out of "suspended" state. The default is false.
  /// Setting suspended=true causes the replicator to disconnect and enter Offline state;
  /// it will not attempt to reconnect while it's suspended.
  /// Setting suspended=false causes the replicator to attempt to reconnect, _if_ it was
  /// connected when suspended, and is still in Offline state.
  void CBLReplicator_SetSuspended(
    ffi.Pointer<CBLReplicator> repl,
    bool suspended,
  ) {
    return _CBLReplicator_SetSuspended(
      repl,
      suspended ? 1 : 0,
    );
  }

  late final _CBLReplicator_SetSuspended_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_SetSuspended>>(
          'CBLReplicator_SetSuspended');
  late final _dart_CBLReplicator_SetSuspended _CBLReplicator_SetSuspended =
      _CBLReplicator_SetSuspended_ptr.asFunction<
          _dart_CBLReplicator_SetSuspended>();

  /// Returns the replicator's current status.
  CBLReplicatorStatus CBLReplicator_Status(
    ffi.Pointer<CBLReplicator> arg0,
  ) {
    return _CBLReplicator_Status(
      arg0,
    );
  }

  late final _CBLReplicator_Status_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_Status>>(
          'CBLReplicator_Status');
  late final _dart_CBLReplicator_Status _CBLReplicator_Status =
      _CBLReplicator_Status_ptr.asFunction<_dart_CBLReplicator_Status>();

  /// Indicates which documents have local changes that have not yet been pushed to the server
  /// by this replicator. This is of course a snapshot, that will go out of date as the replicator
  /// makes progress and/or documents are saved locally.
  ///
  /// The result is, effectively, a set of document IDs: a dictionary whose keys are the IDs and
  /// values are `true`.
  /// If there are no pending documents, the dictionary is empty.
  /// On error, NULL is returned.
  ///
  /// \note  This function can be called on a stopped or un-started replicator.
  /// \note  Documents that would never be pushed by this replicator, due to its configuration's
  /// `pushFilter` or `docIDs`, are ignored.
  /// \warning  You are responsible for releasing the returned array via \ref FLValue_Release.
  ffi.Pointer<FLDict> CBLReplicator_PendingDocumentIDs(
    ffi.Pointer<CBLReplicator> arg0,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLReplicator_PendingDocumentIDs(
      arg0,
      outError,
    );
  }

  late final _CBLReplicator_PendingDocumentIDs_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_PendingDocumentIDs>>(
          'CBLReplicator_PendingDocumentIDs');
  late final _dart_CBLReplicator_PendingDocumentIDs
      _CBLReplicator_PendingDocumentIDs = _CBLReplicator_PendingDocumentIDs_ptr
          .asFunction<_dart_CBLReplicator_PendingDocumentIDs>();

  /// Indicates whether the document with the given ID has local changes that have not yet been
  /// pushed to the server by this replicator.
  ///
  /// This is equivalent to, but faster than, calling \ref CBLReplicator_PendingDocumentIDs and
  /// checking whether the result contains \p docID. See that function's documentation for details.
  ///
  /// \note  A `false` result means the document is not pending, _or_ there was an error.
  /// To tell the difference, compare the error code to zero.
  bool CBLReplicator_IsDocumentPending(
    ffi.Pointer<CBLReplicator> repl,
    FLSlice docID,
    ffi.Pointer<CBLError> outError,
  ) {
    return _CBLReplicator_IsDocumentPending(
          repl,
          docID,
          outError,
        ) !=
        0;
  }

  late final _CBLReplicator_IsDocumentPending_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_IsDocumentPending>>(
          'CBLReplicator_IsDocumentPending');
  late final _dart_CBLReplicator_IsDocumentPending
      _CBLReplicator_IsDocumentPending = _CBLReplicator_IsDocumentPending_ptr
          .asFunction<_dart_CBLReplicator_IsDocumentPending>();

  /// Adds a listener that will be called when the replicator's status changes.
  ffi.Pointer<CBLListenerToken> CBLReplicator_AddChangeListener(
    ffi.Pointer<CBLReplicator> arg0,
    ffi.Pointer<ffi.NativeFunction<CBLReplicatorChangeListener>> arg1,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLReplicator_AddChangeListener(
      arg0,
      arg1,
      context,
    );
  }

  late final _CBLReplicator_AddChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLReplicator_AddChangeListener>>(
          'CBLReplicator_AddChangeListener');
  late final _dart_CBLReplicator_AddChangeListener
      _CBLReplicator_AddChangeListener = _CBLReplicator_AddChangeListener_ptr
          .asFunction<_dart_CBLReplicator_AddChangeListener>();

  /// Adds a listener that will be called when documents are replicated.
  ffi.Pointer<CBLListenerToken> CBLReplicator_AddDocumentReplicationListener(
    ffi.Pointer<CBLReplicator> arg0,
    ffi.Pointer<ffi.NativeFunction<CBLDocumentReplicationListener>> arg1,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CBLReplicator_AddDocumentReplicationListener(
      arg0,
      arg1,
      context,
    );
  }

  late final _CBLReplicator_AddDocumentReplicationListener_ptr = _lookup<
          ffi.NativeFunction<_c_CBLReplicator_AddDocumentReplicationListener>>(
      'CBLReplicator_AddDocumentReplicationListener');
  late final _dart_CBLReplicator_AddDocumentReplicationListener
      _CBLReplicator_AddDocumentReplicationListener =
      _CBLReplicator_AddDocumentReplicationListener_ptr.asFunction<
          _dart_CBLReplicator_AddDocumentReplicationListener>();

  void CBLDart_PostCObject(
    ffi.Pointer<ffi.NativeFunction<Dart_PostCObjectType>> function_pointer,
  ) {
    return _CBLDart_PostCObject(
      function_pointer,
    );
  }

  late final _CBLDart_PostCObject_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_PostCObject>>(
          'CBLDart_PostCObject');
  late final _dart_CBLDart_PostCObject _CBLDart_PostCObject =
      _CBLDart_PostCObject_ptr.asFunction<_dart_CBLDart_PostCObject>();

  void CBLDart_NewNativePort(
    ffi.Pointer<ffi.NativeFunction<Dart_NewNativePortType>> function_pointer,
  ) {
    return _CBLDart_NewNativePort(
      function_pointer,
    );
  }

  late final _CBLDart_NewNativePort_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_NewNativePort>>(
          'CBLDart_NewNativePort');
  late final _dart_CBLDart_NewNativePort _CBLDart_NewNativePort =
      _CBLDart_NewNativePort_ptr.asFunction<_dart_CBLDart_NewNativePort>();

  void CBLDart_CloseNativePort(
    ffi.Pointer<ffi.NativeFunction<Dart_CloseNativePortType>> function_pointer,
  ) {
    return _CBLDart_CloseNativePort(
      function_pointer,
    );
  }

  late final _CBLDart_CloseNativePort_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_CloseNativePort>>(
          'CBLDart_CloseNativePort');
  late final _dart_CBLDart_CloseNativePort _CBLDart_CloseNativePort =
      _CBLDart_CloseNativePort_ptr.asFunction<_dart_CBLDart_CloseNativePort>();

  void CBLDart_RegisterPorts(
    int database_listener_port,
    int document_listener_port,
    int query_listener_port,
    int replicator_status_port,
    int replicator_filter_port,
    int replicator_conflict_port,
    ffi.Pointer<ffi.NativeFunction<CBLDart_ReplicatorStatusCallback>>
        replicator_status_callback,
    ffi.Pointer<ffi.NativeFunction<CBLDart_ReplicatorFilterCallback>>
        replicator_filter_callback,
    ffi.Pointer<ffi.NativeFunction<CBLDart_ConflictResolverCallback>>
        replicator_conflict_callback,
  ) {
    return _CBLDart_RegisterPorts(
      database_listener_port,
      document_listener_port,
      query_listener_port,
      replicator_status_port,
      replicator_filter_port,
      replicator_conflict_port,
      replicator_status_callback,
      replicator_filter_callback,
      replicator_conflict_callback,
    );
  }

  late final _CBLDart_RegisterPorts_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_RegisterPorts>>(
          'CBLDart_RegisterPorts');
  late final _dart_CBLDart_RegisterPorts _CBLDart_RegisterPorts =
      _CBLDart_RegisterPorts_ptr.asFunction<_dart_CBLDart_RegisterPorts>();

  void CBLDart_ExecuteCallback(
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<Work>>> work_ptr,
  ) {
    return _CBLDart_ExecuteCallback(
      work_ptr,
    );
  }

  late final _CBLDart_ExecuteCallback_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_ExecuteCallback>>(
          'CBLDart_ExecuteCallback');
  late final _dart_CBLDart_ExecuteCallback _CBLDart_ExecuteCallback =
      _CBLDart_ExecuteCallback_ptr.asFunction<_dart_CBLDart_ExecuteCallback>();

  void CBLDart_DatabaseChangeListener(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDatabase> db,
    int numDocs,
    ffi.Pointer<FLSlice> docIDs,
  ) {
    return _CBLDart_DatabaseChangeListener(
      context,
      db,
      numDocs,
      docIDs,
    );
  }

  late final _CBLDart_DatabaseChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_DatabaseChangeListener>>(
          'CBLDart_DatabaseChangeListener');
  late final _dart_CBLDart_DatabaseChangeListener
      _CBLDart_DatabaseChangeListener = _CBLDart_DatabaseChangeListener_ptr
          .asFunction<_dart_CBLDart_DatabaseChangeListener>();

  void CBLDart_DocumentChangeListener(
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<CBLDatabase> db,
    FLSlice docID,
  ) {
    return _CBLDart_DocumentChangeListener(
      context,
      db,
      docID,
    );
  }

  late final _CBLDart_DocumentChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_DocumentChangeListener>>(
          'CBLDart_DocumentChangeListener');
  late final _dart_CBLDart_DocumentChangeListener
      _CBLDart_DocumentChangeListener = _CBLDart_DocumentChangeListener_ptr
          .asFunction<_dart_CBLDart_DocumentChangeListener>();

  void CBLDart_QueryChangeListener(
    ffi.Pointer<ffi.Void> queryId,
    ffi.Pointer<CBLQuery> query,
    ffi.Pointer<CBLListenerToken> token,
  ) {
    return _CBLDart_QueryChangeListener(
      queryId,
      query,
      token,
    );
  }

  late final _CBLDart_QueryChangeListener_ptr =
      _lookup<ffi.NativeFunction<_c_CBLDart_QueryChangeListener>>(
          'CBLDart_QueryChangeListener');
  late final _dart_CBLDart_QueryChangeListener _CBLDart_QueryChangeListener =
      _CBLDart_QueryChangeListener_ptr.asFunction<
          _dart_CBLDart_QueryChangeListener>();
}

/// A simple reference to a block of memory. Does not imply ownership.
/// (This is equivalent to the C++ class `slice`.)
class FLSlice extends ffi.Struct {
  external ffi.Pointer<ffi.Void> buf;

  @ffi.Uint64()
  external int size;
}

/// A heap-allocated block of memory returned from an API call.
/// The caller takes ownership, and must call \ref FLSliceResult_Release when done with it.
/// \warning The contents of the block must not be modified, since others may be using it.
/// \note This is equivalent to the C++ class `alloc_slice`. In C++ the easiest way to deal with
/// a `FLSliceResult` return value is to construct an `alloc_slice` from it, which will
/// adopt the reference, and release it in its destructor. For example:
/// `alloc_slice foo( CopyFoo() );`
class FLSliceResult extends ffi.Struct {
  external ffi.Pointer<ffi.Void> buf;

  @ffi.Uint64()
  external int size;
}

/// A struct holding information about an error. It's declared on the stack by a caller, and
/// its address is passed to an API function. If the function's return value indicates that
/// there was an error (usually by returning NULL or false), then the CBLError will have been
/// filled in with the details.
class CBLError extends ffi.Struct {
  /// < Domain of errors; a namespace for the `code`.
  @ffi.Uint8()
  external int domain;

  /// < Error code, specific to the domain. 0 always means no error.
  @ffi.Int32()
  external int code;

  @ffi.Uint32()
  external int internal_info;
}

class CBLRefCounted extends ffi.Opaque {}

class CBLDatabase extends ffi.Opaque {}

class CBLDocument extends ffi.Opaque {}

class CBLBlob extends ffi.Opaque {}

class CBLQuery extends ffi.Opaque {}

class CBLResultSet extends ffi.Opaque {}

class CBLReplicator extends ffi.Opaque {}

class CBLListenerToken extends ffi.Opaque {}

/// Error codes returned from some API calls.
abstract class FLError {
  static const int kFLNoError = 0;
  static const int kFLMemoryError = 1;
  static const int kFLOutOfRange = 2;
  static const int kFLInvalidData = 3;
  static const int kFLEncodeError = 4;
  static const int kFLJSONError = 5;
  static const int kFLUnknownValue = 6;
  static const int kFLInternalError = 7;
  static const int kFLNotFound = 8;
  static const int kFLSharedKeysStateError = 9;
  static const int kFLPOSIXError = 10;
  static const int kFLUnsupported = 11;
}

/// Specifies whether not input data is trusted to be 100% valid Fleece.
abstract class FLTrust {
  /// Input data is not trusted to be valid, and will be fully validated by the API call.
  static const int kFLUntrusted = 0;

  /// Input data is trusted to be valid. The API will perform only minimal validation when
  /// reading it. This is faster than kFLUntrusted, but should only be used if
  /// the data was generated by a trusted encoder and has not been altered or corrupted. For
  /// example, this can be used to parse Fleece data previously stored by your code in local
  /// storage.
  /// If invalid data is read by this call, subsequent calls to Value accessor functions can
  /// crash or return bogus results (including data from arbitrary memory locations.)
  static const int kFLTrusted = 1;
}

class FLDoc extends ffi.Opaque {}

class FLSharedKeys extends ffi.Opaque {}

class FLValue extends ffi.Opaque {}

/// Types of Fleece values. Basically JSON, with the addition of Data (raw blob).
abstract class FLValueType {
  /// < Type of a NULL pointer, i.e. no such value, like JSON `undefined`. Also the type of a value created by FLEncoder_WriteUndefined().
  static const int kFLUndefined = -1;

  /// < Equivalent to a JSON 'null'
  static const int kFLNull = 0;

  /// < A `true` or `false` value
  static const int kFLBoolean = 1;

  /// < A numeric value, either integer or floating-point
  static const int kFLNumber = 2;

  /// < A string
  static const int kFLString = 3;

  /// < Binary data (no JSON equivalent)
  static const int kFLData = 4;

  /// < An array of values
  static const int kFLArray = 5;

  /// < A mapping of strings to values
  static const int kFLDict = 6;
}

class FLArray extends ffi.Opaque {}

class FLDict extends ffi.Opaque {}

/// Opaque array iterator. Declare one on the stack and pass its address to
/// `FLArrayIteratorBegin`.
class FLArrayIterator extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _private1;

  @ffi.Uint32()
  external int _private2;

  @ffi.Uint8()
  external int _private3;

  external ffi.Pointer<ffi.Void> _private4;
}

/// \name Mutable Arrays
/// @{
abstract class FLCopyFlags {
  static const int kFLDefaultCopy = 0;
  static const int kFLDeepCopy = 1;
  static const int kFLCopyImmutables = 2;
  static const int kFLDeepCopyImmutables = 3;
}

/// Opaque dictionary iterator. Declare one on the stack, and pass its address to
/// FLDictIterator_Begin.
class FLDictIterator extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _private1;

  @ffi.Uint32()
  external int _private2;

  @ffi.Uint8()
  external int _private3;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer<ffi.Void>> _private4;

  @ffi.Int32()
  external int _private5;
}

/// Opaque key for a dictionary. You are responsible for creating space for these; they can
/// go on the stack, on the heap, inside other objects, anywhere.
/// Be aware that the lookup operations that use these will write into the struct to store
/// "hints" that speed up future searches.
class FLDictKey extends ffi.Struct {
  external FLSlice _private1;

  external ffi.Pointer<ffi.Void> _private2;

  @ffi.Uint32()
  external int _private3;

  @ffi.Uint32()
  external int private4;

  @ffi.Uint8()
  external int private5;
}

class FLDeepIterator extends ffi.Opaque {}

class FLPathComponent extends ffi.Struct {
  /// < Dict key, or kFLSliceNull if none
  external FLSlice key;

  /// < Array index, only if there's no key
  @ffi.Uint32()
  external int index;
}

class FLKeyPath extends ffi.Opaque {}

class FLEncoder extends ffi.Opaque {}

class FLSharedKeyScope extends ffi.Opaque {}

/// Output formats a FLEncoder can generate.
abstract class FLEncoderFormat {
  /// < Fleece encoding
  static const int kFLEncodeFleece = 0;

  /// < JSON encoding
  static const int kFLEncodeJSON = 1;

  /// < [JSON5](http://json5.org), an extension of JSON with a more readable syntax
  static const int kFLEncodeJSON5 = 2;
}

class FILE extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _Placeholder;
}

class FLSlot extends ffi.Opaque {}

class CBLBlobReadStream extends ffi.Opaque {}

class CBLBlobWriteStream extends ffi.Opaque {}

/// Database configuration options.
class CBLDatabaseConfiguration extends ffi.Struct {
  /// < The parent directory of the database
  external FLSlice directory;
}

/// The properties for configuring logging to files.
/// @warning `usePlaintext` results in significantly larger log files and higher CPU usage that may slow
/// down your app; we recommend turning it off in production.
class CBLLogFileConfiguration extends ffi.Struct {
  /// < The minimum level of message to write
  @ffi.Uint8()
  external int level;

  /// < The directory where log files will be created.
  external FLSlice directory;

  /// < Max number of older log files to keep (in addition to current one.)
  @ffi.Uint32()
  external int maxRotateCount;

  /// < The size in bytes at which a file will be rotated out (best effort).
  @ffi.Uint64()
  external int maxSize;

  /// < Whether or not to log in plaintext (as opposed to binary.) Plaintext logging is slower and bigger.
  @ffi.Uint8()
  external int usePlaintext;
}

/// Value Index Configuration.
class CBLValueIndexConfiguration extends ffi.Struct {
  /// The language used in the expressions.
  @ffi.Uint32()
  external int expressionLanguage;

  /// The expressions describing each coloumn of the index. The expressions could be specified
  /// in a JSON Array or in N1QL syntax using comma delimiter.
  external FLSlice expressions;
}

/// Full-Text Index Configuration.
class CBLFullTextIndexConfiguration extends ffi.Struct {
  /// The language used in the expressions.
  @ffi.Uint32()
  external int expressionLanguage;

  /// The expressions describing each coloumn of the index. The expressions could be specified
  /// in a JSON Array or in N1QL syntax using comma delimiter.
  external FLSlice expressions;

  /// Should diacritical marks (accents) be ignored?
  /// Defaults to false. Generally this should be left `false` for non-English text.
  @ffi.Uint8()
  external int ignoreAccents;

  /// The dominant language. Setting this enables word stemming, i.e.
  /// matching different cases of the same word ("big" and "bigger", for instance) and ignoring
  /// common "stop-words" ("the", "a", "of", etc.)
  ///
  /// Can be an ISO-639 language code or a lowercase (English) language name; supported
  /// languages are: da/danish, nl/dutch, en/english, fi/finnish, fr/french, de/german,
  /// hu/hungarian, it/italian, no/norwegian, pt/portuguese, ro/romanian, ru/russian,
  /// es/spanish, sv/swedish, tr/turkish.
  ///
  /// If left null,  or set to an unrecognized language, no language-specific behaviors
  /// such as stemming and stop-word removal occur.
  external FLSlice language;
}

class CBLEndpoint extends ffi.Opaque {}

class CBLAuthenticator extends ffi.Opaque {}

/// Proxy settings for the replicator.
class CBLProxySettings extends ffi.Struct {
  /// < Type of proxy
  @ffi.Uint8()
  external int type;

  /// < Proxy server hostname or IP address
  external FLSlice hostname;

  /// < Proxy server port
  @ffi.Uint16()
  external int port;

  /// < Username for proxy auth (optional)
  external FLSlice username;

  /// < Password for proxy auth
  external FLSlice password;
}

/// The configuration of a replicator.
class CBLReplicatorConfiguration extends ffi.Struct {
  /// < The database to replicate
  external ffi.Pointer<CBLDatabase> database;

  /// < The address of the other database to replicate with
  external ffi.Pointer<CBLEndpoint> endpoint;

  /// < Push, pull or both
  @ffi.Uint8()
  external int replicatorType;

  /// < Continuous replication?
  @ffi.Uint8()
  external int continuous;

  /// < Disable/Enable auto-purging documents when the user's access to the documents has been revoked.
  @ffi.Uint8()
  external int disableAutoPurge;

  /// < Max retry attempts where the initial connect to replicate counts toward the given value.
  /// < Specify 0 to use the default value, 10 times for a non-continuous replicator and max-int time for a continuous replicator. Specify 1 means there will be no retry after the first attempt.
  @ffi.Uint32()
  external int maxAttempts;

  /// < Max wait time between retry attempts in seconds. Specify 0 to use the default value of 300 seconds.
  @ffi.Uint32()
  external int maxAttemptWaitTime;

  /// < The heartbeat interval in seconds. Specify 0 to use the default value of 300 seconds.
  @ffi.Uint32()
  external int heartbeat;

  /// < Authentication credentials, if needed
  external ffi.Pointer<CBLAuthenticator> authenticator;

  /// < HTTP client proxy settings
  external ffi.Pointer<CBLProxySettings> proxy;

  /// < Extra HTTP headers to add to the WebSocket request
  external ffi.Pointer<FLDict> headers;

  /// < An X.509 cert to "pin" TLS connections to (PEM or DER)
  external FLSlice pinnedServerCertificate;

  /// < Set of anchor certs (PEM format)
  external FLSlice trustedRootCertificates;

  /// < Optional set of channels to pull from
  external ffi.Pointer<FLArray> channels;

  /// < Optional set of document IDs to replicate
  external ffi.Pointer<FLArray> documentIDs;

  /// < Optional callback to filter which docs are pushed
  external ffi.Pointer<ffi.NativeFunction<CBLReplicationFilter>> pushFilter;

  /// < Optional callback to validate incoming docs
  external ffi.Pointer<ffi.NativeFunction<CBLReplicationFilter>> pullFilter;

  /// < Optional conflict-resolver callback
  external ffi.Pointer<ffi.NativeFunction<CBLConflictResolver>>
      conflictResolver;

  /// < Arbitrary value that will be passed to callbacks
  external ffi.Pointer<ffi.Void> context;
}

/// A fractional progress value, ranging from 0.0 to 1.0 as replication progresses.
/// The value is very approximate and may bounce around during replication; making it more
/// accurate would require slowing down the replicator and incurring more load on the server.
/// It's fine to use in a progress bar, though.
class CBLReplicatorProgress extends ffi.Struct {
  @ffi.Float()
  external double complete;

  /// < Number of documents transferred so far
  @ffi.Uint64()
  external int documentCount;
}

/// A replicator's current status.
class CBLReplicatorStatus extends ffi.Struct {
  /// < Current state
  @ffi.Uint8()
  external int activity;

  /// < Approximate fraction complete
  external CBLReplicatorProgress progress;

  /// < Error, if any
  external CBLError error;
}

/// Information about a document that's been pushed or pulled.
class CBLReplicatedDocument extends ffi.Struct {
  /// < The document ID
  external FLSlice ID;

  /// < Indicates whether the document was deleted or removed
  @ffi.Uint32()
  external int flags;

  /// < If the code is nonzero, the document failed to replicate.
  external CBLError error;
}

class Dart_CObject extends ffi.Opaque {}

const int kCBLDomain = 1;

const int kCBLPOSIXDomain = 2;

const int kCBLSQLiteDomain = 3;

const int kCBLFleeceDomain = 4;

const int kCBLNetworkDomain = 5;

const int kCBLWebSocketDomain = 6;

const int kCBLErrorAssertionFailed = 1;

const int kCBLErrorUnimplemented = 2;

const int kCBLErrorUnsupportedEncryption = 3;

const int kCBLErrorBadRevisionID = 4;

const int kCBLErrorCorruptRevisionData = 5;

const int kCBLErrorNotOpen = 6;

const int kCBLErrorNotFound = 7;

const int kCBLErrorConflict = 8;

const int kCBLErrorInvalidParameter = 9;

const int kCBLErrorUnexpectedError = 10;

const int kCBLErrorCantOpenFile = 11;

const int kCBLErrorIOError = 12;

const int kCBLErrorMemoryError = 13;

const int kCBLErrorNotWriteable = 14;

const int kCBLErrorCorruptData = 15;

const int kCBLErrorBusy = 16;

const int kCBLErrorNotInTransaction = 17;

const int kCBLErrorTransactionNotClosed = 18;

const int kCBLErrorUnsupported = 19;

const int kCBLErrorNotADatabaseFile = 20;

const int kCBLErrorWrongFormat = 21;

const int kCBLErrorCrypto = 22;

const int kCBLErrorInvalidQuery = 23;

const int kCBLErrorMissingIndex = 24;

const int kCBLErrorInvalidQueryParam = 25;

const int kCBLErrorRemoteError = 26;

const int kCBLErrorDatabaseTooOld = 27;

const int kCBLErrorDatabaseTooNew = 28;

const int kCBLErrorBadDocID = 29;

const int kCBLErrorCantUpgradeDatabase = 30;

const int kCBLNetErrDNSFailure = 1;

const int kCBLNetErrUnknownHost = 2;

const int kCBLNetErrTimeout = 3;

const int kCBLNetErrInvalidURL = 4;

const int kCBLNetErrTooManyRedirects = 5;

const int kCBLNetErrTLSHandshakeFailed = 6;

const int kCBLNetErrTLSCertExpired = 7;

const int kCBLNetErrTLSCertUntrusted = 8;

const int kCBLNetErrTLSClientCertRequired = 9;

const int kCBLNetErrTLSClientCertRejected = 10;

const int kCBLNetErrTLSCertUnknownRoot = 11;

const int kCBLNetErrInvalidRedirect = 12;

const int kCBLNetErrUnknown = 13;

const int kCBLNetErrTLSCertRevoked = 14;

const int kCBLNetErrTLSCertNameMismatch = 15;

const int kCBLMaintenanceTypeCompact = 0;

const int kCBLMaintenanceTypeReindex = 1;

const int kCBLMaintenanceTypeIntegrityCheck = 2;

const int kCBLMaintenanceTypeOptimize = 3;

const int kCBLMaintenanceTypeFullOptimize = 4;

const int kCBLConcurrencyControlLastWriteWins = 0;

const int kCBLConcurrencyControlFailOnConflict = 1;

const int kCBLLogDomainDatabase = 0;

const int kCBLLogDomainQuery = 1;

const int kCBLLogDomainReplicator = 2;

const int kCBLLogDomainNetwork = 3;

const int kCBLLogDebug = 0;

const int kCBLLogVerbose = 1;

const int kCBLLogInfo = 2;

const int kCBLLogWarning = 3;

const int kCBLLogError = 4;

const int kCBLLogNone = 5;

const int kCBLJSONLanguage = 0;

const int kCBLN1QLLanguage = 1;

const int kCBLReplicatorTypePushAndPull = 0;

const int kCBLReplicatorTypePush = 1;

const int kCBLReplicatorTypePull = 2;

const int kCBLDocumentFlagsDeleted = 1;

const int kCBLDocumentFlagsAccessRemoved = 2;

const int kCBLProxyHTTP = 0;

const int kCBLProxyHTTPS = 1;

const int kCBLReplicatorStopped = 0;

const int kCBLReplicatorOffline = 1;

const int kCBLReplicatorConnecting = 2;

const int kCBLReplicatorIdle = 3;

const int kCBLReplicatorBusy = 4;

const int kNativeArgNumberPos = 0;

const int kNativeArgNumberSize = 8;

const int kNativeArgTypePos = 8;

const int kNativeArgTypeSize = 8;

const int kCBLReplicatorFilterTypePush = 0;

const int kCBLReplicatorFilterTypePull = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const String HOTLEVEL = 'Ofast';

const String COLDLEVEL = 'Oz';

const int __bool_true_false_are_defined = 1;

const int false_1 = 0;

const int true_1 = 1;

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int _WCHAR_T_DEFINED = 1;

const int NULL = 0;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_NODISCARD = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -2147483648;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 2147483647;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 4294967295;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int WCHAR_MIN = 0;

const int WCHAR_MAX = 65535;

const int WINT_MIN = 0;

const int WINT_MAX = 65535;

const int _ARGMAX = 100;

const int _TRUNCATE = -1;

const int _CRT_INT_MAX = 2147483647;

const int _CRT_SIZE_MAX = -1;

const String __FILEW__ = 't';

const int _CRT_FUNCTIONS_REQUIRED = 1;

const int _CRT_HAS_CXX17 = 0;

const int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = 1;

const int _CRT_BUILD_DESKTOP_APP = 1;

const int _CRT_INTERNAL_NONSTDC_NAMES = 1;

const int __STDC_SECURE_LIB__ = 200411;

const int __GOT_SECURE_LIB__ = 200411;

const int __STDC_WANT_SECURE_LIB__ = 1;

const int _SECURECRT_FILL_BUFFER_PATTERN = 254;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;

const int _MAX_ITOSTR_BASE16_COUNT = 9;

const int _MAX_ITOSTR_BASE10_COUNT = 12;

const int _MAX_ITOSTR_BASE8_COUNT = 12;

const int _MAX_ITOSTR_BASE2_COUNT = 33;

const int _MAX_LTOSTR_BASE16_COUNT = 9;

const int _MAX_LTOSTR_BASE10_COUNT = 12;

const int _MAX_LTOSTR_BASE8_COUNT = 12;

const int _MAX_LTOSTR_BASE2_COUNT = 33;

const int _MAX_ULTOSTR_BASE16_COUNT = 9;

const int _MAX_ULTOSTR_BASE10_COUNT = 11;

const int _MAX_ULTOSTR_BASE8_COUNT = 12;

const int _MAX_ULTOSTR_BASE2_COUNT = 33;

const int _MAX_I64TOSTR_BASE16_COUNT = 17;

const int _MAX_I64TOSTR_BASE10_COUNT = 21;

const int _MAX_I64TOSTR_BASE8_COUNT = 23;

const int _MAX_I64TOSTR_BASE2_COUNT = 65;

const int _MAX_U64TOSTR_BASE16_COUNT = 17;

const int _MAX_U64TOSTR_BASE10_COUNT = 21;

const int _MAX_U64TOSTR_BASE8_COUNT = 23;

const int _MAX_U64TOSTR_BASE2_COUNT = 65;

const int CHAR_BIT = 8;

const int SCHAR_MIN = -128;

const int SCHAR_MAX = 127;

const int UCHAR_MAX = 255;

const int CHAR_MIN = -128;

const int CHAR_MAX = 127;

const int MB_LEN_MAX = 5;

const int SHRT_MIN = -32768;

const int SHRT_MAX = 32767;

const int USHRT_MAX = 65535;

const int INT_MIN = -2147483648;

const int INT_MAX = 2147483647;

const int UINT_MAX = 4294967295;

const int LONG_MIN = -2147483648;

const int LONG_MAX = 2147483647;

const int ULONG_MAX = 4294967295;

const int LLONG_MAX = 9223372036854775807;

const int LLONG_MIN = -9223372036854775808;

const int ULLONG_MAX = -1;

const int _I8_MIN = -128;

const int _I8_MAX = 127;

const int _UI8_MAX = 255;

const int _I16_MIN = -32768;

const int _I16_MAX = 32767;

const int _UI16_MAX = 65535;

const int _I32_MIN = -2147483648;

const int _I32_MAX = 2147483647;

const int _UI32_MAX = 4294967295;

const int _I64_MIN = -9223372036854775808;

const int _I64_MAX = 9223372036854775807;

const int _UI64_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int EXIT_SUCCESS = 0;

const int EXIT_FAILURE = 1;

const int _WRITE_ABORT_MSG = 1;

const int _CALL_REPORTFAULT = 2;

const int _OUT_TO_DEFAULT = 0;

const int _OUT_TO_STDERR = 1;

const int _OUT_TO_MSGBOX = 2;

const int _REPORT_ERRMODE = 3;

const int RAND_MAX = 32767;

const int _CVTBUFSIZE = 349;

const int _MAX_PATH = 260;

const int _MAX_DRIVE = 3;

const int _MAX_DIR = 256;

const int _MAX_FNAME = 256;

const int _MAX_EXT = 256;

const int _MAX_ENV = 32767;

const int EPERM = 1;

const int ENOENT = 2;

const int ESRCH = 3;

const int EINTR = 4;

const int EIO = 5;

const int ENXIO = 6;

const int E2BIG = 7;

const int ENOEXEC = 8;

const int EBADF = 9;

const int ECHILD = 10;

const int EAGAIN = 11;

const int ENOMEM = 12;

const int EACCES = 13;

const int EFAULT = 14;

const int EBUSY = 16;

const int EEXIST = 17;

const int EXDEV = 18;

const int ENODEV = 19;

const int ENOTDIR = 20;

const int EISDIR = 21;

const int ENFILE = 23;

const int EMFILE = 24;

const int ENOTTY = 25;

const int EFBIG = 27;

const int ENOSPC = 28;

const int ESPIPE = 29;

const int EROFS = 30;

const int EMLINK = 31;

const int EPIPE = 32;

const int EDOM = 33;

const int EDEADLK = 36;

const int ENAMETOOLONG = 38;

const int ENOLCK = 39;

const int ENOSYS = 40;

const int ENOTEMPTY = 41;

const int EINVAL = 22;

const int ERANGE = 34;

const int EILSEQ = 42;

const int STRUNCATE = 80;

const int EDEADLOCK = 36;

const int EADDRINUSE = 100;

const int EADDRNOTAVAIL = 101;

const int EAFNOSUPPORT = 102;

const int EALREADY = 103;

const int EBADMSG = 104;

const int ECANCELED = 105;

const int ECONNABORTED = 106;

const int ECONNREFUSED = 107;

const int ECONNRESET = 108;

const int EDESTADDRREQ = 109;

const int EHOSTUNREACH = 110;

const int EIDRM = 111;

const int EINPROGRESS = 112;

const int EISCONN = 113;

const int ELOOP = 114;

const int EMSGSIZE = 115;

const int ENETDOWN = 116;

const int ENETRESET = 117;

const int ENETUNREACH = 118;

const int ENOBUFS = 119;

const int ENODATA = 120;

const int ENOLINK = 121;

const int ENOMSG = 122;

const int ENOPROTOOPT = 123;

const int ENOSR = 124;

const int ENOSTR = 125;

const int ENOTCONN = 126;

const int ENOTRECOVERABLE = 127;

const int ENOTSOCK = 128;

const int ENOTSUP = 129;

const int EOPNOTSUPP = 130;

const int EOTHER = 131;

const int EOVERFLOW = 132;

const int EOWNERDEAD = 133;

const int EPROTO = 134;

const int EPROTONOSUPPORT = 135;

const int EPROTOTYPE = 136;

const int ETIME = 137;

const int ETIMEDOUT = 138;

const int ETXTBSY = 139;

const int EWOULDBLOCK = 140;

const int _NLSCMPERROR = 2147483647;

const String _CRT_INTERNAL_STDIO_SYMBOL_PREFIX = '';

const int _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION = 1;

const int _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR = 2;

const int _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS = 4;

const int _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY = 8;

const int _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS = 16;

const int _CRT_INTERNAL_SCANF_SECURECRT = 1;

const int _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS = 2;

const int _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY = 4;

const int WEOF = 65535;

const int BUFSIZ = 512;

const int _NFILE = 512;

const int _NSTREAM_ = 512;

const int _IOB_ENTRIES = 3;

const int EOF = -1;

const int _IOFBF = 0;

const int _IOLBF = 64;

const int _IONBF = 4;

const int L_tmpnam = 260;

const int L_tmpnam_s = 260;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const int SEEK_SET = 0;

const int FILENAME_MAX = 260;

const int FOPEN_MAX = 20;

const int _SYS_OPEN = 20;

const int TMP_MAX = 2147483647;

const int TMP_MAX_S = 2147483647;

const int _TMP_MAX_S = 2147483647;

const int SYS_OPEN = 20;

const int FLTimestampNone = -9223372036854775808;

const String PRId8 = 'hhd';

const String PRId16 = 'hd';

const String PRId32 = 'd';

const String PRId64 = 'lld';

const String PRIdLEAST8 = 'hhd';

const String PRIdLEAST16 = 'hd';

const String PRIdLEAST32 = 'd';

const String PRIdLEAST64 = 'lld';

const String PRIdFAST8 = 'hhd';

const String PRIdFAST16 = 'd';

const String PRIdFAST32 = 'd';

const String PRIdFAST64 = 'lld';

const String PRIdMAX = 'lld';

const String PRIdPTR = 'lld';

const String PRIi8 = 'hhi';

const String PRIi16 = 'hi';

const String PRIi32 = 'i';

const String PRIi64 = 'lli';

const String PRIiLEAST8 = 'hhi';

const String PRIiLEAST16 = 'hi';

const String PRIiLEAST32 = 'i';

const String PRIiLEAST64 = 'lli';

const String PRIiFAST8 = 'hhi';

const String PRIiFAST16 = 'i';

const String PRIiFAST32 = 'i';

const String PRIiFAST64 = 'lli';

const String PRIiMAX = 'lli';

const String PRIiPTR = 'lli';

const String PRIo8 = 'hho';

const String PRIo16 = 'ho';

const String PRIo32 = 'o';

const String PRIo64 = 'llo';

const String PRIoLEAST8 = 'hho';

const String PRIoLEAST16 = 'ho';

const String PRIoLEAST32 = 'o';

const String PRIoLEAST64 = 'llo';

const String PRIoFAST8 = 'hho';

const String PRIoFAST16 = 'o';

const String PRIoFAST32 = 'o';

const String PRIoFAST64 = 'llo';

const String PRIoMAX = 'llo';

const String PRIoPTR = 'llo';

const String PRIu8 = 'hhu';

const String PRIu16 = 'hu';

const String PRIu32 = 'u';

const String PRIu64 = 'llu';

const String PRIuLEAST8 = 'hhu';

const String PRIuLEAST16 = 'hu';

const String PRIuLEAST32 = 'u';

const String PRIuLEAST64 = 'llu';

const String PRIuFAST8 = 'hhu';

const String PRIuFAST16 = 'u';

const String PRIuFAST32 = 'u';

const String PRIuFAST64 = 'llu';

const String PRIuMAX = 'llu';

const String PRIuPTR = 'llu';

const String PRIx8 = 'hhx';

const String PRIx16 = 'hx';

const String PRIx32 = 'x';

const String PRIx64 = 'llx';

const String PRIxLEAST8 = 'hhx';

const String PRIxLEAST16 = 'hx';

const String PRIxLEAST32 = 'x';

const String PRIxLEAST64 = 'llx';

const String PRIxFAST8 = 'hhx';

const String PRIxFAST16 = 'x';

const String PRIxFAST32 = 'x';

const String PRIxFAST64 = 'llx';

const String PRIxMAX = 'llx';

const String PRIxPTR = 'llx';

const String PRIX8 = 'hhX';

const String PRIX16 = 'hX';

const String PRIX32 = 'X';

const String PRIX64 = 'llX';

const String PRIXLEAST8 = 'hhX';

const String PRIXLEAST16 = 'hX';

const String PRIXLEAST32 = 'X';

const String PRIXLEAST64 = 'llX';

const String PRIXFAST8 = 'hhX';

const String PRIXFAST16 = 'X';

const String PRIXFAST32 = 'X';

const String PRIXFAST64 = 'llX';

const String PRIXMAX = 'llX';

const String PRIXPTR = 'llX';

const String SCNd8 = 'hhd';

const String SCNd16 = 'hd';

const String SCNd32 = 'd';

const String SCNd64 = 'lld';

const String SCNdLEAST8 = 'hhd';

const String SCNdLEAST16 = 'hd';

const String SCNdLEAST32 = 'd';

const String SCNdLEAST64 = 'lld';

const String SCNdFAST8 = 'hhd';

const String SCNdFAST16 = 'd';

const String SCNdFAST32 = 'd';

const String SCNdFAST64 = 'lld';

const String SCNdMAX = 'lld';

const String SCNdPTR = 'lld';

const String SCNi8 = 'hhi';

const String SCNi16 = 'hi';

const String SCNi32 = 'i';

const String SCNi64 = 'lli';

const String SCNiLEAST8 = 'hhi';

const String SCNiLEAST16 = 'hi';

const String SCNiLEAST32 = 'i';

const String SCNiLEAST64 = 'lli';

const String SCNiFAST8 = 'hhi';

const String SCNiFAST16 = 'i';

const String SCNiFAST32 = 'i';

const String SCNiFAST64 = 'lli';

const String SCNiMAX = 'lli';

const String SCNiPTR = 'lli';

const String SCNo8 = 'hho';

const String SCNo16 = 'ho';

const String SCNo32 = 'o';

const String SCNo64 = 'llo';

const String SCNoLEAST8 = 'hho';

const String SCNoLEAST16 = 'ho';

const String SCNoLEAST32 = 'o';

const String SCNoLEAST64 = 'llo';

const String SCNoFAST8 = 'hho';

const String SCNoFAST16 = 'o';

const String SCNoFAST32 = 'o';

const String SCNoFAST64 = 'llo';

const String SCNoMAX = 'llo';

const String SCNoPTR = 'llo';

const String SCNu8 = 'hhu';

const String SCNu16 = 'hu';

const String SCNu32 = 'u';

const String SCNu64 = 'llu';

const String SCNuLEAST8 = 'hhu';

const String SCNuLEAST16 = 'hu';

const String SCNuLEAST32 = 'u';

const String SCNuLEAST64 = 'llu';

const String SCNuFAST8 = 'hhu';

const String SCNuFAST16 = 'u';

const String SCNuFAST32 = 'u';

const String SCNuFAST64 = 'llu';

const String SCNuMAX = 'llu';

const String SCNuPTR = 'llu';

const String SCNx8 = 'hhx';

const String SCNx16 = 'hx';

const String SCNx32 = 'x';

const String SCNx64 = 'llx';

const String SCNxLEAST8 = 'hhx';

const String SCNxLEAST16 = 'hx';

const String SCNxLEAST32 = 'x';

const String SCNxLEAST64 = 'llx';

const String SCNxFAST8 = 'hhx';

const String SCNxFAST16 = 'x';

const String SCNxFAST32 = 'x';

const String SCNxFAST64 = 'llx';

const String SCNxMAX = 'llx';

const String SCNxPTR = 'llx';

const int DART_FLAGS_CURRENT_VERSION = 12;

const int DART_INITIALIZE_PARAMS_CURRENT_VERSION = 4;

const int ILLEGAL_PORT = 0;

const String DART_KERNEL_ISOLATE_NAME = 'kernel-service';

const String DART_VM_SERVICE_ISOLATE_NAME = 'vm-service';

const String kSnapshotBuildIdCSymbol = '_kDartSnapshotBuildId';

const String kVmSnapshotDataCSymbol = '_kDartVmSnapshotData';

const String kVmSnapshotInstructionsCSymbol = '_kDartVmSnapshotInstructions';

const String kVmSnapshotBssCSymbol = '_kDartVmSnapshotBss';

const String kIsolateSnapshotDataCSymbol = '_kDartIsolateSnapshotData';

const String kIsolateSnapshotInstructionsCSymbol =
    '_kDartIsolateSnapshotInstructions';

const String kIsolateSnapshotBssCSymbol = '_kDartIsolateSnapshotBss';

const String kSnapshotBuildIdAsmSymbol = '_kDartSnapshotBuildId';

const String kVmSnapshotDataAsmSymbol = '_kDartVmSnapshotData';

const String kVmSnapshotInstructionsAsmSymbol = '_kDartVmSnapshotInstructions';

const String kVmSnapshotBssAsmSymbol = '_kDartVmSnapshotBss';

const String kIsolateSnapshotDataAsmSymbol = '_kDartIsolateSnapshotData';

const String kIsolateSnapshotInstructionsAsmSymbol =
    '_kDartIsolateSnapshotInstructions';

const String kIsolateSnapshotBssAsmSymbol = '_kDartIsolateSnapshotBss';

typedef _c_FLSlice_Equal = ffi.Uint8 Function(
  FLSlice a,
  FLSlice b,
);

typedef _dart_FLSlice_Equal = int Function(
  FLSlice a,
  FLSlice b,
);

typedef _c_FLSlice_Compare = ffi.Int32 Function(
  FLSlice arg0,
  FLSlice arg1,
);

typedef _dart_FLSlice_Compare = int Function(
  FLSlice arg0,
  FLSlice arg1,
);

typedef _c_FLSlice_Hash = ffi.Uint32 Function(
  FLSlice s,
);

typedef _dart_FLSlice_Hash = int Function(
  FLSlice s,
);

typedef _c_FLSlice_ToCString = ffi.Uint8 Function(
  FLSlice s,
  ffi.Pointer<ffi.Int8> buffer,
  ffi.Uint64 capacity,
);

typedef _dart_FLSlice_ToCString = int Function(
  FLSlice s,
  ffi.Pointer<ffi.Int8> buffer,
  int capacity,
);

typedef _c_FLSliceResult_New = FLSliceResult Function(
  ffi.Uint64 arg0,
);

typedef _dart_FLSliceResult_New = FLSliceResult Function(
  int arg0,
);

typedef _c_FLSlice_Copy = FLSliceResult Function(
  FLSlice arg0,
);

typedef _dart_FLSlice_Copy = FLSliceResult Function(
  FLSlice arg0,
);

typedef _c_FLBuf_Retain = ffi.Void Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _dart_FLBuf_Retain = void Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _c_FLBuf_Release = ffi.Void Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _dart_FLBuf_Release = void Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _c_FL_WipeMemory = ffi.Void Function(
  ffi.Pointer<ffi.Void> dst,
  ffi.Uint64 size,
);

typedef _dart_FL_WipeMemory = void Function(
  ffi.Pointer<ffi.Void> dst,
  int size,
);

typedef _c_CBLError_Message = FLSliceResult Function(
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLError_Message = FLSliceResult Function(
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBL_Now = ffi.Int64 Function();

typedef _dart_CBL_Now = int Function();

typedef _c_CBL_Retain = ffi.Pointer<CBLRefCounted> Function(
  ffi.Pointer<CBLRefCounted> arg0,
);

typedef _dart_CBL_Retain = ffi.Pointer<CBLRefCounted> Function(
  ffi.Pointer<CBLRefCounted> arg0,
);

typedef _c_CBL_Release = ffi.Void Function(
  ffi.Pointer<CBLRefCounted> arg0,
);

typedef _dart_CBL_Release = void Function(
  ffi.Pointer<CBLRefCounted> arg0,
);

typedef _c_CBL_InstanceCount = ffi.Uint32 Function();

typedef _dart_CBL_InstanceCount = int Function();

typedef _c_CBL_DumpInstances = ffi.Void Function();

typedef _dart_CBL_DumpInstances = void Function();

typedef _c_CBLListener_Remove = ffi.Void Function(
  ffi.Pointer<CBLListenerToken> arg0,
);

typedef _dart_CBLListener_Remove = void Function(
  ffi.Pointer<CBLListenerToken> arg0,
);

typedef _c_FLDoc_FromResultData = ffi.Pointer<FLDoc> Function(
  FLSliceResult data,
  ffi.Int32 arg1,
  ffi.Pointer<FLSharedKeys> arg2,
  FLSlice externData,
);

typedef _dart_FLDoc_FromResultData = ffi.Pointer<FLDoc> Function(
  FLSliceResult data,
  int arg1,
  ffi.Pointer<FLSharedKeys> arg2,
  FLSlice externData,
);

typedef _c_FLDoc_FromJSON = ffi.Pointer<FLDoc> Function(
  FLSlice json,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _dart_FLDoc_FromJSON = ffi.Pointer<FLDoc> Function(
  FLSlice json,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _c_FLDoc_Release = ffi.Void Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _dart_FLDoc_Release = void Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _c_FLDoc_Retain = ffi.Pointer<FLDoc> Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _dart_FLDoc_Retain = ffi.Pointer<FLDoc> Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _c_FLDoc_GetData = FLSlice Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _dart_FLDoc_GetData = FLSlice Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _c_FLDoc_GetAllocedData = FLSliceResult Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _dart_FLDoc_GetAllocedData = FLSliceResult Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _c_FLDoc_GetRoot = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _dart_FLDoc_GetRoot = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _c_FLDoc_GetSharedKeys = ffi.Pointer<FLSharedKeys> Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _dart_FLDoc_GetSharedKeys = ffi.Pointer<FLSharedKeys> Function(
  ffi.Pointer<FLDoc> arg0,
);

typedef _c_FLValue_FindDoc = ffi.Pointer<FLDoc> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_FindDoc = ffi.Pointer<FLDoc> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_FromData = ffi.Pointer<FLValue> Function(
  FLSlice data,
  ffi.Int32 arg1,
);

typedef _dart_FLValue_FromData = ffi.Pointer<FLValue> Function(
  FLSlice data,
  int arg1,
);

typedef _c_FLData_ConvertJSON = FLSliceResult Function(
  FLSlice json,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _dart_FLData_ConvertJSON = FLSliceResult Function(
  FLSlice json,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _c_FLData_Dump = FLSliceResult Function(
  FLSlice data,
);

typedef _dart_FLData_Dump = FLSliceResult Function(
  FLSlice data,
);

typedef _c_FLValue_ToJSON = FLSliceResult Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_ToJSON = FLSliceResult Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_ToJSON5 = FLSliceResult Function(
  ffi.Pointer<FLValue> v,
);

typedef _dart_FLValue_ToJSON5 = FLSliceResult Function(
  ffi.Pointer<FLValue> v,
);

typedef _c_FLValue_ToJSONX = FLSliceResult Function(
  ffi.Pointer<FLValue> v,
  ffi.Uint8 json5,
  ffi.Uint8 canonicalForm,
);

typedef _dart_FLValue_ToJSONX = FLSliceResult Function(
  ffi.Pointer<FLValue> v,
  int json5,
  int canonicalForm,
);

typedef _c_FLJSON5_ToJSON = FLSliceResult Function(
  FLSlice json5,
  ffi.Pointer<FLSliceResult> outErrorMessage,
  ffi.Pointer<ffi.Uint64> outErrorPos,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _dart_FLJSON5_ToJSON = FLSliceResult Function(
  FLSlice json5,
  ffi.Pointer<FLSliceResult> outErrorMessage,
  ffi.Pointer<ffi.Uint64> outErrorPos,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _c_FLDump = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLDump = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLDumpData = ffi.Pointer<ffi.Int8> Function(
  FLSlice data,
);

typedef _dart_FLDumpData = ffi.Pointer<ffi.Int8> Function(
  FLSlice data,
);

typedef _c_FLValue_GetType = ffi.Int32 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_GetType = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_IsInteger = ffi.Uint8 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_IsInteger = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_IsUnsigned = ffi.Uint8 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_IsUnsigned = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_IsDouble = ffi.Uint8 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_IsDouble = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsBool = ffi.Uint8 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsBool = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsInt = ffi.Int64 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsInt = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsUnsigned = ffi.Uint64 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsUnsigned = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsFloat = ffi.Float Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsFloat = double Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsDouble = ffi.Double Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsDouble = double Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsString = FLSlice Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsString = FLSlice Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsTimestamp = ffi.Int64 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsTimestamp = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsData = FLSlice Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsData = FLSlice Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_AsDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_AsDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_ToString = FLSliceResult Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_ToString = FLSliceResult Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_IsEqual = ffi.Uint8 Function(
  ffi.Pointer<FLValue> v1,
  ffi.Pointer<FLValue> v2,
);

typedef _dart_FLValue_IsEqual = int Function(
  ffi.Pointer<FLValue> v1,
  ffi.Pointer<FLValue> v2,
);

typedef _c_FLValue_IsMutable = ffi.Uint8 Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_IsMutable = int Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_Retain = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_Retain = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_Release = ffi.Void Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLValue_Release = void Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLValue_NewString = ffi.Pointer<FLValue> Function(
  FLSlice arg0,
);

typedef _dart_FLValue_NewString = ffi.Pointer<FLValue> Function(
  FLSlice arg0,
);

typedef _c_FLValue_NewData = ffi.Pointer<FLValue> Function(
  FLSlice arg0,
);

typedef _dart_FLValue_NewData = ffi.Pointer<FLValue> Function(
  FLSlice arg0,
);

typedef _c_FLArray_Count = ffi.Uint32 Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _dart_FLArray_Count = int Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _c_FLArray_IsEmpty = ffi.Uint8 Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _dart_FLArray_IsEmpty = int Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _c_FLArray_AsMutable = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _dart_FLArray_AsMutable = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _c_FLArray_Get = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Uint32 index,
);

typedef _dart_FLArray_Get = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLArray> arg0,
  int index,
);

typedef _c_FLArrayIterator_Begin = ffi.Void Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Pointer<FLArrayIterator> arg1,
);

typedef _dart_FLArrayIterator_Begin = void Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Pointer<FLArrayIterator> arg1,
);

typedef _c_FLArrayIterator_GetValue = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLArrayIterator> arg0,
);

typedef _dart_FLArrayIterator_GetValue = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLArrayIterator> arg0,
);

typedef _c_FLArrayIterator_GetValueAt = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLArrayIterator> arg0,
  ffi.Uint32 offset,
);

typedef _dart_FLArrayIterator_GetValueAt = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLArrayIterator> arg0,
  int offset,
);

typedef _c_FLArrayIterator_GetCount = ffi.Uint32 Function(
  ffi.Pointer<FLArrayIterator> arg0,
);

typedef _dart_FLArrayIterator_GetCount = int Function(
  ffi.Pointer<FLArrayIterator> arg0,
);

typedef _c_FLArrayIterator_Next = ffi.Uint8 Function(
  ffi.Pointer<FLArrayIterator> arg0,
);

typedef _dart_FLArrayIterator_Next = int Function(
  ffi.Pointer<FLArrayIterator> arg0,
);

typedef _c_FLArray_MutableCopy = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Int32 arg1,
);

typedef _dart_FLArray_MutableCopy = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
  int arg1,
);

typedef _c_FLMutableArray_New = ffi.Pointer<FLArray> Function();

typedef _dart_FLMutableArray_New = ffi.Pointer<FLArray> Function();

typedef _c_FLMutableArray_GetSource = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _dart_FLMutableArray_GetSource = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _c_FLMutableArray_IsChanged = ffi.Uint8 Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _dart_FLMutableArray_IsChanged = int Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _c_FLMutableArray_SetChanged = ffi.Void Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Uint8 arg1,
);

typedef _dart_FLMutableArray_SetChanged = void Function(
  ffi.Pointer<FLArray> arg0,
  int arg1,
);

typedef _c_FLMutableArray_Insert = ffi.Void Function(
  ffi.Pointer<FLArray> array,
  ffi.Uint32 firstIndex,
  ffi.Uint32 count,
);

typedef _dart_FLMutableArray_Insert = void Function(
  ffi.Pointer<FLArray> array,
  int firstIndex,
  int count,
);

typedef _c_FLMutableArray_Remove = ffi.Void Function(
  ffi.Pointer<FLArray> array,
  ffi.Uint32 firstIndex,
  ffi.Uint32 count,
);

typedef _dart_FLMutableArray_Remove = void Function(
  ffi.Pointer<FLArray> array,
  int firstIndex,
  int count,
);

typedef _c_FLMutableArray_Resize = ffi.Void Function(
  ffi.Pointer<FLArray> array,
  ffi.Uint32 size,
);

typedef _dart_FLMutableArray_Resize = void Function(
  ffi.Pointer<FLArray> array,
  int size,
);

typedef _c_FLMutableArray_GetMutableArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Uint32 index,
);

typedef _dart_FLMutableArray_GetMutableArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLArray> arg0,
  int index,
);

typedef _c_FLMutableArray_GetMutableDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Uint32 index,
);

typedef _dart_FLMutableArray_GetMutableDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLArray> arg0,
  int index,
);

typedef _c_FLDict_Count = ffi.Uint32 Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _dart_FLDict_Count = int Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _c_FLDict_IsEmpty = ffi.Uint8 Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _dart_FLDict_IsEmpty = int Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _c_FLDict_AsMutable = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _dart_FLDict_AsMutable = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _c_FLDict_Get = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice keyString,
);

typedef _dart_FLDict_Get = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice keyString,
);

typedef _c_FLDictIterator_Begin = ffi.Void Function(
  ffi.Pointer<FLDict> arg0,
  ffi.Pointer<FLDictIterator> arg1,
);

typedef _dart_FLDictIterator_Begin = void Function(
  ffi.Pointer<FLDict> arg0,
  ffi.Pointer<FLDictIterator> arg1,
);

typedef _c_FLDictIterator_GetKey = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _dart_FLDictIterator_GetKey = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _c_FLDictIterator_GetKeyString = FLSlice Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _dart_FLDictIterator_GetKeyString = FLSlice Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _c_FLDictIterator_GetValue = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _dart_FLDictIterator_GetValue = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _c_FLDictIterator_GetCount = ffi.Uint32 Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _dart_FLDictIterator_GetCount = int Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _c_FLDictIterator_Next = ffi.Uint8 Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _dart_FLDictIterator_Next = int Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _c_FLDictIterator_End = ffi.Void Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _dart_FLDictIterator_End = void Function(
  ffi.Pointer<FLDictIterator> arg0,
);

typedef _c_FLDictKey_Init = FLDictKey Function(
  FLSlice string,
);

typedef _dart_FLDictKey_Init = FLDictKey Function(
  FLSlice string,
);

typedef _c_FLDictKey_GetString = FLSlice Function(
  ffi.Pointer<FLDictKey> arg0,
);

typedef _dart_FLDictKey_GetString = FLSlice Function(
  ffi.Pointer<FLDictKey> arg0,
);

typedef _c_FLDict_GetWithKey = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDict> arg0,
  ffi.Pointer<FLDictKey> arg1,
);

typedef _dart_FLDict_GetWithKey = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDict> arg0,
  ffi.Pointer<FLDictKey> arg1,
);

typedef _c_FLDict_MutableCopy = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> source,
  ffi.Int32 arg1,
);

typedef _dart_FLDict_MutableCopy = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> source,
  int arg1,
);

typedef _c_FLMutableDict_New = ffi.Pointer<FLDict> Function();

typedef _dart_FLMutableDict_New = ffi.Pointer<FLDict> Function();

typedef _c_FLMutableDict_GetSource = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _dart_FLMutableDict_GetSource = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _c_FLMutableDict_IsChanged = ffi.Uint8 Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _dart_FLMutableDict_IsChanged = int Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _c_FLMutableDict_SetChanged = ffi.Void Function(
  ffi.Pointer<FLDict> arg0,
  ffi.Uint8 arg1,
);

typedef _dart_FLMutableDict_SetChanged = void Function(
  ffi.Pointer<FLDict> arg0,
  int arg1,
);

typedef _c_FLMutableDict_Remove = ffi.Void Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice key,
);

typedef _dart_FLMutableDict_Remove = void Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice key,
);

typedef _c_FLMutableDict_RemoveAll = ffi.Void Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _dart_FLMutableDict_RemoveAll = void Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _c_FLMutableDict_GetMutableArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice key,
);

typedef _dart_FLMutableDict_GetMutableArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice key,
);

typedef _c_FLMutableDict_GetMutableDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice key,
);

typedef _dart_FLMutableDict_GetMutableDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<FLDict> arg0,
  FLSlice key,
);

typedef _c_FLDeepIterator_New = ffi.Pointer<FLDeepIterator> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _dart_FLDeepIterator_New = ffi.Pointer<FLDeepIterator> Function(
  ffi.Pointer<FLValue> arg0,
);

typedef _c_FLDeepIterator_Free = ffi.Void Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_Free = void Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_GetValue = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_GetValue = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_GetParent = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_GetParent = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_GetKey = FLSlice Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_GetKey = FLSlice Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_GetIndex = ffi.Uint32 Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_GetIndex = int Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_GetDepth = ffi.Uint64 Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_GetDepth = int Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_SkipChildren = ffi.Void Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_SkipChildren = void Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_Next = ffi.Uint8 Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_Next = int Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_GetPath = ffi.Void Function(
  ffi.Pointer<FLDeepIterator> arg0,
  ffi.Pointer<ffi.Pointer<FLPathComponent>> outPath,
  ffi.Pointer<ffi.Uint64> outDepth,
);

typedef _dart_FLDeepIterator_GetPath = void Function(
  ffi.Pointer<FLDeepIterator> arg0,
  ffi.Pointer<ffi.Pointer<FLPathComponent>> outPath,
  ffi.Pointer<ffi.Uint64> outDepth,
);

typedef _c_FLDeepIterator_GetPathString = FLSliceResult Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_GetPathString = FLSliceResult Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLDeepIterator_GetJSONPointer = FLSliceResult Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _dart_FLDeepIterator_GetJSONPointer = FLSliceResult Function(
  ffi.Pointer<FLDeepIterator> arg0,
);

typedef _c_FLKeyPath_New = ffi.Pointer<FLKeyPath> Function(
  FLSlice specifier,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_FLKeyPath_New = ffi.Pointer<FLKeyPath> Function(
  FLSlice specifier,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_FLKeyPath_Free = ffi.Void Function(
  ffi.Pointer<FLKeyPath> arg0,
);

typedef _dart_FLKeyPath_Free = void Function(
  ffi.Pointer<FLKeyPath> arg0,
);

typedef _c_FLKeyPath_Eval = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLKeyPath> arg0,
  ffi.Pointer<FLValue> root,
);

typedef _dart_FLKeyPath_Eval = ffi.Pointer<FLValue> Function(
  ffi.Pointer<FLKeyPath> arg0,
  ffi.Pointer<FLValue> root,
);

typedef _c_FLKeyPath_EvalOnce = ffi.Pointer<FLValue> Function(
  FLSlice specifier,
  ffi.Pointer<FLValue> root,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_FLKeyPath_EvalOnce = ffi.Pointer<FLValue> Function(
  FLSlice specifier,
  ffi.Pointer<FLValue> root,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_FLKeyPath_ToString = FLSliceResult Function(
  ffi.Pointer<FLKeyPath> path,
);

typedef _dart_FLKeyPath_ToString = FLSliceResult Function(
  ffi.Pointer<FLKeyPath> path,
);

typedef _c_FLKeyPath_Equals = ffi.Uint8 Function(
  ffi.Pointer<FLKeyPath> path1,
  ffi.Pointer<FLKeyPath> path2,
);

typedef _dart_FLKeyPath_Equals = int Function(
  ffi.Pointer<FLKeyPath> path1,
  ffi.Pointer<FLKeyPath> path2,
);

typedef _c_FLKeyPath_GetElement = ffi.Uint8 Function(
  ffi.Pointer<FLKeyPath> arg0,
  ffi.Uint64 i,
  ffi.Pointer<FLSlice> outDictKey,
  ffi.Pointer<ffi.Int32> outArrayIndex,
);

typedef _dart_FLKeyPath_GetElement = int Function(
  ffi.Pointer<FLKeyPath> arg0,
  int i,
  ffi.Pointer<FLSlice> outDictKey,
  ffi.Pointer<ffi.Int32> outArrayIndex,
);

typedef _c_FLSharedKeys_New = ffi.Pointer<FLSharedKeys> Function();

typedef _dart_FLSharedKeys_New = ffi.Pointer<FLSharedKeys> Function();

typedef FLSharedKeysReadCallback = ffi.Uint8 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<FLSharedKeys>,
);

typedef _c_FLSharedKeys_NewWithRead = ffi.Pointer<FLSharedKeys> Function(
  ffi.Pointer<ffi.NativeFunction<FLSharedKeysReadCallback>> arg0,
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_FLSharedKeys_NewWithRead = ffi.Pointer<FLSharedKeys> Function(
  ffi.Pointer<ffi.NativeFunction<FLSharedKeysReadCallback>> arg0,
  ffi.Pointer<ffi.Void> context,
);

typedef _c_FLSharedKeys_GetStateData = FLSliceResult Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _dart_FLSharedKeys_GetStateData = FLSliceResult Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _c_FLSharedKeys_LoadStateData = ffi.Uint8 Function(
  ffi.Pointer<FLSharedKeys> arg0,
  FLSlice arg1,
);

typedef _dart_FLSharedKeys_LoadStateData = int Function(
  ffi.Pointer<FLSharedKeys> arg0,
  FLSlice arg1,
);

typedef _c_FLSharedKeys_WriteState = ffi.Void Function(
  ffi.Pointer<FLSharedKeys> arg0,
  ffi.Pointer<FLEncoder> arg1,
);

typedef _dart_FLSharedKeys_WriteState = void Function(
  ffi.Pointer<FLSharedKeys> arg0,
  ffi.Pointer<FLEncoder> arg1,
);

typedef _c_FLSharedKeys_LoadState = ffi.Uint8 Function(
  ffi.Pointer<FLSharedKeys> arg0,
  ffi.Pointer<FLValue> arg1,
);

typedef _dart_FLSharedKeys_LoadState = int Function(
  ffi.Pointer<FLSharedKeys> arg0,
  ffi.Pointer<FLValue> arg1,
);

typedef _c_FLSharedKeys_Encode = ffi.Int32 Function(
  ffi.Pointer<FLSharedKeys> arg0,
  FLSlice arg1,
  ffi.Uint8 add,
);

typedef _dart_FLSharedKeys_Encode = int Function(
  ffi.Pointer<FLSharedKeys> arg0,
  FLSlice arg1,
  int add,
);

typedef _c_FLSharedKeys_Decode = FLSlice Function(
  ffi.Pointer<FLSharedKeys> arg0,
  ffi.Int32 key,
);

typedef _dart_FLSharedKeys_Decode = FLSlice Function(
  ffi.Pointer<FLSharedKeys> arg0,
  int key,
);

typedef _c_FLSharedKeys_Count = ffi.Uint32 Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _dart_FLSharedKeys_Count = int Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _c_FLSharedKeys_RevertToCount = ffi.Void Function(
  ffi.Pointer<FLSharedKeys> arg0,
  ffi.Uint32 oldCount,
);

typedef _dart_FLSharedKeys_RevertToCount = void Function(
  ffi.Pointer<FLSharedKeys> arg0,
  int oldCount,
);

typedef _c_FLSharedKeys_Retain = ffi.Pointer<FLSharedKeys> Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _dart_FLSharedKeys_Retain = ffi.Pointer<FLSharedKeys> Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _c_FLSharedKeys_Release = ffi.Void Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _dart_FLSharedKeys_Release = void Function(
  ffi.Pointer<FLSharedKeys> arg0,
);

typedef _c_FLSharedKeyScope_WithRange = ffi.Pointer<FLSharedKeyScope> Function(
  FLSlice range,
  ffi.Pointer<FLSharedKeys> arg1,
);

typedef _dart_FLSharedKeyScope_WithRange = ffi.Pointer<FLSharedKeyScope>
    Function(
  FLSlice range,
  ffi.Pointer<FLSharedKeys> arg1,
);

typedef _c_FLSharedKeyScope_Free = ffi.Void Function(
  ffi.Pointer<FLSharedKeyScope> arg0,
);

typedef _dart_FLSharedKeyScope_Free = void Function(
  ffi.Pointer<FLSharedKeyScope> arg0,
);

typedef _c_FLEncoder_New = ffi.Pointer<FLEncoder> Function();

typedef _dart_FLEncoder_New = ffi.Pointer<FLEncoder> Function();

typedef _c_FLEncoder_NewWithOptions = ffi.Pointer<FLEncoder> Function(
  ffi.Int32 format,
  ffi.Uint64 reserveSize,
  ffi.Uint8 uniqueStrings,
);

typedef _dart_FLEncoder_NewWithOptions = ffi.Pointer<FLEncoder> Function(
  int format,
  int reserveSize,
  int uniqueStrings,
);

typedef _c_FLEncoder_NewWritingToFile = ffi.Pointer<FLEncoder> Function(
  ffi.Pointer<FILE> arg0,
  ffi.Uint8 uniqueStrings,
);

typedef _dart_FLEncoder_NewWritingToFile = ffi.Pointer<FLEncoder> Function(
  ffi.Pointer<FILE> arg0,
  int uniqueStrings,
);

typedef _c_FLEncoder_Free = ffi.Void Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_Free = void Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_SetSharedKeys = ffi.Void Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<FLSharedKeys> arg1,
);

typedef _dart_FLEncoder_SetSharedKeys = void Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<FLSharedKeys> arg1,
);

typedef _c_FLEncoder_SetExtraInfo = ffi.Void Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<ffi.Void> info,
);

typedef _dart_FLEncoder_SetExtraInfo = void Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<ffi.Void> info,
);

typedef _c_FLEncoder_GetExtraInfo = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_GetExtraInfo = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_Amend = ffi.Void Function(
  ffi.Pointer<FLEncoder> e,
  FLSlice base,
  ffi.Uint8 reuseStrings,
  ffi.Uint8 externPointers,
);

typedef _dart_FLEncoder_Amend = void Function(
  ffi.Pointer<FLEncoder> e,
  FLSlice base,
  int reuseStrings,
  int externPointers,
);

typedef _c_FLEncoder_GetBase = FLSlice Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_GetBase = FLSlice Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_SuppressTrailer = ffi.Void Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_SuppressTrailer = void Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_Reset = ffi.Void Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_Reset = void Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_BytesWritten = ffi.Uint64 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_BytesWritten = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_GetNextWritePos = ffi.Uint64 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_GetNextWritePos = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_WriteNull = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_WriteNull = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_WriteUndefined = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_WriteUndefined = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_WriteBool = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Uint8 arg1,
);

typedef _dart_FLEncoder_WriteBool = int Function(
  ffi.Pointer<FLEncoder> arg0,
  int arg1,
);

typedef _c_FLEncoder_WriteInt = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Int64 arg1,
);

typedef _dart_FLEncoder_WriteInt = int Function(
  ffi.Pointer<FLEncoder> arg0,
  int arg1,
);

typedef _c_FLEncoder_WriteUInt = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Uint64 arg1,
);

typedef _dart_FLEncoder_WriteUInt = int Function(
  ffi.Pointer<FLEncoder> arg0,
  int arg1,
);

typedef _c_FLEncoder_WriteFloat = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Float arg1,
);

typedef _dart_FLEncoder_WriteFloat = int Function(
  ffi.Pointer<FLEncoder> arg0,
  double arg1,
);

typedef _c_FLEncoder_WriteDouble = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Double arg1,
);

typedef _dart_FLEncoder_WriteDouble = int Function(
  ffi.Pointer<FLEncoder> arg0,
  double arg1,
);

typedef _c_FLEncoder_WriteString = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _dart_FLEncoder_WriteString = int Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _c_FLEncoder_WriteDateString = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> encoder,
  ffi.Int64 ts,
  ffi.Uint8 asUTC,
);

typedef _dart_FLEncoder_WriteDateString = int Function(
  ffi.Pointer<FLEncoder> encoder,
  int ts,
  int asUTC,
);

typedef _c_FLEncoder_WriteData = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _dart_FLEncoder_WriteData = int Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _c_FLEncoder_WriteRaw = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _dart_FLEncoder_WriteRaw = int Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _c_FLEncoder_BeginArray = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Uint64 reserveCount,
);

typedef _dart_FLEncoder_BeginArray = int Function(
  ffi.Pointer<FLEncoder> arg0,
  int reserveCount,
);

typedef _c_FLEncoder_EndArray = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_EndArray = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_BeginDict = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Uint64 reserveCount,
);

typedef _dart_FLEncoder_BeginDict = int Function(
  ffi.Pointer<FLEncoder> arg0,
  int reserveCount,
);

typedef _c_FLEncoder_WriteKey = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _dart_FLEncoder_WriteKey = int Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice arg1,
);

typedef _c_FLEncoder_WriteKeyValue = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<FLValue> arg1,
);

typedef _dart_FLEncoder_WriteKeyValue = int Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<FLValue> arg1,
);

typedef _c_FLEncoder_EndDict = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_EndDict = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_WriteValue = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<FLValue> arg1,
);

typedef _dart_FLEncoder_WriteValue = int Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<FLValue> arg1,
);

typedef _c_FLEncoder_LastValueWritten = ffi.IntPtr Function(
  ffi.Pointer<FLEncoder> e,
);

typedef _dart_FLEncoder_LastValueWritten = int Function(
  ffi.Pointer<FLEncoder> e,
);

typedef _c_FLEncoder_WriteValueAgain = ffi.Void Function(
  ffi.Pointer<FLEncoder> e,
  ffi.IntPtr preWrittenValue,
);

typedef _dart_FLEncoder_WriteValueAgain = void Function(
  ffi.Pointer<FLEncoder> e,
  int preWrittenValue,
);

typedef _c_FLEncoder_Snip = FLSliceResult Function(
  ffi.Pointer<FLEncoder> e,
);

typedef _dart_FLEncoder_Snip = FLSliceResult Function(
  ffi.Pointer<FLEncoder> e,
);

typedef _c_FLEncoder_ConvertJSON = ffi.Uint8 Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice json,
);

typedef _dart_FLEncoder_ConvertJSON = int Function(
  ffi.Pointer<FLEncoder> arg0,
  FLSlice json,
);

typedef _c_FLEncoder_FinishItem = ffi.Uint64 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_FinishItem = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_FinishDoc = ffi.Pointer<FLDoc> Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<ffi.Int32> arg1,
);

typedef _dart_FLEncoder_FinishDoc = ffi.Pointer<FLDoc> Function(
  ffi.Pointer<FLEncoder> arg0,
  ffi.Pointer<ffi.Int32> arg1,
);

typedef _c_FLEncoder_Finish = FLSliceResult Function(
  ffi.Pointer<FLEncoder> e,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _dart_FLEncoder_Finish = FLSliceResult Function(
  ffi.Pointer<FLEncoder> e,
  ffi.Pointer<ffi.Int32> outError,
);

typedef _c_FLEncoder_GetError = ffi.Int32 Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_GetError = int Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLEncoder_GetErrorMessage = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _dart_FLEncoder_GetErrorMessage = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<FLEncoder> arg0,
);

typedef _c_FLCreateJSONDelta = FLSliceResult Function(
  ffi.Pointer<FLValue> old,
  ffi.Pointer<FLValue> nuu,
);

typedef _dart_FLCreateJSONDelta = FLSliceResult Function(
  ffi.Pointer<FLValue> old,
  ffi.Pointer<FLValue> nuu,
);

typedef _c_FLEncodeJSONDelta = ffi.Uint8 Function(
  ffi.Pointer<FLValue> old,
  ffi.Pointer<FLValue> nuu,
  ffi.Pointer<FLEncoder> jsonEncoder,
);

typedef _dart_FLEncodeJSONDelta = int Function(
  ffi.Pointer<FLValue> old,
  ffi.Pointer<FLValue> nuu,
  ffi.Pointer<FLEncoder> jsonEncoder,
);

typedef _c_FLApplyJSONDelta = FLSliceResult Function(
  ffi.Pointer<FLValue> old,
  FLSlice jsonDelta,
  ffi.Pointer<ffi.Int32> error,
);

typedef _dart_FLApplyJSONDelta = FLSliceResult Function(
  ffi.Pointer<FLValue> old,
  FLSlice jsonDelta,
  ffi.Pointer<ffi.Int32> error,
);

typedef _c_FLEncodeApplyingJSONDelta = ffi.Uint8 Function(
  ffi.Pointer<FLValue> old,
  FLSlice jsonDelta,
  ffi.Pointer<FLEncoder> encoder,
);

typedef _dart_FLEncodeApplyingJSONDelta = int Function(
  ffi.Pointer<FLValue> old,
  FLSlice jsonDelta,
  ffi.Pointer<FLEncoder> encoder,
);

typedef _c_FLMutableArray_Set = ffi.Pointer<FLSlot> Function(
  ffi.Pointer<FLArray> arg0,
  ffi.Uint32 index,
);

typedef _dart_FLMutableArray_Set = ffi.Pointer<FLSlot> Function(
  ffi.Pointer<FLArray> arg0,
  int index,
);

typedef _c_FLMutableArray_Append = ffi.Pointer<FLSlot> Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _dart_FLMutableArray_Append = ffi.Pointer<FLSlot> Function(
  ffi.Pointer<FLArray> arg0,
);

typedef _c_FLMutableDict_Set = ffi.Pointer<FLSlot> Function(
  ffi.Pointer<FLDict> FL_NONNULL,
  FLSlice key,
);

typedef _dart_FLMutableDict_Set = ffi.Pointer<FLSlot> Function(
  ffi.Pointer<FLDict> FL_NONNULL,
  FLSlice key,
);

typedef _c_FLSlot_SetNull = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
);

typedef _dart_FLSlot_SetNull = void Function(
  ffi.Pointer<FLSlot> arg0,
);

typedef _c_FLSlot_SetBool = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  ffi.Uint8 arg1,
);

typedef _dart_FLSlot_SetBool = void Function(
  ffi.Pointer<FLSlot> arg0,
  int arg1,
);

typedef _c_FLSlot_SetInt = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  ffi.Int64 arg1,
);

typedef _dart_FLSlot_SetInt = void Function(
  ffi.Pointer<FLSlot> arg0,
  int arg1,
);

typedef _c_FLSlot_SetUInt = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  ffi.Uint64 arg1,
);

typedef _dart_FLSlot_SetUInt = void Function(
  ffi.Pointer<FLSlot> arg0,
  int arg1,
);

typedef _c_FLSlot_SetFloat = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  ffi.Float arg1,
);

typedef _dart_FLSlot_SetFloat = void Function(
  ffi.Pointer<FLSlot> arg0,
  double arg1,
);

typedef _c_FLSlot_SetDouble = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  ffi.Double arg1,
);

typedef _dart_FLSlot_SetDouble = void Function(
  ffi.Pointer<FLSlot> arg0,
  double arg1,
);

typedef _c_FLSlot_SetString = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  FLSlice arg1,
);

typedef _dart_FLSlot_SetString = void Function(
  ffi.Pointer<FLSlot> arg0,
  FLSlice arg1,
);

typedef _c_FLSlot_SetData = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  FLSlice arg1,
);

typedef _dart_FLSlot_SetData = void Function(
  ffi.Pointer<FLSlot> arg0,
  FLSlice arg1,
);

typedef _c_FLSlot_SetValue = ffi.Void Function(
  ffi.Pointer<FLSlot> arg0,
  ffi.Pointer<FLValue> arg1,
);

typedef _dart_FLSlot_SetValue = void Function(
  ffi.Pointer<FLSlot> arg0,
  ffi.Pointer<FLValue> arg1,
);

typedef _c_FLDict_IsBlob = ffi.Uint8 Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _dart_FLDict_IsBlob = int Function(
  ffi.Pointer<FLDict> arg0,
);

typedef _c_FLDict_GetBlob = ffi.Pointer<CBLBlob> Function(
  ffi.Pointer<FLDict> blobDict,
);

typedef _dart_FLDict_GetBlob = ffi.Pointer<CBLBlob> Function(
  ffi.Pointer<FLDict> blobDict,
);

typedef _c_CBLBlob_Length = ffi.Uint64 Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _dart_CBLBlob_Length = int Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _c_CBLBlob_Digest = FLSlice Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _dart_CBLBlob_Digest = FLSlice Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _c_CBLBlob_ContentType = FLSlice Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _dart_CBLBlob_ContentType = FLSlice Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _c_CBLBlob_Properties = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _dart_CBLBlob_Properties = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLBlob> arg0,
);

typedef _c_CBLBlob_ToJSON = FLSliceResult Function(
  ffi.Pointer<CBLBlob> blob,
);

typedef _dart_CBLBlob_ToJSON = FLSliceResult Function(
  ffi.Pointer<CBLBlob> blob,
);

typedef _c_CBLBlob_Content = FLSliceResult Function(
  ffi.Pointer<CBLBlob> blob,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLBlob_Content = FLSliceResult Function(
  ffi.Pointer<CBLBlob> blob,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLBlob_OpenContentStream = ffi.Pointer<CBLBlobReadStream> Function(
  ffi.Pointer<CBLBlob> blob,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLBlob_OpenContentStream = ffi.Pointer<CBLBlobReadStream>
    Function(
  ffi.Pointer<CBLBlob> blob,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLBlobReader_Read = ffi.Int32 Function(
  ffi.Pointer<CBLBlobReadStream> stream,
  ffi.Pointer<ffi.Void> dst,
  ffi.Uint64 maxLength,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLBlobReader_Read = int Function(
  ffi.Pointer<CBLBlobReadStream> stream,
  ffi.Pointer<ffi.Void> dst,
  int maxLength,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLBlobReader_Close = ffi.Void Function(
  ffi.Pointer<CBLBlobReadStream> arg0,
);

typedef _dart_CBLBlobReader_Close = void Function(
  ffi.Pointer<CBLBlobReadStream> arg0,
);

typedef _c_CBLBlob_CreateWithData = ffi.Pointer<CBLBlob> Function(
  FLSlice contentType,
  FLSlice contents,
);

typedef _dart_CBLBlob_CreateWithData = ffi.Pointer<CBLBlob> Function(
  FLSlice contentType,
  FLSlice contents,
);

typedef _c_CBLBlobWriter_Create = ffi.Pointer<CBLBlobWriteStream> Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLBlobWriter_Create = ffi.Pointer<CBLBlobWriteStream> Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLBlobWriter_Close = ffi.Void Function(
  ffi.Pointer<CBLBlobWriteStream> arg0,
);

typedef _dart_CBLBlobWriter_Close = void Function(
  ffi.Pointer<CBLBlobWriteStream> arg0,
);

typedef _c_CBLBlobWriter_Write = ffi.Uint8 Function(
  ffi.Pointer<CBLBlobWriteStream> writer,
  ffi.Pointer<ffi.Void> data,
  ffi.Uint64 length,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLBlobWriter_Write = int Function(
  ffi.Pointer<CBLBlobWriteStream> writer,
  ffi.Pointer<ffi.Void> data,
  int length,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLBlob_CreateWithStream = ffi.Pointer<CBLBlob> Function(
  FLSlice contentType,
  ffi.Pointer<CBLBlobWriteStream> writer,
);

typedef _dart_CBLBlob_CreateWithStream = ffi.Pointer<CBLBlob> Function(
  FLSlice contentType,
  ffi.Pointer<CBLBlobWriteStream> writer,
);

typedef _c_FLSlot_SetBlob = ffi.Void Function(
  ffi.Pointer<FLSlot> slot,
  ffi.Pointer<CBLBlob> blob,
);

typedef _dart_FLSlot_SetBlob = void Function(
  ffi.Pointer<FLSlot> slot,
  ffi.Pointer<CBLBlob> blob,
);

typedef _c_CBLDatabase_GetBlob = ffi.Pointer<CBLBlob> Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<FLDict> properties,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_GetBlob = ffi.Pointer<CBLBlob> Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<FLDict> properties,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_SaveBlob = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLBlob> blob,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_SaveBlob = int Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLBlob> blob,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabaseConfiguration_Default = CBLDatabaseConfiguration
    Function();

typedef _dart_CBLDatabaseConfiguration_Default = CBLDatabaseConfiguration
    Function();

typedef _c_CBL_DatabaseExists = ffi.Uint8 Function(
  FLSlice name,
  FLSlice inDirectory,
);

typedef _dart_CBL_DatabaseExists = int Function(
  FLSlice name,
  FLSlice inDirectory,
);

typedef _c_CBL_CopyDatabase = ffi.Uint8 Function(
  FLSlice fromPath,
  FLSlice toName,
  ffi.Pointer<CBLDatabaseConfiguration> config,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBL_CopyDatabase = int Function(
  FLSlice fromPath,
  FLSlice toName,
  ffi.Pointer<CBLDatabaseConfiguration> config,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBL_DeleteDatabase = ffi.Uint8 Function(
  FLSlice name,
  FLSlice inDirectory,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBL_DeleteDatabase = int Function(
  FLSlice name,
  FLSlice inDirectory,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_Open = ffi.Pointer<CBLDatabase> Function(
  FLSlice name,
  ffi.Pointer<CBLDatabaseConfiguration> config,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_Open = ffi.Pointer<CBLDatabase> Function(
  FLSlice name,
  ffi.Pointer<CBLDatabaseConfiguration> config,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_Close = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_Close = int Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_Delete = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_Delete = int Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_BeginTransaction = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_BeginTransaction = int Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_EndTransaction = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> arg0,
  ffi.Uint8 commit,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_EndTransaction = int Function(
  ffi.Pointer<CBLDatabase> arg0,
  int commit,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_PerformMaintenance = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Uint32 type,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_PerformMaintenance = int Function(
  ffi.Pointer<CBLDatabase> db,
  int type,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_Name = FLSlice Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef _dart_CBLDatabase_Name = FLSlice Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef _c_CBLDatabase_Path = FLSliceResult Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef _dart_CBLDatabase_Path = FLSliceResult Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef _c_CBLDatabase_Count = ffi.Uint64 Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef _dart_CBLDatabase_Count = int Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef _c_CBLDatabase_Config = CBLDatabaseConfiguration Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef _dart_CBLDatabase_Config = CBLDatabaseConfiguration Function(
  ffi.Pointer<CBLDatabase> arg0,
);

typedef CBLDatabaseChangeListener = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLDatabase>,
  ffi.Uint32,
  ffi.Pointer<FLSlice>,
);

typedef _c_CBLDatabase_AddChangeListener = ffi.Pointer<CBLListenerToken>
    Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.NativeFunction<CBLDatabaseChangeListener>> listener,
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_CBLDatabase_AddChangeListener = ffi.Pointer<CBLListenerToken>
    Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.NativeFunction<CBLDatabaseChangeListener>> listener,
  ffi.Pointer<ffi.Void> context,
);

typedef CBLNotificationsReadyCallback = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLDatabase>,
);

typedef _c_CBLDatabase_BufferNotifications = ffi.Void Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.NativeFunction<CBLNotificationsReadyCallback>> callback,
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_CBLDatabase_BufferNotifications = void Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<ffi.NativeFunction<CBLNotificationsReadyCallback>> callback,
  ffi.Pointer<ffi.Void> context,
);

typedef _c_CBLDatabase_SendNotifications = ffi.Void Function(
  ffi.Pointer<CBLDatabase> db,
);

typedef _dart_CBLDatabase_SendNotifications = void Function(
  ffi.Pointer<CBLDatabase> db,
);

typedef _c_CBLDatabase_GetDocument = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDatabase> database,
  FLSlice docID,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_GetDocument = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDatabase> database,
  FLSlice docID,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_SaveDocument = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> doc,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_SaveDocument = int Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> doc,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_SaveDocumentWithConcurrencyControl = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> doc,
  ffi.Uint8 concurrency,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_SaveDocumentWithConcurrencyControl = int Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> doc,
  int concurrency,
  ffi.Pointer<CBLError> outError,
);

typedef CBLConflictHandler = ffi.Uint8 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLDocument>,
  ffi.Pointer<CBLDocument>,
);

typedef _c_CBLDatabase_SaveDocumentWithConflictHandler = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> doc,
  ffi.Pointer<ffi.NativeFunction<CBLConflictHandler>> conflictHandler,
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_SaveDocumentWithConflictHandler = int Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> doc,
  ffi.Pointer<ffi.NativeFunction<CBLConflictHandler>> conflictHandler,
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_DeleteDocument = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> document,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_DeleteDocument = int Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> document,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_DeleteDocumentWithConcurrencyControl = ffi.Uint8
    Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> document,
  ffi.Uint8 concurrency,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_DeleteDocumentWithConcurrencyControl = int Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> document,
  int concurrency,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_PurgeDocument = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> document,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_PurgeDocument = int Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Pointer<CBLDocument> document,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_PurgeDocumentByID = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> database,
  FLSlice docID,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_PurgeDocumentByID = int Function(
  ffi.Pointer<CBLDatabase> database,
  FLSlice docID,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_GetMutableDocument = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDatabase> database,
  FLSlice docID,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_GetMutableDocument = ffi.Pointer<CBLDocument>
    Function(
  ffi.Pointer<CBLDatabase> database,
  FLSlice docID,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDocument_Create = ffi.Pointer<CBLDocument> Function();

typedef _dart_CBLDocument_Create = ffi.Pointer<CBLDocument> Function();

typedef _c_CBLDocument_CreateWithID = ffi.Pointer<CBLDocument> Function(
  FLSlice docID,
);

typedef _dart_CBLDocument_CreateWithID = ffi.Pointer<CBLDocument> Function(
  FLSlice docID,
);

typedef _c_CBLDocument_MutableCopy = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDocument> original,
);

typedef _dart_CBLDocument_MutableCopy = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<CBLDocument> original,
);

typedef _c_CBLDocument_ID = FLSlice Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _dart_CBLDocument_ID = FLSlice Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _c_CBLDocument_RevisionID = FLSlice Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _dart_CBLDocument_RevisionID = FLSlice Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _c_CBLDocument_Sequence = ffi.Uint64 Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _dart_CBLDocument_Sequence = int Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _c_CBLDocument_Properties = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _dart_CBLDocument_Properties = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _c_CBLDocument_MutableProperties = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _dart_CBLDocument_MutableProperties = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _c_CBLDocument_SetProperties = ffi.Void Function(
  ffi.Pointer<CBLDocument> arg0,
  ffi.Pointer<FLDict> properties,
);

typedef _dart_CBLDocument_SetProperties = void Function(
  ffi.Pointer<CBLDocument> arg0,
  ffi.Pointer<FLDict> properties,
);

typedef _c_CBLDocument_CreateJSON = FLSliceResult Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _dart_CBLDocument_CreateJSON = FLSliceResult Function(
  ffi.Pointer<CBLDocument> arg0,
);

typedef _c_CBLDocument_SetJSON = ffi.Uint8 Function(
  ffi.Pointer<CBLDocument> arg0,
  FLSlice json,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDocument_SetJSON = int Function(
  ffi.Pointer<CBLDocument> arg0,
  FLSlice json,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_GetDocumentExpiration = ffi.Int64 Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice docID,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_GetDocumentExpiration = int Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice docID,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_SetDocumentExpiration = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice docID,
  ffi.Int64 expiration,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_SetDocumentExpiration = int Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice docID,
  int expiration,
  ffi.Pointer<CBLError> outError,
);

typedef CBLDocumentChangeListener = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLDatabase>,
  FLSlice,
);

typedef _c_CBLDatabase_AddDocumentChangeListener = ffi.Pointer<CBLListenerToken>
    Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice docID,
  ffi.Pointer<ffi.NativeFunction<CBLDocumentChangeListener>> listener,
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_CBLDatabase_AddDocumentChangeListener
    = ffi.Pointer<CBLListenerToken> Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice docID,
  ffi.Pointer<ffi.NativeFunction<CBLDocumentChangeListener>> listener,
  ffi.Pointer<ffi.Void> context,
);

typedef _c_CBL_Log = ffi.Void Function(
  ffi.Uint8 domain,
  ffi.Uint8 level,
  ffi.Pointer<ffi.Int8> format,
);

typedef _dart_CBL_Log = void Function(
  int domain,
  int level,
  ffi.Pointer<ffi.Int8> format,
);

typedef _c_CBL_LogMessage = ffi.Void Function(
  ffi.Uint8 domain,
  ffi.Uint8 level,
  FLSlice message,
);

typedef _dart_CBL_LogMessage = void Function(
  int domain,
  int level,
  FLSlice message,
);

typedef _c_CBLLog_ConsoleLevel = ffi.Uint8 Function();

typedef _dart_CBLLog_ConsoleLevel = int Function();

typedef _c_CBLLog_SetConsoleLevel = ffi.Void Function(
  ffi.Uint8 arg0,
);

typedef _dart_CBLLog_SetConsoleLevel = void Function(
  int arg0,
);

typedef _c_CBLLog_CallbackLevel = ffi.Uint8 Function();

typedef _dart_CBLLog_CallbackLevel = int Function();

typedef _c_CBLLog_SetCallbackLevel = ffi.Void Function(
  ffi.Uint8 arg0,
);

typedef _dart_CBLLog_SetCallbackLevel = void Function(
  int arg0,
);

typedef CBLLogCallback = ffi.Void Function(
  ffi.Uint8,
  ffi.Uint8,
  FLSlice,
);

typedef _c_CBLLog_Callback = ffi.Pointer<ffi.NativeFunction<CBLLogCallback>>
    Function();

typedef _dart_CBLLog_Callback = ffi.Pointer<ffi.NativeFunction<CBLLogCallback>>
    Function();

typedef _c_CBLLog_SetCallback = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<CBLLogCallback>> callback,
);

typedef _dart_CBLLog_SetCallback = void Function(
  ffi.Pointer<ffi.NativeFunction<CBLLogCallback>> callback,
);

typedef _c_CBLLog_FileConfig = ffi.Pointer<CBLLogFileConfiguration> Function();

typedef _dart_CBLLog_FileConfig = ffi.Pointer<CBLLogFileConfiguration>
    Function();

typedef _c_CBLLog_SetFileConfig = ffi.Uint8 Function(
  CBLLogFileConfiguration arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLLog_SetFileConfig = int Function(
  CBLLogFileConfiguration arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_CreateQuery = ffi.Pointer<CBLQuery> Function(
  ffi.Pointer<CBLDatabase> db,
  ffi.Uint32 language,
  FLSlice queryString,
  ffi.Pointer<ffi.Int32> outErrorPos,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_CreateQuery = ffi.Pointer<CBLQuery> Function(
  ffi.Pointer<CBLDatabase> db,
  int language,
  FLSlice queryString,
  ffi.Pointer<ffi.Int32> outErrorPos,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLQuery_SetParameters = ffi.Void Function(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<FLDict> parameters,
);

typedef _dart_CBLQuery_SetParameters = void Function(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<FLDict> parameters,
);

typedef _c_CBLQuery_Parameters = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLQuery> query,
);

typedef _dart_CBLQuery_Parameters = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLQuery> query,
);

typedef _c_CBLQuery_Execute = ffi.Pointer<CBLResultSet> Function(
  ffi.Pointer<CBLQuery> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLQuery_Execute = ffi.Pointer<CBLResultSet> Function(
  ffi.Pointer<CBLQuery> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLQuery_Explain = FLSliceResult Function(
  ffi.Pointer<CBLQuery> arg0,
);

typedef _dart_CBLQuery_Explain = FLSliceResult Function(
  ffi.Pointer<CBLQuery> arg0,
);

typedef _c_CBLQuery_ColumnCount = ffi.Uint32 Function(
  ffi.Pointer<CBLQuery> arg0,
);

typedef _dart_CBLQuery_ColumnCount = int Function(
  ffi.Pointer<CBLQuery> arg0,
);

typedef _c_CBLQuery_ColumnName = FLSlice Function(
  ffi.Pointer<CBLQuery> arg0,
  ffi.Uint32 columnIndex,
);

typedef _dart_CBLQuery_ColumnName = FLSlice Function(
  ffi.Pointer<CBLQuery> arg0,
  int columnIndex,
);

typedef _c_CBLResultSet_Next = ffi.Uint8 Function(
  ffi.Pointer<CBLResultSet> arg0,
);

typedef _dart_CBLResultSet_Next = int Function(
  ffi.Pointer<CBLResultSet> arg0,
);

typedef _c_CBLResultSet_ValueAtIndex = ffi.Pointer<FLValue> Function(
  ffi.Pointer<CBLResultSet> arg0,
  ffi.Uint32 index,
);

typedef _dart_CBLResultSet_ValueAtIndex = ffi.Pointer<FLValue> Function(
  ffi.Pointer<CBLResultSet> arg0,
  int index,
);

typedef _c_CBLResultSet_ValueForKey = ffi.Pointer<FLValue> Function(
  ffi.Pointer<CBLResultSet> arg0,
  FLSlice key,
);

typedef _dart_CBLResultSet_ValueForKey = ffi.Pointer<FLValue> Function(
  ffi.Pointer<CBLResultSet> arg0,
  FLSlice key,
);

typedef _c_CBLResultSet_ResultArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<CBLResultSet> arg0,
);

typedef _dart_CBLResultSet_ResultArray = ffi.Pointer<FLArray> Function(
  ffi.Pointer<CBLResultSet> arg0,
);

typedef _c_CBLResultSet_ResultDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLResultSet> arg0,
);

typedef _dart_CBLResultSet_ResultDict = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLResultSet> arg0,
);

typedef _c_CBLResultSet_GetQuery = ffi.Pointer<CBLQuery> Function(
  ffi.Pointer<CBLResultSet> rs,
);

typedef _dart_CBLResultSet_GetQuery = ffi.Pointer<CBLQuery> Function(
  ffi.Pointer<CBLResultSet> rs,
);

typedef CBLQueryChangeListener = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLQuery>,
  ffi.Pointer<CBLListenerToken>,
);

typedef _c_CBLQuery_AddChangeListener = ffi.Pointer<CBLListenerToken> Function(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<ffi.NativeFunction<CBLQueryChangeListener>> listener,
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_CBLQuery_AddChangeListener = ffi.Pointer<CBLListenerToken>
    Function(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<ffi.NativeFunction<CBLQueryChangeListener>> listener,
  ffi.Pointer<ffi.Void> context,
);

typedef _c_CBLQuery_CopyCurrentResults = ffi.Pointer<CBLResultSet> Function(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<CBLListenerToken> listener,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLQuery_CopyCurrentResults = ffi.Pointer<CBLResultSet> Function(
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<CBLListenerToken> listener,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_CreateValueIndex = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice name,
  CBLValueIndexConfiguration config,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_CreateValueIndex = int Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice name,
  CBLValueIndexConfiguration config,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_CreateFullTextIndex = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice name,
  CBLFullTextIndexConfiguration config,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_CreateFullTextIndex = int Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice name,
  CBLFullTextIndexConfiguration config,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_DeleteIndex = ffi.Uint8 Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice name,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLDatabase_DeleteIndex = int Function(
  ffi.Pointer<CBLDatabase> db,
  FLSlice name,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLDatabase_GetIndexNames = ffi.Pointer<FLArray> Function(
  ffi.Pointer<CBLDatabase> db,
);

typedef _dart_CBLDatabase_GetIndexNames = ffi.Pointer<FLArray> Function(
  ffi.Pointer<CBLDatabase> db,
);

typedef _c_CBLEndpoint_CreateWithURL = ffi.Pointer<CBLEndpoint> Function(
  FLSlice url,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLEndpoint_CreateWithURL = ffi.Pointer<CBLEndpoint> Function(
  FLSlice url,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLEndpoint_Free = ffi.Void Function(
  ffi.Pointer<CBLEndpoint> arg0,
);

typedef _dart_CBLEndpoint_Free = void Function(
  ffi.Pointer<CBLEndpoint> arg0,
);

typedef _c_CBLAuth_CreatePassword = ffi.Pointer<CBLAuthenticator> Function(
  FLSlice username,
  FLSlice password,
);

typedef _dart_CBLAuth_CreatePassword = ffi.Pointer<CBLAuthenticator> Function(
  FLSlice username,
  FLSlice password,
);

typedef _c_CBLAuth_CreateSession = ffi.Pointer<CBLAuthenticator> Function(
  FLSlice sessionID,
  FLSlice cookieName,
);

typedef _dart_CBLAuth_CreateSession = ffi.Pointer<CBLAuthenticator> Function(
  FLSlice sessionID,
  FLSlice cookieName,
);

typedef _c_CBLAuth_Free = ffi.Void Function(
  ffi.Pointer<CBLAuthenticator> arg0,
);

typedef _dart_CBLAuth_Free = void Function(
  ffi.Pointer<CBLAuthenticator> arg0,
);

typedef CBLConflictResolver = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<ffi.Void>,
  FLSlice,
  ffi.Pointer<CBLDocument>,
  ffi.Pointer<CBLDocument>,
);

typedef _c_CBLReplicator_Create = ffi.Pointer<CBLReplicator> Function(
  ffi.Pointer<CBLReplicatorConfiguration> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLReplicator_Create = ffi.Pointer<CBLReplicator> Function(
  ffi.Pointer<CBLReplicatorConfiguration> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLReplicator_Config = ffi.Pointer<CBLReplicatorConfiguration>
    Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _dart_CBLReplicator_Config = ffi.Pointer<CBLReplicatorConfiguration>
    Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _c_CBLReplicator_Start = ffi.Void Function(
  ffi.Pointer<CBLReplicator> replicator,
  ffi.Uint8 resetCheckpoint,
);

typedef _dart_CBLReplicator_Start = void Function(
  ffi.Pointer<CBLReplicator> replicator,
  int resetCheckpoint,
);

typedef _c_CBLReplicator_Stop = ffi.Void Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _dart_CBLReplicator_Stop = void Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _c_CBLReplicator_SetHostReachable = ffi.Void Function(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Uint8 reachable,
);

typedef _dart_CBLReplicator_SetHostReachable = void Function(
  ffi.Pointer<CBLReplicator> arg0,
  int reachable,
);

typedef _c_CBLReplicator_SetSuspended = ffi.Void Function(
  ffi.Pointer<CBLReplicator> repl,
  ffi.Uint8 suspended,
);

typedef _dart_CBLReplicator_SetSuspended = void Function(
  ffi.Pointer<CBLReplicator> repl,
  int suspended,
);

typedef _c_CBLReplicator_Status = CBLReplicatorStatus Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _dart_CBLReplicator_Status = CBLReplicatorStatus Function(
  ffi.Pointer<CBLReplicator> arg0,
);

typedef _c_CBLReplicator_PendingDocumentIDs = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLReplicator_PendingDocumentIDs = ffi.Pointer<FLDict> Function(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Pointer<CBLError> outError,
);

typedef _c_CBLReplicator_IsDocumentPending = ffi.Uint8 Function(
  ffi.Pointer<CBLReplicator> repl,
  FLSlice docID,
  ffi.Pointer<CBLError> outError,
);

typedef _dart_CBLReplicator_IsDocumentPending = int Function(
  ffi.Pointer<CBLReplicator> repl,
  FLSlice docID,
  ffi.Pointer<CBLError> outError,
);

typedef CBLReplicatorChangeListener = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLReplicator>,
  ffi.Pointer<CBLReplicatorStatus>,
);

typedef _c_CBLReplicator_AddChangeListener = ffi.Pointer<CBLListenerToken>
    Function(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Pointer<ffi.NativeFunction<CBLReplicatorChangeListener>> arg1,
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_CBLReplicator_AddChangeListener = ffi.Pointer<CBLListenerToken>
    Function(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Pointer<ffi.NativeFunction<CBLReplicatorChangeListener>> arg1,
  ffi.Pointer<ffi.Void> context,
);

typedef CBLDocumentReplicationListener = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLReplicator>,
  ffi.Uint8,
  ffi.Uint32,
  ffi.Pointer<CBLReplicatedDocument>,
);

typedef _c_CBLReplicator_AddDocumentReplicationListener
    = ffi.Pointer<CBLListenerToken> Function(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Pointer<ffi.NativeFunction<CBLDocumentReplicationListener>> arg1,
  ffi.Pointer<ffi.Void> context,
);

typedef _dart_CBLReplicator_AddDocumentReplicationListener
    = ffi.Pointer<CBLListenerToken> Function(
  ffi.Pointer<CBLReplicator> arg0,
  ffi.Pointer<ffi.NativeFunction<CBLDocumentReplicationListener>> arg1,
  ffi.Pointer<ffi.Void> context,
);

typedef Dart_PostCObjectType = ffi.Uint8 Function(
  ffi.Int64,
  ffi.Pointer<Dart_CObject>,
);

typedef _c_CBLDart_PostCObject = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<Dart_PostCObjectType>> function_pointer,
);

typedef _dart_CBLDart_PostCObject = void Function(
  ffi.Pointer<ffi.NativeFunction<Dart_PostCObjectType>> function_pointer,
);

typedef Dart_NativeMessageHandler = ffi.Void Function(
  ffi.Int64,
  ffi.Pointer<Dart_CObject>,
);

typedef Dart_NewNativePortType = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.NativeFunction<Dart_NativeMessageHandler>>,
  ffi.Uint8,
);

typedef _c_CBLDart_NewNativePort = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<Dart_NewNativePortType>> function_pointer,
);

typedef _dart_CBLDart_NewNativePort = void Function(
  ffi.Pointer<ffi.NativeFunction<Dart_NewNativePortType>> function_pointer,
);

typedef Dart_CloseNativePortType = ffi.Uint8 Function(
  ffi.Int64,
);

typedef _c_CBLDart_CloseNativePort = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<Dart_CloseNativePortType>> function_pointer,
);

typedef _dart_CBLDart_CloseNativePort = void Function(
  ffi.Pointer<ffi.NativeFunction<Dart_CloseNativePortType>> function_pointer,
);

typedef CBLDart_ReplicatorStatusCallback = ffi.Void Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<FLDict>,
);

typedef CBLDart_ReplicatorFilterCallback = ffi.Uint8 Function(
  ffi.Uint8,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<CBLDocument>,
  ffi.Uint8,
);

typedef CBLDart_ConflictResolverCallback = ffi.Pointer<CBLDocument> Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<CBLDocument>,
  ffi.Pointer<CBLDocument>,
);

typedef _c_CBLDart_RegisterPorts = ffi.Void Function(
  ffi.Uint64 database_listener_port,
  ffi.Uint64 document_listener_port,
  ffi.Uint64 query_listener_port,
  ffi.Uint64 replicator_status_port,
  ffi.Uint64 replicator_filter_port,
  ffi.Uint64 replicator_conflict_port,
  ffi.Pointer<ffi.NativeFunction<CBLDart_ReplicatorStatusCallback>>
      replicator_status_callback,
  ffi.Pointer<ffi.NativeFunction<CBLDart_ReplicatorFilterCallback>>
      replicator_filter_callback,
  ffi.Pointer<ffi.NativeFunction<CBLDart_ConflictResolverCallback>>
      replicator_conflict_callback,
);

typedef _dart_CBLDart_RegisterPorts = void Function(
  int database_listener_port,
  int document_listener_port,
  int query_listener_port,
  int replicator_status_port,
  int replicator_filter_port,
  int replicator_conflict_port,
  ffi.Pointer<ffi.NativeFunction<CBLDart_ReplicatorStatusCallback>>
      replicator_status_callback,
  ffi.Pointer<ffi.NativeFunction<CBLDart_ReplicatorFilterCallback>>
      replicator_filter_callback,
  ffi.Pointer<ffi.NativeFunction<CBLDart_ConflictResolverCallback>>
      replicator_conflict_callback,
);

typedef Work = ffi.Void Function();

typedef _c_CBLDart_ExecuteCallback = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<Work>>> work_ptr,
);

typedef _dart_CBLDart_ExecuteCallback = void Function(
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<Work>>> work_ptr,
);

typedef _c_CBLDart_DatabaseChangeListener = ffi.Void Function(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLDatabase> db,
  ffi.Uint32 numDocs,
  ffi.Pointer<FLSlice> docIDs,
);

typedef _dart_CBLDart_DatabaseChangeListener = void Function(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLDatabase> db,
  int numDocs,
  ffi.Pointer<FLSlice> docIDs,
);

typedef _c_CBLDart_DocumentChangeListener = ffi.Void Function(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLDatabase> db,
  FLSlice docID,
);

typedef _dart_CBLDart_DocumentChangeListener = void Function(
  ffi.Pointer<ffi.Void> context,
  ffi.Pointer<CBLDatabase> db,
  FLSlice docID,
);

typedef _c_CBLDart_QueryChangeListener = ffi.Void Function(
  ffi.Pointer<ffi.Void> queryId,
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<CBLListenerToken> token,
);

typedef _dart_CBLDart_QueryChangeListener = void Function(
  ffi.Pointer<ffi.Void> queryId,
  ffi.Pointer<CBLQuery> query,
  ffi.Pointer<CBLListenerToken> token,
);

typedef CBLReplicationFilter = ffi.Uint8 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CBLDocument>,
  ffi.Uint32,
);
